SuperMap.String = {
    startsWith: function(c, a) {
        return ( c.indexOf(a) == 0)
    },
    contains: function(c, a) {
        return ( c.indexOf(a) != -1)
    },
    trim: function(a) {
        return a.replace(/^\s\s*/, "").replace(/\s\s*$/, "")
    },
    camelize: function(g) {
        var e = g.split("-");
        var c = e[0];
        for (var d = 1, a = e.length; d < a; d++) {
            var f = e[d];
            c += f.charAt(0).toUpperCase() + f.substring(1)
        }
        return c
    },
    format: function(e, d, a) {
        if (!d) {
            d = window
        }
        var c = function(k, f) {
            var j;
            var h = f.split(/\.+/);
            for (var g = 0; g < h.length; g++) {
                if (g == 0) {
                    j = d
                }
                j = j[h[g]]
            }
            if (typeof j == "function") {
                j = a ? j.apply(null, a) : j()
            }
            if (typeof j == "undefined") {
                return "undefined"
            } else {
                return j
            }
        };
        return e.replace(SuperMap.String.tokenRegEx, c)
    },
    tokenRegEx: /\$\{([\w.]+?)\}/g,
    numberRegEx: /^([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$/,
    isNumeric: function(a) {
        return SuperMap.String.numberRegEx.test(a)
    },
    numericIf: function(a) {
        return SuperMap.String.isNumeric(a) ? parseFloat(a) : a
    }
};
SuperMap.Number = {
    decimalSeparator: ".",
    thousandsSeparator: ",",
    limitSigDigs: function(a, d) {
        var c = 0;
        if (d > 0) {
            c = parseFloat(a.toPrecision(d))
        }
        return c
    },
    format: function(d, a, h, j) {
        a = (typeof a != "undefined") ? a : 0;
        h = (typeof h != "undefined") ? h : SuperMap.Number.thousandsSeparator;
        j = (typeof j != "undefined") ? j : SuperMap.Number.decimalSeparator;
        if (a != null) {
            d = parseFloat(d.toFixed(a))
        }
        var c = d.toString().split(".");
        if (c.length == 1 && a == null) {
            a = 0
        }
        var e = c[0];
        if (h) {
            var f = /(-?[0-9]+)([0-9]{3})/;
            while (f.test(e)) {
                e = e.replace(f, "$1" + h + "$2")
            }
        }
        var g;
        if (a == 0) {
            g = e
        } else {
            var i = c.length > 1 ? c[1] : "0";
            if (a != null) {
                i = i + new Array(a - i.length + 1).join("0")
            }
            g = e + j + i
        }
        return g
    }
};
if (!Number.prototype.limitSigDigs) {
    Number.prototype.limitSigDigs = function(a) {
        return SuperMap.Number.limitSigDigs(this, a)
    }
}
SuperMap.Function = {
    bind: function(d, c) {
        var a = Array.prototype.slice.apply(arguments, [2]);
        return function() {
            var e = a.concat(Array.prototype.slice.apply(arguments, [0]));
            return d.apply(c, e)
        }
    },
    bindAsEventListener: function(c, a) {
        return function(d) {
            return c.call(a, d || window.event)
        }
    },
    False: function() {
        return false
    },
    True: function() {
        return true
    },
    Void: function() {}
};
SuperMap.Array = {
    filter: function(h, g, c) {
        var e = [];
        if (Array.prototype.filter) {
            e = h.filter(g, c)
        } else {
            var a = h.length;
            if (typeof g != "function") {
                throw new TypeError()
            }
            for (var d = 0; d < a; d++) {
                if (d in h) {
                    var f = h[d];
                    if (g.call(c, f, d, h)) {
                        e.push(f)
                    }
                }
            }
        }
        return e
    }
};
SuperMap.Bounds = SuperMap.Class({
    left: null,
    bottom: null,
    right: null,
    top: null,
    centerLonLat: null,
    initialize: function(e, a, c, d) {
        if (SuperMap.Util.isArray(e)) {
            d = e[3];
            c = e[2];
            a = e[1];
            e = e[0]
        }
        if (e != null) {
            this.left = SuperMap.Util.toFloat(e)
        }
        if (a != null) {
            this.bottom = SuperMap.Util.toFloat(a)
        }
        if (c != null) {
            this.right = SuperMap.Util.toFloat(c)
        }
        if (d != null) {
            this.top = SuperMap.Util.toFloat(d)
        }
    },
    clone: function() {
        return new SuperMap.Bounds(this.left,this.bottom,this.right,this.top)
    },
    equals: function(c) {
        var a = false;
        if (c != null) {
            a = ((this.left == c.left) && (this.right == c.right) && (this.top == c.top) && (this.bottom == c.bottom))
        }
        return a
    },
    toString: function() {
        return [this.left, this.bottom, this.right, this.top].join(",")
    },
    toArray: function(a) {
        if (a === true) {
            return [this.bottom, this.left, this.top, this.right]
        } else {
            return [this.left, this.bottom, this.right, this.top]
        }
    },
    toBBOX: function(c, f) {
        if (c == null) {
            c = 6
        }
        var h = Math.pow(10, c);
        var g = Math.round(this.left * h) / h;
        var e = Math.round(this.bottom * h) / h;
        var d = Math.round(this.right * h) / h;
        var a = Math.round(this.top * h) / h;
        if (f === true) {
            return e + "," + g + "," + a + "," + d
        } else {
            return g + "," + e + "," + d + "," + a
        }
    },
    toGeometry: function() {
        return new SuperMap.Geometry.Polygon([new SuperMap.Geometry.LinearRing([new SuperMap.Geometry.Point(this.left,this.bottom), new SuperMap.Geometry.Point(this.right,this.bottom), new SuperMap.Geometry.Point(this.right,this.top), new SuperMap.Geometry.Point(this.left,this.top)])])
    },
    getWidth: function() {
        return ( this.right - this.left)
    },
    getHeight: function() {
        return ( this.top - this.bottom)
    },
    getSize: function() {
        return new SuperMap.Size(this.getWidth(),this.getHeight())
    },
    getCenterPixel: function() {
        return new SuperMap.Pixel((this.left + this.right) / 2,(this.bottom + this.top) / 2)
    },
    getCenterLonLat: function() {
        if (!this.centerLonLat) {
            this.centerLonLat = new SuperMap.LonLat((this.left + this.right) / 2,(this.bottom + this.top) / 2)
        }
        return this.centerLonLat
    },
    scale: function(f, d) {
        if (d == null) {
            d = this.getCenterLonLat()
        }
        var a, i;
        if (d.CLASS_NAME == "SuperMap.LonLat") {
            a = d.lon;
            i = d.lat
        } else {
            a = d.x;
            i = d.y
        }
        var h = (this.left - a) * f + a;
        var c = (this.bottom - i) * f + i;
        var e = (this.right - a) * f + a;
        var g = (this.top - i) * f + i;
        return new SuperMap.Bounds(h,c,e,g)
    },
    add: function(a, c) {
        if ((a == null) || (c == null)) {
            throw new TypeError("Bounds.add cannot receive null values")
        }
        return new SuperMap.Bounds(this.left + a,this.bottom + c,this.right + a,this.top + c)
    },
    extend: function(a) {
        var c = null;
        if (a) {
            switch (a.CLASS_NAME) {
            case "SuperMap.LonLat":
                c = new SuperMap.Bounds(a.lon,a.lat,a.lon,a.lat);
                break;
            case "SuperMap.Geometry.Point":
                c = new SuperMap.Bounds(a.x,a.y,a.x,a.y);
                break;
            case "SuperMap.Bounds":
                c = a;
                break
            }
            if (c) {
                this.centerLonLat = null;
                if ((this.left == null) || (c.left < this.left)) {
                    this.left = c.left
                }
                if ((this.bottom == null) || (c.bottom < this.bottom)) {
                    this.bottom = c.bottom
                }
                if ((this.right == null) || (c.right > this.right)) {
                    this.right = c.right
                }
                if ((this.top == null) || (c.top > this.top)) {
                    this.top = c.top
                }
            }
        }
    },
    containsLonLat: function(g, d) {
        if (typeof d === "boolean") {
            d = {
                inclusive: d
            }
        }
        d = d || {};
        var e = this.contains(g.lon, g.lat, d.inclusive)
          , f = d.worldBounds;
        if (f && !e) {
            var h = f.getWidth();
            var a = (f.left + f.right) / 2;
            var c = Math.round((g.lon - a) / h);
            e = this.containsLonLat({
                lon: g.lon - c * h,
                lat: g.lat
            }, {
                inclusive: d.inclusive
            })
        }
        return e
    },
    containsPixel: function(c, a) {
        return this.contains(c.x, c.y, a)
    },
    contains: function(c, e, a) {
        if (a == null) {
            a = true
        }
        if (c == null || e == null) {
            return false
        }
        c = SuperMap.Util.toFloat(c);
        e = SuperMap.Util.toFloat(e);
        var d = false;
        if (a) {
            d = ((c >= this.left) && (c <= this.right) && (e >= this.bottom) && (e <= this.top))
        } else {
            d = ((c > this.left) && (c < this.right) && (e > this.bottom) && (e < this.top))
        }
        return d
    },
    intersectsBounds: function(a, n) {
        if (typeof n === "boolean") {
            n = {
                inclusive: n
            }
        }
        n = n || {};
        if (n.worldBounds) {
            var m = this.wrapDateLine(n.worldBounds);
            a = a.wrapDateLine(n.worldBounds)
        } else {
            m = this
        }
        if (n.inclusive == null) {
            n.inclusive = true
        }
        var i = false;
        var j = (m.left == a.right || m.right == a.left || m.top == a.bottom || m.bottom == a.top);
        if (n.inclusive || !j) {
            var k = (((a.bottom >= m.bottom) && (a.bottom <= m.top)) || ((m.bottom >= a.bottom) && (m.bottom <= a.top)));
            var l = (((a.top >= m.bottom) && (a.top <= m.top)) || ((m.top > a.bottom) && (m.top < a.top)));
            var e = (((a.left >= m.left) && (a.left <= m.right)) || ((m.left >= a.left) && (m.left <= a.right)));
            var d = (((a.right >= m.left) && (a.right <= m.right)) || ((m.right >= a.left) && (m.right <= a.right)));
            i = ((k || l) && (e || d))
        }
        if (n.worldBounds && !i) {
            var h = n.worldBounds;
            var c = h.getWidth();
            var g = !h.containsBounds(m);
            var f = !h.containsBounds(a);
            if (g && !f) {
                a = a.add(-c, 0);
                i = m.intersectsBounds(a, {
                    inclusive: n.inclusive
                })
            } else {
                if (f && !g) {
                    m = m.add(-c, 0);
                    i = a.intersectsBounds(m, {
                        inclusive: n.inclusive
                    })
                }
            }
        }
        return i
    },
    containsBounds: function(h, c, a) {
        if (c == null) {
            c = false
        }
        if (a == null) {
            a = true
        }
        var d = this.contains(h.left, h.bottom, a);
        var e = this.contains(h.right, h.bottom, a);
        var g = this.contains(h.left, h.top, a);
        var f = this.contains(h.right, h.top, a);
        return (c) ? (d || e || g || f) : (d && e && g && f)
    },
    determineQuadrant: function(d) {
        var c = "";
        var a = this.getCenterLonLat();
        c += (d.lat < a.lat) ? "b" : "t";
        c += (d.lon < a.lon) ? "l" : "r";
        return c
    },
    transform: function(e, c) {
        this.centerLonLat = null;
        var f = SuperMap.Projection.transform({
            x: this.left,
            y: this.bottom
        }, e, c);
        var a = SuperMap.Projection.transform({
            x: this.right,
            y: this.bottom
        }, e, c);
        var d = SuperMap.Projection.transform({
            x: this.left,
            y: this.top
        }, e, c);
        var g = SuperMap.Projection.transform({
            x: this.right,
            y: this.top
        }, e, c);
        this.left = Math.min(f.x, d.x);
        this.bottom = Math.min(f.y, a.y);
        this.right = Math.max(a.x, g.x);
        this.top = Math.max(d.y, g.y);
        return this
    },
    wrapDateLine: function(a, d) {
        d = d || {};
        var f = d.leftTolerance || 0;
        var c = d.rightTolerance || 0;
        var h = this.clone();
        if (a) {
            var e = a.getWidth();
            while (h.left < a.left && h.right - c <= a.left) {
                h = h.add(e, 0)
            }
            while (h.left + f >= a.right && h.right > a.right) {
                h = h.add(-e, 0)
            }
            var g = h.left + f;
            if (g < a.right && g > a.left && h.right - c > a.right) {
                h = h.add(-e, 0)
            }
        }
        return h
    },
    toServerJSONObject: function() {
        var a = {
            rightTop: {
                x: this.right,
                y: this.top
            },
            leftBottom: {
                x: this.left,
                y: this.bottom
            },
            left: this.left,
            right: this.right,
            top: this.top,
            bottom: this.bottom
        };
        return a
    },
    CLASS_NAME: "SuperMap.Bounds"
});
SuperMap.Bounds.fromString = function(d, c) {
    var a = d.split(",");
    return SuperMap.Bounds.fromArray(a, c)
}
;
SuperMap.Bounds.fromArray = function(c, a) {
    return a === true ? new SuperMap.Bounds(c[1],c[0],c[3],c[2]) : new SuperMap.Bounds(c[0],c[1],c[2],c[3])
}
;
SuperMap.Bounds.fromSize = function(a) {
    return new SuperMap.Bounds(0,a.h,a.w,0)
}
;
SuperMap.Bounds.oppositeQuadrant = function(a) {
    var c = "";
    c += (a.charAt(0) == "t") ? "b" : "t";
    c += (a.charAt(1) == "l") ? "r" : "l";
    return c
}
;
SuperMap.Date = {
    toISOString: (function() {
        if ("toISOString"in Date.prototype) {
            return function(c) {
                return c.toISOString()
            }
        } else {
            function a(d, c) {
                var e = d + "";
                while (e.length < c) {
                    e = "0" + e
                }
                return e
            }
            return function(c) {
                var d;
                if (isNaN(c.getTime())) {
                    d = "Invalid Date"
                } else {
                    d = c.getUTCFullYear() + "-" + a(c.getUTCMonth() + 1, 2) + "-" + a(c.getUTCDate(), 2) + "T" + a(c.getUTCHours(), 2) + ":" + a(c.getUTCMinutes(), 2) + ":" + a(c.getUTCSeconds(), 2) + "." + a(c.getUTCMilliseconds(), 3) + "Z"
                }
                return d
            }
        }
    })(),
    parse: function(k) {
        var c;
        var i = k.match(/^(?:(\d{4})(?:-(\d{2})(?:-(\d{2}))?)?)?(?:(?:T(\d{1,2}):(\d{2}):(\d{2}(?:\.\d+)?)(Z|(?:[+-]\d{1,2}(?::(\d{2}))?)))|Z)?$/);
        if (i && (i[1] || i[7])) {
            var l = parseInt(i[1], 10) || 0;
            var j = (parseInt(i[2], 10) - 1) || 0;
            var n = parseInt(i[3], 10) || 1;
            c = new Date(Date.UTC(l, j, n));
            var m = i[7];
            if (m) {
                var o = parseInt(i[4], 10);
                var e = parseInt(i[5], 10);
                var a = parseFloat(i[6]);
                var p = a | 0;
                var d = Math.round(1000 * (a - p));
                c.setUTCHours(o, e, p, d);
                if (m !== "Z") {
                    var h = parseInt(m, 10);
                    var g = parseInt(i[8], 10) || 0;
                    var f = -1000 * (60 * (h * 60) + g * 60);
                    c = new Date(c.getTime() + f)
                }
            }
        } else {
            c = new Date("invalid")
        }
        return c
    }
};
SuperMap.Element = {
    visible: function(a) {
        return SuperMap.Util.getElement(a).style.display != "none"
    },
    toggle: function() {
        for (var d = 0, a = arguments.length; d < a; d++) {
            var c = SuperMap.Util.getElement(arguments[d]);
            var e = SuperMap.Element.visible(c) ? "none" : "";
            c.style.display = e
        }
    },
    remove: function(a) {
        a = SuperMap.Util.getElement(a);
        a.parentNode.removeChild(a)
    },
    getHeight: function(a) {
        a = SuperMap.Util.getElement(a);
        return a.offsetHeight
    },
    hasClass: function(c, a) {
        var d = c.className;
        return ( !!d && new RegExp("(^|\\s)" + a + "(\\s|$)").test(d))
    },
    addClass: function(c, a) {
        if (!SuperMap.Element.hasClass(c, a)) {
            c.className += (c.className ? " " : "") + a
        }
        return c
    },
    removeClass: function(c, a) {
        var d = c.className;
        if (d) {
            c.className = SuperMap.String.trim(d.replace(new RegExp("(^|\\s+)" + a + "(\\s+|$)"), " "))
        }
        return c
    },
    toggleClass: function(c, a) {
        if (SuperMap.Element.hasClass(c, a)) {
            SuperMap.Element.removeClass(c, a)
        } else {
            SuperMap.Element.addClass(c, a)
        }
        return c
    },
    getStyle: function(d, e) {
        d = SuperMap.Util.getElement(d);
        var f = null;
        if (d && d.style) {
            f = d.style[SuperMap.String.camelize(e)];
            if (!f) {
                if (document.defaultView && document.defaultView.getComputedStyle) {
                    var c = document.defaultView.getComputedStyle(d, null);
                    f = c ? c.getPropertyValue(e) : null
                } else {
                    if (d.currentStyle) {
                        f = d.currentStyle[SuperMap.String.camelize(e)]
                    }
                }
            }
            var a = ["left", "top", "right", "bottom"];
            if (window.opera && (SuperMap.Util.indexOf(a, e) != -1) && (SuperMap.Element.getStyle(d, "position") == "static")) {
                f = "auto"
            }
        }
        return f == "auto" ? null : f
    }
};
SuperMap.LonLat = SuperMap.Class({
    lon: 0,
    lat: 0,
    initialize: function(c, a) {
        if (SuperMap.Util.isArray(c)) {
            a = c[1];
            c = c[0]
        }
        this.lon = SuperMap.Util.toFloat(c);
        this.lat = SuperMap.Util.toFloat(a)
    },
    toString: function() {
        return ( "lon=" + this.lon + ",lat=" + this.lat)
    },
    toShortString: function() {
        return ( this.lon + ", " + this.lat)
    },
    clone: function() {
        return new SuperMap.LonLat(this.lon,this.lat)
    },
    add: function(c, a) {
        if ((c == null) || (a == null)) {
            throw new TypeError("LonLat.add cannot receive null values")
        }
        return new SuperMap.LonLat(this.lon + SuperMap.Util.toFloat(c),this.lat + SuperMap.Util.toFloat(a))
    },
    equals: function(c) {
        var a = false;
        if (c != null) {
            a = ((this.lon == c.lon && this.lat == c.lat) || (isNaN(this.lon) && isNaN(this.lat) && isNaN(c.lon) && isNaN(c.lat)))
        }
        return a
    },
    transform: function(d, c) {
        var a = SuperMap.Projection.transform({
            x: this.lon,
            y: this.lat
        }, d, c);
        this.lon = a.x;
        this.lat = a.y;
        return this
    },
    wrapDateLine: function(a) {
        var c = this.clone();
        if (a) {
            while (c.lon < a.left) {
                c.lon += a.getWidth()
            }
            while (c.lon > a.right) {
                c.lon -= a.getWidth()
            }
        }
        return c
    },
    CLASS_NAME: "SuperMap.LonLat"
});
SuperMap.LonLat.fromString = function(c) {
    var a = c.split(",");
    return new SuperMap.LonLat(a[0],a[1])
}
;
SuperMap.LonLat.fromArray = function(a) {
    var c = SuperMap.Util.isArray(a)
      , e = c && a[0]
      , d = c && a[1];
    return new SuperMap.LonLat(e,d)
}
;
SuperMap.Pixel = SuperMap.Class({
    x: 0,
    y: 0,
    initialize: function(a, c) {
        this.x = parseFloat(a);
        this.y = parseFloat(c)
    },
    toString: function() {
        return ( "x=" + this.x + ",y=" + this.y)
    },
    clone: function() {
        return new SuperMap.Pixel(this.x,this.y)
    },
    equals: function(a) {
        var c = false;
        if (a != null) {
            c = ((this.x == a.x && this.y == a.y) || (isNaN(this.x) && isNaN(this.y) && isNaN(a.x) && isNaN(a.y)))
        }
        return c
    },
    distanceTo: function(a) {
        return Math.sqrt(Math.pow(this.x - a.x, 2) + Math.pow(this.y - a.y, 2))
    },
    add: function(a, c) {
        if ((a == null) || (c == null)) {
            throw new TypeError("Pixel.add cannot receive null values")
        }
        return new SuperMap.Pixel(this.x + a,this.y + c)
    },
    offset: function(a) {
        var c = this.clone();
        if (a) {
            c = this.add(a.x, a.y)
        }
        return c
    },
    CLASS_NAME: "SuperMap.Pixel"
});
SuperMap.Size = SuperMap.Class({
    w: 0,
    h: 0,
    initialize: function(a, c) {
        this.w = parseFloat(a);
        this.h = parseFloat(c)
    },
    toString: function() {
        return ( "w=" + this.w + ",h=" + this.h)
    },
    clone: function() {
        return new SuperMap.Size(this.w,this.h)
    },
    equals: function(c) {
        var a = false;
        if (c != null) {
            a = ((this.w == c.w && this.h == c.h) || (isNaN(this.w) && isNaN(this.h) && isNaN(c.w) && isNaN(c.h)))
        }
        return a
    },
    CLASS_NAME: "SuperMap.Size"
});
SuperMap.Credential = SuperMap.Class({
    value: "",
    name: "token",
    initialize: function(c, a) {
        if (c) {
            this.value = c
        }
        if (a) {
            this.name = a
        }
    },
    getUrlParameters: function() {
        return this.name + "=" + this.value
    },
    getValue: function() {
        return this.value
    },
    CLASS_NAME: "SuperMap.Credential"
});
SuperMap.Credential.CREDENTIAL = null;
SuperMap.Tween = SuperMap.Class({
    INTERVAL: 10,
    Easing: null,
    begin: null,
    finish: null,
    duration: null,
    callbacks: null,
    time: null,
    interval: null,
    playing: false,
    initialize: function(a) {
        this.easing = (a) ? a : SuperMap.Easing.Expo.easeOut
    },
    start: function(d, c, e, a) {
        this.playing = true;
        this.begin = d;
        this.finish = c;
        this.duration = e;
        this.callbacks = a.callbacks;
        this.time = 0;
        if (this.interval) {
            window.clearInterval(this.interval);
            this.interval = null
        }
        if (this.callbacks && this.callbacks.start) {
            this.callbacks.start.call(this, this.begin)
        }
        this.interval = window.setInterval(SuperMap.Function.bind(this.play, this), this.INTERVAL)
    },
    stop: function() {
        if (!this.playing) {
            return
        }
        if (this.callbacks && this.callbacks.done) {
            this.callbacks.done.call(this, this.finish)
        }
        window.clearInterval(this.interval);
        this.interval = null;
        this.playing = false
    },
    play: function() {
        var g = {};
        for (var d in this.begin) {
            var a = this.begin[d];
            var e = this.finish[d];
            if (a == null || e == null || isNaN(a) || isNaN(e)) {
                throw new TypeError("invalid value for Tween")
            }
            var h = e - a;
            g[d] = this.easing.apply(this, [this.time, a, h, this.duration])
        }
        this.time++;
        if (this.callbacks && this.callbacks.eachStep) {
            this.callbacks.eachStep.call(this, g)
        }
        if (this.time > this.duration) {
            this.stop()
        }
    },
    CLASS_NAME: "SuperMap.Tween"
});
SuperMap.Easing = {
    CLASS_NAME: "SuperMap.Easing"
};
SuperMap.Easing.Linear = {
    easeIn: function(e, a, g, f) {
        return g * e / f + a
    },
    easeOut: function(e, a, g, f) {
        return g * e / f + a
    },
    easeInOut: function(e, a, g, f) {
        return g * e / f + a
    },
    CLASS_NAME: "SuperMap.Easing.Linear"
};
SuperMap.Easing.Expo = {
    easeIn: function(e, a, g, f) {
        return (e == 0) ? a : g * Math.pow(2, 10 * (e / f - 1)) + a
    },
    easeOut: function(e, a, g, f) {
        return (e == f) ? a + g : g * (-Math.pow(2, -10 * e / f) + 1) + a
    },
    easeInOut: function(e, a, g, f) {
        if (e == 0) {
            return a
        }
        if (e == f) {
            return a + g
        }
        if ((e /= f / 2) < 1) {
            return g / 2 * Math.pow(2, 10 * (e - 1)) + a
        }
        return g / 2 * (-Math.pow(2, -10 * --e) + 2) + a
    },
    CLASS_NAME: "SuperMap.Easing.Expo"
};
SuperMap.Easing.Quad = {
    easeIn: function(e, a, g, f) {
        return g * (e /= f) * e + a
    },
    easeOut: function(e, a, g, f) {
        return -g * (e /= f) * (e - 2) + a
    },
    easeInOut: function(e, a, g, f) {
        if ((e /= f / 2) < 1) {
            return g / 2 * e * e + a
        }
        return -g / 2 * ((--e) * (e - 2) - 1) + a
    },
    CLASS_NAME: "SuperMap.Easing.Quad"
};
SuperMap.Kinetic = SuperMap.Class({
    threshold: 0,
    interval: 10,
    deceleration: 0.0155,
    nbPoints: 100,
    delay: 200,
    points: undefined,
    timerId: undefined,
    initialize: function(a) {
        SuperMap.Util.extend(this, a)
    },
    begin: function() {
        clearInterval(this.timerId);
        this.timerId = undefined;
        this.points = []
    },
    update: function(a) {
        this.points.unshift({
            xy: a,
            tick: new Date().getTime()
        });
        if (this.points.length > this.nbPoints) {
            this.points.pop()
        }
    },
    end: function(m) {
        var k, a = new Date().getTime();
        for (var g = 0, f = this.points.length, j; g < f; g++) {
            j = this.points[g];
            if (a - j.tick > this.delay) {
                break
            }
            k = j
        }
        if (!k) {
            return
        }
        var e = new Date().getTime() - k.tick;
        var h = Math.sqrt(Math.pow(m.x - k.xy.x, 2) + Math.pow(m.y - k.xy.y, 2));
        var d = h / e;
        if (d == 0 || d < this.threshold) {
            return
        }
        var c = Math.asin((m.y - k.xy.y) / h);
        if (k.xy.x <= m.x) {
            c = Math.PI - c
        }
        return {
            speed: d,
            theta: c
        }
    },
    move: function(d, k) {
        var j = d.speed;
        var h = Math.cos(d.theta);
        var g = -Math.sin(d.theta);
        var f = 0;
        var e = new Date().getTime();
        var c = 0;
        var a = 0;
        var i = function() {
            if (this.timerId == null) {
                return
            }
            f += this.interval;
            var r = new Date().getTime() - e;
            var o = (f + r) / 2;
            var q = (-this.deceleration * Math.pow(o, 2)) / 2 + j * o;
            var l = q * h;
            var s = q * g;
            var n = {};
            n.end = false;
            var m = -this.deceleration * o + j;
            if (m <= 0) {
                clearInterval(this.timerId);
                this.timerId = null;
                n.end = true
            }
            n.x = l - c;
            n.y = s - a;
            c = l;
            a = s;
            k(n.x, n.y, n.end)
        };
        this.timerId = window.setInterval(SuperMap.Function.bind(i, this), this.interval)
    },
    CLASS_NAME: "SuperMap.Kinetic"
});
SuperMap.Event = {
    observers: false,
    KEY_SPACE: 32,
    KEY_BACKSPACE: 8,
    KEY_TAB: 9,
    KEY_RETURN: 13,
    KEY_ESC: 27,
    KEY_LEFT: 37,
    KEY_UP: 38,
    KEY_RIGHT: 39,
    KEY_DOWN: 40,
    KEY_DELETE: 46,
    element: function(a) {
        return a.target || a.srcElement
    },
    isSingleTouch: function(a) {
        return a.touches && a.touches.length == 1
    },
    isMultiTouch: function(a) {
        return a.touches && a.touches.length > 1
    },
    isLeftClick: function(a) {
        return ( ((a.which) && (a.which == 1)) || ((a.button) && (a.button == 1)))
    },
    isRightClick: function(a) {
        return ( ((a.which) && (a.which == 3)) || ((a.button) && (a.button == 2)))
    },
    stop: function(c, a) {
        if (!a) {
            if (c.preventDefault) {
                c.preventDefault()
            } else {
                c.returnValue = false
            }
        }
        if (c.stopPropagation) {
            c.stopPropagation()
        } else {
            c.cancelBubble = true
        }
    },
    findElement: function(d, c) {
        var a = SuperMap.Event.element(d);
        while (a.parentNode && (!a.tagName || (a.tagName.toUpperCase() != c.toUpperCase()))) {
            a = a.parentNode
        }
        return a
    },
    observe: function(c, e, d, a) {
        var f = SuperMap.Util.getElement(c);
        a = a || false;
        if (e == "keypress" && (navigator.appVersion.match(/Konqueror|Safari|KHTML/) || f.attachEvent)) {
            e = "keydown"
        }
        if (!this.observers) {
            this.observers = {}
        }
        if (!f._eventCacheID) {
            var g = "eventCacheID_";
            if (f.id) {
                g = f.id + "_" + g
            }
            f._eventCacheID = SuperMap.Util.createUniqueID(g)
        }
        var h = f._eventCacheID;
        if (!this.observers[h]) {
            this.observers[h] = []
        }
        this.observers[h].push({
            element: f,
            name: e,
            observer: d,
            useCapture: a
        });
        if (f.addEventListener) {
            f.addEventListener(e, d, a)
        } else {
            if (f.attachEvent) {
                f.attachEvent("on" + e, d)
            }
        }
    },
    stopObservingElement: function(a) {
        var c = SuperMap.Util.getElement(a);
        var d = c._eventCacheID;
        this._removeElementObservers(SuperMap.Event.observers[d])
    },
    _removeElementObservers: function(f) {
        if (f) {
            for (var c = f.length - 1; c >= 0; c--) {
                var d = f[c];
                var a = new Array(d.element,d.name,d.observer,d.useCapture);
                var e = SuperMap.Event.stopObserving.apply(this, a)
            }
        }
    },
    stopObserving: function(j, a, h, c) {
        c = c || false;
        var g = SuperMap.Util.getElement(j);
        var e = g._eventCacheID;
        if (a == "keypress") {
            if (navigator.appVersion.match(/Konqueror|Safari|KHTML/) || g.detachEvent) {
                a = "keydown"
            }
        }
        var l = false;
        var d = SuperMap.Event.observers[e];
        if (d) {
            var f = 0;
            while (!l && f < d.length) {
                var k = d[f];
                if ((k.name == a) && (k.observer == h) && (k.useCapture == c)) {
                    d.splice(f, 1);
                    if (d.length == 0) {
                        delete SuperMap.Event.observers[e]
                    }
                    l = true;
                    break
                }
                f++
            }
        }
        if (l) {
            if (g.removeEventListener) {
                g.removeEventListener(a, h, c)
            } else {
                if (g && g.detachEvent) {
                    g.detachEvent("on" + a, h)
                }
            }
        }
        return l
    },
    unloadCache: function() {
        if (SuperMap.Event && SuperMap.Event.observers) {
            for (var a in SuperMap.Event.observers) {
                var c = SuperMap.Event.observers[a];
                SuperMap.Event._removeElementObservers.apply(this, [c])
            }
            SuperMap.Event.observers = false
        }
    },
    CLASS_NAME: "SuperMap.Event"
};
SuperMap.Event.observe(window, "unload", SuperMap.Event.unloadCache, false);
SuperMap.Events = SuperMap.Class({
    BROWSER_EVENTS: ["mouseover", "mouseout", "mousedown", "mouseup", "mousemove", "click", "dblclick", "rightclick", "dblrightclick", "resize", "focus", "blur", "touchstart", "touchmove", "touchend", "keydown", "MSPointerDown", "MSPointerUp", "MSGestureStart", "MSGestureChange", "MSGestureEnd"],
    listeners: null,
    object: null,
    element: null,
    eventTypes: null,
    eventHandler: null,
    fallThrough: null,
    includeXY: false,
    extensions: null,
    extensionCount: null,
    clearMouseListener: null,
    initialize: function(d, f, h, g, c) {
        SuperMap.Util.extend(this, c);
        this.object = d;
        this.fallThrough = g;
        this.listeners = {};
        this.extensions = {};
        this.extensionCount = {};
        this.eventTypes = [];
        if (h != null) {
            for (var e = 0, a = h.length; e < a; e++) {
                this.addEventType(h[e])
            }
        }
        if (f != null) {
            this.attachToElement(f)
        }
    },
    destroy: function() {
        for (var a in this.extensions) {
            if (typeof this.extensions[a] !== "boolean") {
                this.extensions[a].destroy()
            }
        }
        this.extensions = null;
        if (this.element) {
            SuperMap.Event.stopObservingElement(this.element);
            if (this.element.hasScrollEvent) {
                SuperMap.Event.stopObserving(window, "scroll", this.clearMouseListener)
            }
        }
        this.element = null;
        this.listeners = null;
        this.object = null;
        this.eventTypes = null;
        this.fallThrough = null;
        this.eventHandler = null
    },
    addEventType: function(a) {
        if (!this.listeners[a]) {
            this.eventTypes.push(a);
            this.listeners[a] = []
        }
    },
    attachToElement: function(e) {
        if (this.element) {
            SuperMap.Event.stopObservingElement(this.element)
        } else {
            this.eventHandler = SuperMap.Function.bindAsEventListener(this.handleBrowserEvent, this);
            this.clearMouseListener = SuperMap.Function.bind(this.clearMouseCache, this)
        }
        this.element = e;
        for (var d = 0, a = this.BROWSER_EVENTS.length; d < a; d++) {
            var c = this.BROWSER_EVENTS[d];
            this.addEventType(c);
            SuperMap.Event.observe(e, c, this.eventHandler)
        }
        SuperMap.Event.observe(e, "dragstart", SuperMap.Event.stop)
    },
    on: function(a) {
        for (var c in a) {
            if (c != "scope" && a.hasOwnProperty(c)) {
                this.register(c, a.scope, a[c])
            }
        }
    },
    register: function(d, g, e, a) {
        if (d in SuperMap.Events && !this.extensions[d]) {
            this.extensions[d] = new SuperMap.Events[d](this)
        }
        if ((e != null) && (SuperMap.Util.indexOf(this.eventTypes, d) != -1)) {
            if (g == null) {
                g = this.object
            }
            var c = this.listeners[d];
            if (!c) {
                c = [];
                this.listeners[d] = c;
                this.extensionCount[d] = 0
            }
            var f = {
                obj: g,
                func: e
            };
            if (a) {
                c.splice(this.extensionCount[d], 0, f);
                if (typeof a === "object" && a.extension) {
                    this.extensionCount[d]++
                }
            } else {
                c.push(f)
            }
        }
    },
    registerPriority: function(a, d, c) {
        this.register(a, d, c, true)
    },
    un: function(a) {
        for (var c in a) {
            if (c != "scope" && a.hasOwnProperty(c)) {
                this.unregister(c, a.scope, a[c])
            }
        }
    },
    unregister: function(e, g, f) {
        if (g == null) {
            g = this.object
        }
        var d = this.listeners[e];
        if (d != null) {
            for (var c = 0, a = d.length; c < a; c++) {
                if (d[c].obj == g && d[c].func == f) {
                    d.splice(c, 1);
                    break
                }
            }
        }
    },
    remove: function(a) {
        if (this.listeners[a] != null) {
            this.listeners[a] = []
        }
    },
    triggerEvent: function(f, c) {
        var e = this.listeners[f];
        if (!e || e.length == 0) {
            return undefined
        }
        if (c == null) {
            c = {}
        }
        c.object = this.object;
        c.element = this.element;
        if (!c.type) {
            c.type = f
        }
        e = e.slice();
        var g;
        for (var d = 0, a = e.length; d < a; d++) {
            var h = e[d];
            g = h.func.apply(h.obj, [c]);
            if ((g != undefined) && (g == false)) {
                break
            }
        }
        if (!this.fallThrough) {
            SuperMap.Event.stop(c, true)
        }
        return g
    },
    handleBrowserEvent: function(k) {
        var f = k.type
          , g = this.listeners[f];
        if (!g || g.length == 0) {
            return
        }
        var d = k.touches;
        if (d && d[0]) {
            var j = 0;
            var h = 0;
            var e = d.length;
            var c;
            for (var a = 0; a < e; ++a) {
                c = d[a];
                j += c.clientX;
                h += c.clientY
            }
            k.clientX = j / e;
            k.clientY = h / e
        }
        if (this.includeXY) {
            k.xy = this.getMousePosition(k)
        }
        this.triggerEvent(f, k)
    },
    clearMouseCache: function() {
        this.element.scrolls = null;
        this.element.lefttop = null;
        var a = document.body;
        if (a && !((a.scrollTop != 0 || a.scrollLeft != 0) && navigator.userAgent.match(/iPhone/i))) {
            this.element.offsets = null
        }
    },
    getMousePosition: function(a) {
        if (!this.includeXY) {
            this.clearMouseCache()
        } else {
            if (!this.element.hasScrollEvent) {
                SuperMap.Event.observe(window, "scroll", this.clearMouseListener);
                this.element.hasScrollEvent = true
            }
        }
        if (!this.element.scrolls) {
            var c = SuperMap.Util.getViewportElement();
            this.element.scrolls = [c.scrollLeft, c.scrollTop]
        }
        if (!this.element.lefttop) {
            this.element.lefttop = [(document.documentElement.clientLeft || 0), (document.documentElement.clientTop || 0)]
        }
        if (!this.element.offsets) {
            this.element.offsets = SuperMap.Util.pagePosition(this.element)
        }
        return new SuperMap.Pixel((a.clientX + this.element.scrolls[0]) - this.element.offsets[0] - this.element.lefttop[0],(a.clientY + this.element.scrolls[1]) - this.element.offsets[1] - this.element.lefttop[1])
    },
    CLASS_NAME: "SuperMap.Events"
});
SuperMap.Request = {
    DEFAULT_CONFIG: {
        method: "GET",
        url: window.location.href,
        async: true,
        user: undefined,
        password: undefined,
        params: null,
        proxy: SuperMap.ProxyHost,
        headers: {},
        data: null,
        callback: function() {},
        success: null,
        failure: null,
        scope: null
    },
    URL_SPLIT_REGEX: /([^:]*:)\/\/([^:]*:?[^@]*@)?([^:\/\?]*):?([^\/\?]*)/,
    events: new SuperMap.Events(this,null,["complete", "success", "failure"]),
    issue: function(e) {
        var h = SuperMap.Util.extend(this.DEFAULT_CONFIG, {
            proxy: SuperMap.ProxyHost
        });
        e = SuperMap.Util.applyDefaults(e, h);
        var g = new SuperMap.Request.XMLHttpRequest();
        var a = SuperMap.Util.urlAppend(e.url, SuperMap.Util.getParameterString(e.params || {}));
        var j = !(a.indexOf("http") == 0);
        var c = !j && a.match(this.URL_SPLIT_REGEX);
        if (c) {
            var k = window.location;
            j = c[1] == k.protocol && c[3] == k.hostname;
            var f = c[4]
              , d = k.port;
            if (f != 80 && f != "" || d != "80" && d != "") {
                j = j && f == d
            }
        }
        if (!j) {
            if (e.proxy) {
                if (typeof e.proxy == "function") {
                    a = e.proxy(a)
                } else {
                    a = e.proxy + encodeURIComponent(a)
                }
            }
        }
        g.open(e.method, a, e.async, e.user, e.password);
        for (var i in e.headers) {
            g.setRequestHeader(i, e.headers[i])
        }
        var m = this.events;
        var l = this;
        g.onreadystatechange = function() {
            if (g.readyState == SuperMap.Request.XMLHttpRequest.DONE) {
                var n = m.triggerEvent("complete", {
                    request: g,
                    config: e,
                    requestUrl: a
                });
                if (n !== false) {
                    l.runCallbacks({
                        request: g,
                        config: e,
                        requestUrl: a
                    })
                }
            }
        }
        ;
        if (e.async === false) {
            g.send(e.data)
        } else {
            window.setTimeout(function() {
                if (g.readyState !== 0) {
                    g.send(e.data)
                }
            }, 0)
        }
        return g
    },
    runCallbacks: function(e) {
        var f = e.request;
        var d = e.config;
        var a = (d.scope) ? SuperMap.Function.bind(d.callback, d.scope) : d.callback;
        var g;
        if (d.success) {
            g = (d.scope) ? SuperMap.Function.bind(d.success, d.scope) : d.success
        }
        var c;
        if (d.failure) {
            c = (d.scope) ? SuperMap.Function.bind(d.failure, d.scope) : d.failure
        }
        if (SuperMap.Util.createUrlObject(d.url).protocol == "file:" && f.responseText) {
            f.status = 200
        }
        a(f);
        if (!f.status || (f.status >= 200 && f.status < 300)) {
            this.events.triggerEvent("success", e);
            if (g) {
                g(f)
            }
        }
        if (f.status && (f.status < 200 || f.status >= 300)) {
            this.events.triggerEvent("failure", e);
            if (c) {
                c(f)
            }
        }
    },
    GET: function(a) {
        a = SuperMap.Util.extend(a, {
            method: "GET"
        });
        return SuperMap.Request.issue(a)
    },
    POST: function(a) {
        a = SuperMap.Util.extend(a, {
            method: "POST"
        });
        a.headers = a.headers ? a.headers : {};
        if (!("CONTENT-TYPE"in SuperMap.Util.upperCaseObject(a.headers))) {
            a.headers["Content-Type"] = "application/xml"
        }
        return SuperMap.Request.issue(a)
    },
    PUT: function(a) {
        a = SuperMap.Util.extend(a, {
            method: "PUT"
        });
        a.headers = a.headers ? a.headers : {};
        if (!("CONTENT-TYPE"in SuperMap.Util.upperCaseObject(a.headers))) {
            a.headers["Content-Type"] = "application/xml"
        }
        return SuperMap.Request.issue(a)
    },
    DELETE: function(a) {
        a = SuperMap.Util.extend(a, {
            method: "DELETE"
        });
        return SuperMap.Request.issue(a)
    },
    HEAD: function(a) {
        a = SuperMap.Util.extend(a, {
            method: "HEAD"
        });
        return SuperMap.Request.issue(a)
    },
    OPTIONS: function(a) {
        a = SuperMap.Util.extend(a, {
            method: "OPTIONS"
        });
        return SuperMap.Request.issue(a)
    }
};
(function() {
    var h = window.XMLHttpRequest;
    var a = !!window.controllers;
    var k = !!window.document.namespaces;
    var l = k && window.navigator.userAgent.match(/MSIE 7.0/);
    function e() {
        this._object = h && !l ? new h : new window.ActiveXObject("Microsoft.XMLHTTP");
        this._listeners = []
    }
    function d() {
        return new e
    }
    d.prototype = e.prototype;
    if (a && h.wrapped) {
        d.wrapped = h.wrapped
    }
    d.UNSENT = 0;
    d.OPENED = 1;
    d.HEADERS_RECEIVED = 2;
    d.LOADING = 3;
    d.DONE = 4;
    d.prototype.UNSENT = d.UNSENT;
    d.prototype.OPENED = d.OPENED;
    d.prototype.HEADERS_RECEIVED = d.HEADERS_RECEIVED;
    d.prototype.LOADING = d.LOADING;
    d.prototype.DONE = d.DONE;
    d.prototype.readyState = d.UNSENT;
    d.prototype.responseText = "";
    d.prototype.responseXML = null;
    d.prototype.status = 0;
    d.prototype.statusText = "";
    d.prototype.priority = "NORMAL";
    d.prototype.onreadystatechange = null;
    d.onreadystatechange = null;
    d.onopen = null;
    d.onsend = null;
    d.onabort = null;
    d.prototype.open = function(r, n, p, t, q) {
        var m = r.toLowerCase();
        if (m == "connect" || m == "trace" || m == "track") {
            throw new Error(18)
        }
        delete this._headers;
        if (arguments.length < 3) {
            p = true
        }
        this._async = p;
        var o = this;
        var s = this.readyState;
        var u = null;
        if (k && p) {
            u = function() {
                if (s != d.DONE) {
                    f(o);
                    o.abort()
                }
            }
            ;
            window.attachEvent("onunload", u)
        }
        if (d.onopen) {
            d.onopen.apply(this, arguments)
        }
        if (arguments.length > 4) {
            this._object.open(r, n, p, t, q)
        } else {
            if (arguments.length > 3) {
                this._object.open(r, n, p, t)
            } else {
                this._object.open(r, n, p)
            }
        }
        this.readyState = d.OPENED;
        c(this);
        this._object.onreadystatechange = function() {
            if (a && !p) {
                return
            }
            o.readyState = o._object.readyState;
            i(o);
            if (o._aborted) {
                o.readyState = d.UNSENT;
                return
            }
            if (o.readyState == d.DONE) {
                delete o._data;
                f(o);
                if (k && p) {
                    window.detachEvent("onunload", u)
                }
                if (s != o.readyState) {
                    c(o)
                }
                s = o.readyState
            }
        }
    }
    ;
    d.prototype.send = function(m) {
        if (d.onsend) {
            d.onsend.apply(this, arguments)
        }
        if (!arguments.length) {
            m = null
        }
        if (m && m.nodeType) {
            m = window.XMLSerializer ? new window.XMLSerializer().serializeToString(m) : m.xml;
            if (!this._headers["Content-Type"]) {
                this._object.setRequestHeader("Content-Type", "application/xml")
            }
        }
        this._data = m;
        g(this)
    }
    ;
    d.prototype.abort = function() {
        if (d.onabort) {
            d.onabort.apply(this, arguments)
        }
        if (this.readyState > d.UNSENT) {
            this._aborted = true
        }
        this._object.abort();
        f(this);
        this.readyState = d.UNSENT;
        delete this._data
    }
    ;
    d.prototype.getAllResponseHeaders = function() {
        return this._object.getAllResponseHeaders()
    }
    ;
    d.prototype.getResponseHeader = function(m) {
        return this._object.getResponseHeader(m)
    }
    ;
    d.prototype.setRequestHeader = function(m, n) {
        if (!this._headers) {
            this._headers = {}
        }
        this._headers[m] = n;
        return this._object.setRequestHeader(m, n)
    }
    ;
    d.prototype.addEventListener = function(p, o, n) {
        for (var m = 0, q; q = this._listeners[m]; m++) {
            if (q[0] == p && q[1] == o && q[2] == n) {
                return
            }
        }
        this._listeners.push([p, o, n])
    }
    ;
    d.prototype.removeEventListener = function(p, o, n) {
        for (var m = 0, q; q = this._listeners[m]; m++) {
            if (q[0] == p && q[1] == o && q[2] == n) {
                break
            }
        }
        if (q) {
            this._listeners.splice(m, 1)
        }
    }
    ;
    d.prototype.dispatchEvent = function(n) {
        var o = {
            type: n.type,
            target: this,
            currentTarget: this,
            eventPhase: 2,
            bubbles: n.bubbles,
            cancelable: n.cancelable,
            timeStamp: n.timeStamp,
            stopPropagation: function() {},
            preventDefault: function() {},
            initEvent: function() {}
        };
        if (o.type == "readystatechange" && this.onreadystatechange) {
            (this.onreadystatechange.handleEvent || this.onreadystatechange).apply(this, [o])
        }
        for (var m = 0, p; p = this._listeners[m]; m++) {
            if (p[0] == o.type && !p[2]) {
                (p[1].handleEvent || p[1]).apply(this, [o])
            }
        }
    }
    ;
    d.prototype.toString = function() {
        return "[object XMLHttpRequest]"
    }
    ;
    d.toString = function() {
        return "[XMLHttpRequest]"
    }
    ;
    function g(m) {
        m._object.send(m._data);
        if (a && !m._async) {
            m.readyState = d.OPENED;
            i(m);
            while (m.readyState < d.DONE) {
                m.readyState++;
                c(m);
                if (m._aborted) {
                    return
                }
            }
        }
    }
    function c(m) {
        if (d.onreadystatechange) {
            d.onreadystatechange.apply(m)
        }
        m.dispatchEvent({
            type: "readystatechange",
            bubbles: false,
            cancelable: false,
            timeStamp: new Date + 0
        })
    }
    function j(o) {
        var n = o.responseXML;
        var m = o.responseText;
        if (k && m && n && !n.documentElement && o.getResponseHeader("Content-Type").match(/[^\/]+\/[^\+]+\+xml/)) {
            n = new window.ActiveXObject("Microsoft.XMLDOM");
            n.async = false;
            n.validateOnParse = false;
            n.loadXML(m)
        }
        if (n) {
            if ((k && n.parseError !== 0) || !n.documentElement || (n.documentElement && n.documentElement.tagName == "parsererror")) {
                return null
            }
        }
        return n
    }
    function i(m) {
        try {
            m.responseText = m._object.responseText
        } catch (n) {}
        try {
            m.responseXML = j(m._object)
        } catch (n) {}
        try {
            m.status = m._object.status
        } catch (n) {}
        try {
            m.statusText = m._object.statusText
        } catch (n) {}
    }
    function f(m) {
        m._object.onreadystatechange = new window.Function
    }
    if (!window.Function.prototype.apply) {
        window.Function.prototype.apply = function(m, n) {
            if (!n) {
                n = []
            }
            m.__func = this;
            m.__func(n[0], n[1], n[2], n[3], n[4]);
            delete m.__func
        }
    }
    SuperMap.Request.XMLHttpRequest = d
})();
SuperMap.Projection = SuperMap.Class({
    proj: null,
    projCode: null,
    titleRegEx: /\+title=[^\+]*/,
    initialize: function(c, a) {
        SuperMap.Util.extend(this, a);
        this.projCode = c;
        if (window.Proj4js) {
            this.proj = new Proj4js.Proj(c)
        }
    },
    getCode: function() {
        return this.proj ? this.proj.srsCode : this.projCode
    },
    getUnits: function() {
        return this.proj ? this.proj.units : null
    },
    toString: function() {
        return this.getCode()
    },
    equals: function(a) {
        var f = a
          , c = false;
        if (f) {
            if (!(f instanceof SuperMap.Projection)) {
                f = new SuperMap.Projection(f)
            }
            if (window.Proj4js && this.proj.defData && f.proj.defData) {
                c = this.proj.defData.replace(this.titleRegEx, "") == f.proj.defData.replace(this.titleRegEx, "")
            } else {
                if (f.getCode) {
                    var d = this.getCode()
                      , e = f.getCode();
                    c = d == e || !!SuperMap.Projection.transforms[d] && SuperMap.Projection.transforms[d][e] === SuperMap.Projection.nullTransform
                }
            }
        }
        return c
    },
    destroy: function() {
        delete this.proj;
        delete this.projCode
    },
    CLASS_NAME: "SuperMap.Projection"
});
SuperMap.Projection.transforms = {};
SuperMap.Projection.defaults = {
    "EPSG:4326": {
        units: "degrees",
        maxExtent: [-180, -90, 180, 90],
        yx: true
    },
    "CRS:84": {
        units: "degrees",
        maxExtent: [-180, -90, 180, 90]
    },
    "EPSG:900913": {
        units: "m",
        maxExtent: [-20037508.34, -20037508.34, 20037508.34, 20037508.34]
    },
    "EPSG:3857": {
        units: "m",
        maxExtent: [-20037508.34, -20037508.34, 20037508.34, 20037508.34]
    }
};
SuperMap.Projection.addTransform = function(e, d, c) {
    if (c === SuperMap.Projection.nullTransform) {
        var a = SuperMap.Projection.defaults[e];
        if (a && !SuperMap.Projection.defaults[d]) {
            SuperMap.Projection.defaults[d] = a
        }
    }
    if (!SuperMap.Projection.transforms[e]) {
        SuperMap.Projection.transforms[e] = {}
    }
    SuperMap.Projection.transforms[e][d] = c
}
;
SuperMap.Projection.transform = function(a, f, c) {
    if (f && c) {
        if (!(f instanceof SuperMap.Projection)) {
            f = new SuperMap.Projection(f)
        }
        if (!(c instanceof SuperMap.Projection)) {
            c = new SuperMap.Projection(c)
        }
        if (f.proj && c.proj) {
            a = Proj4js.transform(f.proj, c.proj, a)
        } else {
            var e = f.getCode();
            var g = c.getCode();
            var d = SuperMap.Projection.transforms;
            if (d[e] && d[e][g]) {
                d[e][g](a)
            }
        }
    }
    return a
}
;
SuperMap.Projection.nullTransform = function(a) {
    return a
}
;
(function() {
    var f = 20037508.34;
    function h(i) {
        i.x = 180 * i.x / f;
        i.y = 180 / Math.PI * (2 * Math.atan(Math.exp((i.y / f) * Math.PI)) - Math.PI / 2);
        return i
    }
    function c(i) {
        i.x = i.x * f / 180;
        i.y = Math.log(Math.tan((90 + i.y) * Math.PI / 360)) / Math.PI * f;
        return i
    }
    function g(l, k) {
        var s = SuperMap.Projection.addTransform;
        var r = SuperMap.Projection.nullTransform;
        var o, p, m, q, n;
        for (o = 0,
        p = k.length; o < p; ++o) {
            m = k[o];
            s(l, m, c);
            s(m, l, h);
            for (n = o + 1; n < p; ++n) {
                q = k[n];
                s(m, q, r);
                s(q, m, r)
            }
        }
    }
    var a = ["EPSG:900913", "EPSG:3857", "EPSG:102113", "EPSG:102100"], e = ["CRS:84", "urn:ogc:def:crs:EPSG:6.6:4326", "EPSG:4326"], d;
    for (d = a.length - 1; d >= 0; --d) {
        g(a[d], e)
    }
    for (d = e.length - 1; d >= 0; --d) {
        g(e[d], a)
    }
})();
SuperMap.Map = SuperMap.Class({
    Z_INDEX_BASE: {
        BaseLayer: 100,
        Overlay: 325,
        Feature: 525,
        Popup: 750,
        Control: 1000
    },
    EVENT_TYPES: ["preaddlayer", "addlayer", "preremovelayer", "removelayer", "changelayer", "movestart", "move", "moveend", "zoomend", "popupopen", "popupclose", "addmarker", "removemarker", "clearmarkers", "mouseover", "mouseout", "mousemove", "dragstart", "drag", "dragend", "changebaselayer"],
    id: null,
    isIESingleTouch: true,
    isIEMultipeTouch: false,
    fractionalZoom: false,
    events: null,
    allOverlays: false,
    div: null,
    dragging: false,
    size: null,
    viewPortDiv: null,
    layerContainerOrigin: null,
    layerContainerDiv: null,
    layerContainerDivCanvas: null,
    layers: null,
    controls: null,
    popups: null,
    baseLayer: null,
    center: null,
    resolution: null,
    zoom: 0,
    panRatio: 1.5,
    viewRequestID: 0,
    tileSize: null,
    projection: "EPSG:4326",
    units: "degrees",
    resolutions: null,
    maxResolution: null,
    minResolution: null,
    maxScale: null,
    minScale: null,
    maxExtent: null,
    minExtent: null,
    restrictedExtent: null,
    numZoomLevels: 16,
    theme: null,
    displayProjection: null,
    fallThrough: true,
    panTween: null,
    eventListeners: null,
    panMethod: SuperMap.Easing.Expo.easeOut,
    panDuration: 50,
    paddingForPopups: null,
    minPx: null,
    maxPx: null,
    initialize: function(c, l) {
        if (arguments.length === 1 && typeof c === "object") {
            l = c;
            c = l && l.div
        }
        this.tileSize = new SuperMap.Size(SuperMap.Map.TILE_WIDTH,SuperMap.Map.TILE_HEIGHT);
        this.paddingForPopups = new SuperMap.Bounds(15,15,15,15);
        this.theme = SuperMap._getScriptLocation() + "../theme/default/style.css";
        SuperMap.Util.extend(this, l);
        var a = this.projection instanceof SuperMap.Projection ? this.projection.projCode : this.projection;
        SuperMap.Util.applyDefaults(this, SuperMap.Projection.defaults[a]);
        if (this.maxExtent && !(this.maxExtent instanceof SuperMap.Bounds)) {
            this.maxExtent = new SuperMap.Bounds(this.maxExtent)
        }
        if (this.minExtent && !(this.minExtent instanceof SuperMap.Bounds)) {
            this.minExtent = new SuperMap.Bounds(this.minExtent)
        }
        if (this.restrictedExtent && !(this.restrictedExtent instanceof SuperMap.Bounds)) {
            this.restrictedExtent = new SuperMap.Bounds(this.restrictedExtent)
        }
        if (this.center && !(this.center instanceof SuperMap.LonLat)) {
            this.center = new SuperMap.LonLat(this.center)
        }
        this.layers = [];
        this.id = SuperMap.Util.createUniqueID("SuperMap.Map_");
        this.div = SuperMap.Util.getElement(c);
        if (!this.div) {
            this.div = document.createElement("div");
            this.div.style.height = "1px";
            this.div.style.width = "1px"
        }
        SuperMap.Element.addClass(this.div, "smMap");
        var e = this.id + "_SuperMap_ViewPort";
        this.viewPortDiv = SuperMap.Util.createDiv(e, null, null, null, "relative", null, "hidden");
        this.viewPortDiv.style.width = "100%";
        this.viewPortDiv.style.height = "100%";
        this.viewPortDiv.className = "smMapViewport";
        this.div.appendChild(this.viewPortDiv);
        var g = document.createElement("div");
        g.id = this.id + "_events";
        g.style.position = "absolute";
        g.style.width = "100%";
        g.style.height = "100%";
        g.style.zIndex = this.Z_INDEX_BASE.Control - 1;
        this.viewPortDiv.appendChild(g);
        this.eventsDiv = g;
        this.events = new SuperMap.Events(this,this.eventsDiv,this.EVENT_TYPES,this.fallThrough,{
            includeXY: true
        });
        e = this.id + "_SuperMap_Container";
        this.layerContainerDiv = SuperMap.Util.createDiv(e);
        this.layerContainerDiv.style.zIndex = this.Z_INDEX_BASE.Popup - 1;
        this.shadowContainerDiv = SuperMap.Util.createDiv("layerContainerShadowDiv");
        this.shadowContainerDiv.style.zIndex = this.Z_INDEX_BASE.Feature - 1;
        this.layerContainerDiv.appendChild(this.shadowContainerDiv);
        this.layerContainerDivCanvas = SuperMap.Util.createDiv(e);
        this.layerContainerDivCanvas.style.zIndex = this.Z_INDEX_BASE.Popup - 1;
        this.eventsDiv.appendChild(this.layerContainerDivCanvas);
        this.eventsDiv.appendChild(this.layerContainerDiv);
        this.updateSize();
        if (this.eventListeners instanceof Object) {
            this.events.on(this.eventListeners)
        }
        this.events.register("movestart", this, this.updateSize);
        this.updateSizeDestroy = SuperMap.Function.bind(this.updateSize, this);
        SuperMap.Event.observe(window, "resize", this.updateSizeDestroy);
        if (this.theme) {
            var f = true;
            var d = document.getElementsByTagName("link");
            for (var h = 0, j = d.length; h < j; ++h) {
                if (SuperMap.Util.isEquivalentUrl(d.item(h).href, this.theme)) {
                    f = false;
                    break
                }
            }
            if (f) {
                var k = document.createElement("link");
                k.setAttribute("rel", "stylesheet");
                k.setAttribute("type", "text/css");
                k.setAttribute("href", this.theme);
                document.getElementsByTagName("head")[0].appendChild(k)
            }
        }
        if (this.controls == null) {
            if (SuperMap.Control != null) {
                this.controls = [new SuperMap.Control.Navigation(), new SuperMap.Control.PanZoomBar(), new SuperMap.Control.Attribution()]
            } else {
                this.controls = []
            }
        }
        for (var h = 0, j = this.controls.length; h < j; h++) {
            this.addControlToMap(this.controls[h])
        }
        this.popups = [];
        this.unloadDestroy = SuperMap.Function.bind(this.destroy, this);
        SuperMap.Event.observe(window, "unload", this.unloadDestroy);
        if (l && l.layers) {
            delete this.center;
            this.addLayers(l.layers);
            if (l.center && !this.getCenter()) {
                this.setCenter(l.center, l.zoom)
            }
        }
    },
    render: function(a) {
        this.div = SuperMap.Util.getElement(a);
        SuperMap.Element.addClass(this.div, "smMap");
        this.viewPortDiv.parentNode.removeChild(this.viewPortDiv);
        this.div.appendChild(this.viewPortDiv);
        this.updateSize()
    },
    unloadDestroy: null,
    updateSizeDestroy: null,
    destroy: function() {
        if (!this.unloadDestroy) {
            return false
        }
        if (this.panTween) {
            this.panTween.stop();
            this.panTween = null
        }
        SuperMap.Event.stopObserving(window, "unload", this.unloadDestroy);
        this.unloadDestroy = null;
        if (this.updateSizeDestroy) {
            SuperMap.Event.stopObserving(window, "resize", this.updateSizeDestroy)
        } else {
            this.events.unregister("resize", this, this.updateSize)
        }
        this.paddingForPopups = null;
        if (this.controls != null) {
            for (var a = this.controls.length - 1; a >= 0; --a) {
                this.controls[a].destroy()
            }
            this.controls = null
        }
        if (this.layers != null) {
            for (var a = this.layers.length - 1; a >= 0; --a) {
                this.layers[a].destroy(false)
            }
            this.layers = null
        }
        if (this.viewPortDiv) {
            this.div.removeChild(this.viewPortDiv)
        }
        this.viewPortDiv = null;
        if (this.eventListeners) {
            this.events.un(this.eventListeners);
            this.eventListeners = null
        }
        this.events.destroy();
        this.events = null
    },
    setOptions: function(a) {
        var c = this.minPx && a.restrictedExtent != this.restrictedExtent;
        SuperMap.Util.extend(this, a);
        c && this.moveTo(this.getCachedCenter(), this.zoom, {
            forceZoomChange: true
        })
    },
    getTileSize: function() {
        return this.tileSize
    },
    getBy: function(f, d, a) {
        var e = (typeof a.test == "function");
        var c = SuperMap.Array.filter(this[f], function(g) {
            return g[d] == a || (e && a.test(g[d]))
        });
        return c
    },
    getLayersBy: function(c, a) {
        return this.getBy("layers", c, a)
    },
    getLayersByName: function(a) {
        return this.getLayersBy("name", a)
    },
    getLayersByClass: function(a) {
        return this.getLayersBy("CLASS_NAME", a)
    },
    getControlsBy: function(c, a) {
        return this.getBy("controls", c, a)
    },
    getControlsByClass: function(a) {
        return this.getControlsBy("CLASS_NAME", a)
    },
    getLayer: function(f) {
        var c = null;
        for (var e = 0, a = this.layers.length; e < a; e++) {
            var d = this.layers[e];
            if (d.id == f) {
                c = d;
                break
            }
        }
        return c
    },
    setLayerZIndex: function(c, a) {
        if ((c instanceof SuperMap.Layer.Vector) || (c instanceof SuperMap.Layer.Markers)) {
            c.setZIndex(this.Z_INDEX_BASE.Feature + a * 5)
        } else {
            c.setZIndex(this.Z_INDEX_BASE[c.isBaseLayer ? "BaseLayer" : "Overlay"] + a * 5)
        }
    },
    resetLayersZIndex: function() {
        for (var d = 0, a = this.layers.length; d < a; d++) {
            var c = this.layers[d];
            this.setLayerZIndex(c, d)
        }
    },
    addLayer: function(d) {
        for (var c = 0, a = this.layers.length; c < a; c++) {
            if (this.layers[c] == d) {
                var e = SuperMap.i18n("layerAlreadyAdded", {
                    layerName: d.name
                });
                return false
            }
        }
        if (this.events.triggerEvent("preaddlayer", {
            layer: d
        }) === false) {
            return false
        }
        if (this.allOverlays) {
            d.isBaseLayer = false
        }
        d.div.className = "smLayerDiv";
        d.div.style.overflow = "";
        this.setLayerZIndex(d, this.layers.length);
        if (d.isFixed) {
            this.viewPortDiv.appendChild(d.div)
        } else {
            if (d.canvas) {
                this.layerContainerDivCanvas.appendChild(d.div)
            } else {
                this.layerContainerDiv.appendChild(d.div)
            }
        }
        this.layers.push(d);
        d.setMap(this);
        if (d.isBaseLayer || (this.allOverlays && !this.baseLayer)) {
            if (this.baseLayer == null) {
                this.setBaseLayer(d)
            } else {
                d.setVisibility(false)
            }
        } else {
            d.redraw()
        }
        this.events.triggerEvent("addlayer", {
            layer: d
        });
        d.events.triggerEvent("added", {
            map: this,
            layer: d
        });
        d.afterAdd();
        return true
    },
    addLayers: function(d) {
        for (var c = 0, a = d.length; c < a; c++) {
            this.addLayer(d[c])
        }
    },
    removeLayer: function(d, f) {
        if (this.events.triggerEvent("preremovelayer", {
            layer: d
        }) === false) {
            return
        }
        if (f == null) {
            f = true
        }
        if (d.isFixed) {
            this.viewPortDiv.removeChild(d.div)
        } else {
            if (d.canvas) {
                this.layerContainerDivCanvas.removeChild(d.div)
            } else {
                this.layerContainerDiv.removeChild(d.div)
            }
        }
        SuperMap.Util.removeItem(this.layers, d);
        d.removeMap(this);
        d.map = null;
        if (this.baseLayer == d) {
            this.baseLayer = null;
            if (f) {
                for (var c = 0, a = this.layers.length; c < a; c++) {
                    var e = this.layers[c];
                    if (e.isBaseLayer || this.allOverlays) {
                        this.setBaseLayer(e);
                        break
                    }
                }
            }
        }
        this.resetLayersZIndex();
        this.events.triggerEvent("removelayer", {
            layer: d
        });
        d.events.triggerEvent("removed", {
            map: this,
            layer: d
        })
    },
    getNumLayers: function() {
        return this.layers.length
    },
    getLayerIndex: function(a) {
        return SuperMap.Util.indexOf(this.layers, a)
    },
    setLayerIndex: function(e, c) {
        var f = this.getLayerIndex(e);
        if (c < 0) {
            c = 0
        } else {
            if (c > this.layers.length) {
                c = this.layers.length
            }
        }
        if (f != c) {
            this.layers.splice(f, 1);
            this.layers.splice(c, 0, e);
            for (var d = 0, a = this.layers.length; d < a; d++) {
                this.setLayerZIndex(this.layers[d], d)
            }
            this.events.triggerEvent("changelayer", {
                layer: e,
                property: "order"
            });
            if (this.allOverlays) {
                if (c === 0) {
                    this.setBaseLayer(e)
                } else {
                    if (this.baseLayer !== this.layers[0]) {
                        this.setBaseLayer(this.layers[0])
                    }
                }
            }
        }
    },
    raiseLayer: function(c, d) {
        var a = this.getLayerIndex(c) + d;
        this.setLayerIndex(c, a)
    },
    setBaseLayer: function(d) {
        if (d != this.baseLayer) {
            if (SuperMap.Util.indexOf(this.layers, d) != -1) {
                var a = this.getCachedCenter();
                var e = SuperMap.Util.getResolutionFromScale(this.getScale(), d.units);
                if (this.baseLayer != null && !this.allOverlays) {
                    this.baseLayer.setVisibility(false)
                }
                this.baseLayer = d;
                this.viewRequestID++;
                if (!this.allOverlays || this.baseLayer.visibility) {
                    this.baseLayer.setVisibility(true);
                    if (this.baseLayer.inRange === false) {
                        this.baseLayer.redraw()
                    }
                }
                if (a != null) {
                    var c = this.getZoomForResolution(e || this.resolution, true);
                    this.setCenter(a, c, false, true)
                }
                this.events.triggerEvent("changebaselayer", {
                    layer: this.baseLayer
                })
            }
        }
    },
    addControl: function(c, a) {
        this.controls.push(c);
        this.addControlToMap(c, a)
    },
    addControls: function(c, h) {
        var f = (arguments.length === 1) ? [] : h;
        for (var e = 0, a = c.length; e < a; e++) {
            var g = c[e];
            var d = (f[e]) ? f[e] : null;
            this.addControl(g, d)
        }
    },
    addControlToMap: function(c, a) {
        c.outsideViewport = (c.div != null);
        if (this.displayProjection && !c.displayProjection) {
            c.displayProjection = this.displayProjection
        }
        c.setMap(this);
        var d = c.draw(a);
        if (d) {
            if (!c.outsideViewport) {
                d.style.zIndex = this.Z_INDEX_BASE.Control + this.controls.length;
                this.viewPortDiv.appendChild(d)
            }
        }
        if (c.autoActivate) {
            c.activate()
        }
    },
    getControl: function(f) {
        var c = null;
        for (var d = 0, a = this.controls.length; d < a; d++) {
            var e = this.controls[d];
            if (e.id == f) {
                c = e;
                break
            }
        }
        return c
    },
    removeControl: function(a) {
        if ((a) && (a == this.getControl(a.id))) {
            if (a.div && (a.div.parentNode == this.viewPortDiv)) {
                this.viewPortDiv.removeChild(a.div)
            }
            SuperMap.Util.removeItem(this.controls, a)
        }
    },
    addPopup: function(a, e) {
        if (e) {
            for (var c = this.popups.length - 1; c >= 0; --c) {
                this.removePopup(this.popups[c])
            }
        }
        a.map = this;
        this.popups.push(a);
        var d = a.draw();
        if (d) {
            d.style.zIndex = this.Z_INDEX_BASE.Popup + this.popups.length;
            this.layerContainerDiv.appendChild(d)
        }
    },
    removePopup: function(a) {
        SuperMap.Util.removeItem(this.popups, a);
        if (a.div) {
            try {
                this.layerContainerDiv.removeChild(a.div)
            } catch (c) {}
        }
        if (a.shadowDiv) {
            try {
                this.shadowContainerDiv.removeChild(a.shadowDiv)
            } catch (c) {}
        }
        a.map = null
    },
    getSize: function() {
        var a = null;
        if (this.size != null) {
            a = this.size.clone()
        }
        return a
    },
    updateSize: function() {
        var d = this.getCurrentSize();
        if (d && !isNaN(d.h) && !isNaN(d.w)) {
            this.events.clearMouseCache();
            var g = this.getSize();
            if (g == null) {
                this.size = g = d
            }
            if (!d.equals(g)) {
                this.size = d;
                for (var e = 0, c = this.layers.length; e < c; e++) {
                    this.layers[e].onMapResize()
                }
                var a = this.getCachedCenter();
                if (this.baseLayer != null && a != null) {
                    var f = this.getZoom();
                    this.zoom = null;
                    this.setCenter(a, f)
                }
            }
        }
    },
    getCurrentSize: function() {
        var a = new SuperMap.Size(this.div.clientWidth,this.div.clientHeight);
        if (a.w == 0 && a.h == 0 || isNaN(a.w) && isNaN(a.h)) {
            a.w = this.div.offsetWidth;
            a.h = this.div.offsetHeight
        }
        if (a.w == 0 && a.h == 0 || isNaN(a.w) && isNaN(a.h)) {
            a.w = parseInt(this.div.style.width);
            a.h = parseInt(this.div.style.height)
        }
        return a
    },
    calculateBounds: function(a, c) {
        var d = null;
        if (a == null) {
            a = this.getCachedCenter()
        }
        if (c == null) {
            c = this.getResolution()
        }
        if ((a != null) && (c != null)) {
            var e = (this.size.w * c) / 2;
            var f = (this.size.h * c) / 2;
            d = new SuperMap.Bounds(a.lon - e,a.lat - f,a.lon + e,a.lat + f)
        }
        return d
    },
    getCenter: function() {
        var a = null;
        var c = this.getCachedCenter();
        if (c) {
            a = c.clone()
        }
        return a
    },
    getCachedCenter: function() {
        if (!this.center && this.size) {
            this.center = this.getLonLatFromViewPortPx({
                x: this.size.w / 2,
                y: this.size.h / 2
            })
        }
        return this.center
    },
    getZoom: function() {
        return this.zoom
    },
    zoomFinished: function() {
        if (this.layers === null) {
            return true
        }
        var e = true;
        for (var d = 0, f = this.layers, a = f.length; d < a; d++) {
            var c = f[d];
            if (c.isZoomming) {
                e = false;
                break
            }
        }
        return e
    },
    pan: function(e, d, f) {
        f = SuperMap.Util.applyDefaults(f, {
            animate: true,
            dragging: false
        });
        if (f.dragging) {
            if ((e != 0 || d != 0) && this.zoomFinished()) {
                this.moveByPx(e, d)
            }
        } else {
            var g = this.getViewPortPxFromLonLat(this.getCachedCenter());
            var c = g.add(e, d);
            if (this.dragging || !c.equals(g)) {
                var a = this.getLonLatFromViewPortPx(c);
                if (f.animate) {
                    this.panTo(a)
                } else {
                    this.moveTo(a);
                    if (this.dragging) {
                        this.dragging = false
                    }
                    this.events.triggerEvent("moveend")
                }
            }
        }
    },
    panTo: function(e) {
        if (this.panMethod && this.getExtent().scale(this.panRatio).containsLonLat(e)) {
            if (!this.panTween) {
                this.panTween = new SuperMap.Tween(this.panMethod)
            }
            var a = this.getCachedCenter();
            if (e.equals(a)) {
                return
            }
            var g = this.getPixelFromLonLat(a);
            var f = this.getPixelFromLonLat(e);
            var c = {
                x: f.x - g.x,
                y: f.y - g.y
            };
            var d = {
                x: 0,
                y: 0
            };
            this.panTween.start({
                x: 0,
                y: 0
            }, c, this.panDuration, {
                callbacks: {
                    eachStep: SuperMap.Function.bind(function(i) {
                        var h = i.x - d.x
                          , j = i.y - d.y;
                        this.moveByPx(h, j);
                        d.x = Math.round(i.x);
                        d.y = Math.round(i.y)
                    }, this),
                    done: SuperMap.Function.bind(function(h) {
                        this.moveTo(e);
                        this.dragging = false;
                        this.events.triggerEvent("moveend")
                    }, this)
                }
            })
        } else {
            this.setCenter(e)
        }
    },
    setCenter: function(d, a, c, e) {
        this.panTween && this.panTween.stop();
        this.moveTo(d, a, {
            dragging: c,
            forceZoomChange: e
        })
    },
    moveByPx: function(p, o) {
        var j = this.size.w / 2;
        var d = this.size.h / 2;
        var m = j + p;
        var l = d + o;
        var e = this.baseLayer.wrapDateLine;
        var n = 0;
        var k = 0;
        if (this.restrictedExtent) {
            n = j;
            k = d;
            e = false
        }
        p = e || m <= this.maxPx.x - n && m >= this.minPx.x + n ? Math.round(p) : 0;
        o = l <= this.maxPx.y - k && l >= this.minPx.y + k ? Math.round(o) : 0;
        var c = this.minPx.x
          , a = this.maxPx.x;
        if (p || o) {
            if (!this.dragging) {
                this.dragging = true;
                this.events.triggerEvent("movestart")
            }
            this.center = null;
            if (p) {
                this.layerContainerDiv.style.left = parseInt(this.layerContainerDiv.style.left) - p + "px";
                this.minPx.x -= p;
                this.maxPx.x -= p;
                if (e) {
                    if (this.maxPx.x > a) {
                        this.maxPx.x -= (a - c)
                    }
                    if (this.minPx.x < c) {
                        this.minPx.x += (a - c)
                    }
                }
            }
            if (o) {
                this.layerContainerDiv.style.top = parseInt(this.layerContainerDiv.style.top) - o + "px";
                this.minPx.y -= o;
                this.maxPx.y -= o
            }
            var g, f, h;
            for (f = 0,
            h = this.layers.length; f < h; ++f) {
                g = this.layers[f];
                if (g.visibility && (g === this.baseLayer || g.inRange)) {
                    g.moveByPx(p, o);
                    g.events.triggerEvent("move")
                }
            }
            this.events.triggerEvent("move")
        }
    },
    adjustZoom: function(g) {
        var d, a = this.baseLayer.resolutions, c = this.getMaxExtent().getWidth() / this.size.w;
        if (this.getResolutionForZoom(g) > c) {
            for (var e = g | 0, f = a.length; e < f; ++e) {
                if (a[e] <= c) {
                    g = e;
                    break
                }
            }
        }
        return g
    },
    moveTo: function(j, a, f) {
        if (a != this.getZoom()) {
            if (this.minResolution != null && this.maxResolution != null) {
                var v = this.baseLayer.getResolutionForZoom(a);
                var c = ((v >= this.minResolution) && (v <= this.maxResolution));
                if (!c) {
                    return
                }
            }
        }
        if (j != null && !(j instanceof SuperMap.LonLat)) {
            j = new SuperMap.LonLat(j)
        }
        if (!f) {
            f = {}
        }
        if (a != null) {
            a = parseFloat(a);
            if (!this.fractionalZoom) {
                a = Math.round(a)
            }
        }
        if (this.baseLayer.wrapDateLine) {
            var n = a;
            a = this.adjustZoom(a);
            if (a !== n) {
                j = this.getCenter()
            }
        }
        var q = f.dragging || this.dragging;
        var l = f.forceZoomChange;
        if (!this.getCachedCenter() && !this.isValidLonLat(j)) {
            j = this.maxExtent.getCenterLonLat();
            this.center = j.clone()
        }
        if (this.restrictedExtent != null) {
            if (j == null) {
                j = this.center
            }
            if (a == null) {
                a = this.getZoom()
            }
            var r = this.getResolutionForZoom(a);
            var o = this.calculateBounds(j, r);
            if (!this.restrictedExtent.containsBounds(o)) {
                var y = this.restrictedExtent.getCenterLonLat();
                if (o.getWidth() > this.restrictedExtent.getWidth()) {
                    j = new SuperMap.LonLat(y.lon,j.lat)
                } else {
                    if (o.left < this.restrictedExtent.left) {
                        j = j.add(this.restrictedExtent.left - o.left, 0)
                    } else {
                        if (o.right > this.restrictedExtent.right) {
                            j = j.add(this.restrictedExtent.right - o.right, 0)
                        }
                    }
                }
                if (o.getHeight() > this.restrictedExtent.getHeight()) {
                    j = new SuperMap.LonLat(j.lon,y.lat)
                } else {
                    if (o.bottom < this.restrictedExtent.bottom) {
                        j = j.add(0, this.restrictedExtent.bottom - o.bottom)
                    } else {
                        if (o.top > this.restrictedExtent.top) {
                            j = j.add(0, this.restrictedExtent.top - o.top)
                        }
                    }
                }
            }
        }
        var m = l || ((this.isValidZoomLevel(a)) && (a != this.getZoom()));
        var h = (this.isValidLonLat(j)) && (!j.equals(this.center));
        if (m || h || q) {
            q || this.events.triggerEvent("movestart");
            if (h) {
                if (!m && this.center) {
                    this.centerLayerContainer(j)
                }
                this.center = j.clone()
            }
            var z = m ? this.getResolutionForZoom(a) : this.getResolution();
            if (m || this.layerContainerOrigin == null) {
                this.layerContainerOrigin = this.getCachedCenter();
                this.layerContainerDiv.style.left = "0px";
                this.layerContainerDiv.style.top = "0px";
                var p = this.getMaxExtent({
                    restricted: true
                });
                var e = p.getCenterLonLat();
                var k = this.center.lon - e.lon;
                var d = e.lat - this.center.lat;
                var w = Math.round(p.getWidth() / z);
                var u = Math.round(p.getHeight() / z);
                this.minPx = {
                    x: (this.size.w - w) / 2 - k / z,
                    y: (this.size.h - u) / 2 - d / z
                };
                this.maxPx = {
                    x: this.minPx.x + Math.round(p.getWidth() / z),
                    y: this.minPx.y + Math.round(p.getHeight() / z)
                }
            }
            if (m) {
                this.zoom = a;
                this.resolution = z;
                this.viewRequestID++
            }
            var g = this.getExtent();
            if (this.baseLayer.visibility) {
                this.baseLayer.moveTo(g, m, f.dragging);
                f.dragging || this.baseLayer.events.triggerEvent("moveend", {
                    zoomChanged: m
                })
            }
            g = this.baseLayer.getExtent();
            for (var s = this.layers.length - 1; s >= 0; --s) {
                var x = this.layers[s];
                if (x !== this.baseLayer && !x.isBaseLayer) {
                    var c = x.calculateInRange();
                    if (x.inRange != c) {
                        x.inRange = c;
                        if (!c) {
                            x.display(false)
                        }
                        this.events.triggerEvent("changelayer", {
                            layer: x,
                            property: "visibility"
                        })
                    }
                    if (c && x.visibility) {
                        x.moveTo(g, m, f.dragging);
                        f.dragging || x.events.triggerEvent("moveend", {
                            zoomChanged: m
                        })
                    }
                }
            }
            this.events.triggerEvent("move");
            q || this.events.triggerEvent("moveend");
            if (m) {
                for (var s = 0, t = this.popups.length; s < t; s++) {
                    this.popups[s].updatePosition()
                }
                this.events.triggerEvent("zoomend")
            }
        }
    },
    centerLayerContainer: function(d) {
        var e = this.getViewPortPxFromLonLat(this.layerContainerOrigin);
        var h = this.getViewPortPxFromLonLat(d);
        if ((e != null) && (h != null)) {
            var a = parseInt(this.layerContainerDiv.style.left);
            var c = parseInt(this.layerContainerDiv.style.top);
            var g = Math.round(e.x - h.x);
            var f = Math.round(e.y - h.y);
            this.layerContainerDiv.style.left = g + "px";
            this.layerContainerDiv.style.top = f + "px";
            var j = a - g;
            var i = c - f;
            this.minPx.x -= j;
            this.maxPx.x -= j;
            this.minPx.y -= i;
            this.maxPx.y -= i
        }
    },
    isValidZoomLevel: function(a) {
        return ( (a != null) && (a >= 0) && (a < this.getNumZoomLevels()))
    },
    isValidLonLat: function(e) {
        var d = false;
        if (e != null) {
            var a = this.getMaxExtent();
            var c = this.baseLayer.wrapDateLine && a;
            d = a.containsLonLat(e, {
                worldBounds: c
            })
        }
        return d
    },
    getProjection: function() {
        var a = this.getProjectionObject();
        return a ? a.getCode() : null
    },
    getProjectionObject: function() {
        var a = null;
        if (this.baseLayer != null) {
            a = this.baseLayer.projection
        }
        return a
    },
    getMaxResolution: function() {
        var a = null;
        if (this.baseLayer != null) {
            a = this.baseLayer.maxResolution
        }
        return a
    },
    getMaxExtent: function(c) {
        var a = null;
        if (c && c.restricted && this.restrictedExtent) {
            a = this.restrictedExtent
        } else {
            if (this.baseLayer != null) {
                a = this.baseLayer.maxExtent
            }
        }
        return a
    },
    getNumZoomLevels: function() {
        var a = null;
        if (this.baseLayer != null) {
            a = this.baseLayer.numZoomLevels
        }
        return a
    },
    getExtent: function() {
        var a = null;
        if (this.baseLayer != null) {
            a = this.baseLayer.getExtent()
        }
        return a
    },
    getResolution: function() {
        var a = null;
        if (this.baseLayer != null) {
            a = this.baseLayer.getResolution()
        } else {
            if (this.allOverlays === true && this.layers.length > 0) {
                a = this.layers[0].getResolution()
            }
        }
        return a
    },
    getUnits: function() {
        var a = null;
        if (this.baseLayer != null) {
            a = this.baseLayer.units
        }
        return a
    },
    getScale: function() {
        var d = null;
        if (this.baseLayer != null) {
            var c = this.getResolution();
            var a = this.baseLayer.units;
            if (this.baseLayer.dpi) {
                d = SuperMap.Util.getScaleFromResolutionDpi(c, this.baseLayer.dpi, a, this.baseLayer.datumAxis)
            } else {
                d = SuperMap.Util.getScaleFromResolution(c, a)
            }
        }
        return d
    },
    getZoomForExtent: function(d, c) {
        var a = null;
        if (this.baseLayer != null) {
            a = this.baseLayer.getZoomForExtent(d, c)
        }
        return a
    },
    getResolutionForZoom: function(c) {
        var a = null;
        if (this.baseLayer) {
            a = this.baseLayer.getResolutionForZoom(c)
        }
        return a
    },
    getZoomForResolution: function(a, d) {
        var c = null;
        if (this.baseLayer != null) {
            c = this.baseLayer.getZoomForResolution(a, d)
        }
        return c
    },
    zoomTo: function(a) {
        if (this.isValidZoomLevel(a)) {
            this.setCenter(null, a)
        }
    },
    zoomIn: function() {
        this.zoomTo(this.getZoom() + 1)
    },
    zoomOut: function() {
        this.zoomTo(this.getZoom() - 1)
    },
    zoomToExtent: function(e, d) {
        if (!(e instanceof SuperMap.Bounds)) {
            e = new SuperMap.Bounds(e)
        }
        var c = e.getCenterLonLat();
        if (this.baseLayer.wrapDateLine) {
            var a = this.getMaxExtent();
            e = e.clone();
            while (e.right < e.left) {
                e.right += a.getWidth()
            }
            c = e.getCenterLonLat().wrapDateLine(a)
        }
        this.setCenter(c, this.getZoomForExtent(e, d))
    },
    zoomToMaxExtent: function(d) {
        var c = (d) ? d.restricted : true;
        var a = this.getMaxExtent({
            restricted: c
        });
        this.zoomToExtent(a)
    },
    zoomToScale: function(h, e) {
        var c = SuperMap.Util.getResolutionFromScale(h, this.baseLayer.units);
        var f = (this.size.w * c) / 2;
        var g = (this.size.h * c) / 2;
        var a = this.getCachedCenter();
        var d = new SuperMap.Bounds(a.lon - f,a.lat - g,a.lon + f,a.lat + g);
        this.zoomToExtent(d, e)
    },
    getLonLatFromViewPortPx: function(a) {
        var c = null;
        if (this.baseLayer != null) {
            c = this.baseLayer.getLonLatFromViewPortPx(a)
        }
        return c
    },
    getViewPortPxFromLonLat: function(c) {
        var a = null;
        if (this.baseLayer != null) {
            a = this.baseLayer.getViewPortPxFromLonLat(c)
        }
        return a
    },
    getLonLatFromPixel: function(a) {
        return this.getLonLatFromViewPortPx(a)
    },
    getPixelFromLonLat: function(c) {
        var a = this.getViewPortPxFromLonLat(c);
        a.x = Math.round(a.x);
        a.y = Math.round(a.y);
        return a
    },
    getGeodesicPixelSize: function(h) {
        var e = h ? this.getLonLatFromPixel(h) : (this.getCachedCenter() || new SuperMap.LonLat(0,0));
        var f = this.getResolution();
        var d = e.add(-f / 2, 0);
        var j = e.add(f / 2, 0);
        var c = e.add(0, -f / 2);
        var g = e.add(0, f / 2);
        var i = new SuperMap.Projection("EPSG:4326");
        var a = this.getProjectionObject() || i;
        if (!a.equals(i)) {
            d.transform(a, i);
            j.transform(a, i);
            c.transform(a, i);
            g.transform(a, i)
        }
        return new SuperMap.Size(SuperMap.Util.distVincenty(d, j),SuperMap.Util.distVincenty(c, g))
    },
    getViewPortPxFromLayerPx: function(e) {
        var d = null;
        if (e != null) {
            var c = parseInt(this.layerContainerDiv.style.left);
            var a = parseInt(this.layerContainerDiv.style.top);
            d = e.add(c, a)
        }
        return d
    },
    getLayerPxFromViewPortPx: function(d) {
        var e = null;
        if (d != null) {
            var c = -parseInt(this.layerContainerDiv.style.left);
            var a = -parseInt(this.layerContainerDiv.style.top);
            e = d.add(c, a);
            if (isNaN(e.x) || isNaN(e.y)) {
                e = null
            }
        }
        return e
    },
    getLonLatFromLayerPx: function(a) {
        a = this.getViewPortPxFromLayerPx(a);
        return this.getLonLatFromViewPortPx(a)
    },
    getLayerPxFromLonLat: function(c) {
        var a = this.getPixelFromLonLat(c);
        return this.getLayerPxFromViewPortPx(a)
    },
    CLASS_NAME: "SuperMap.Map"
});
SuperMap.Map.TILE_WIDTH = 256;
SuperMap.Map.TILE_HEIGHT = 256;
SuperMap.Layer = SuperMap.Class({
    id: null,
    name: null,
    div: null,
    opacity: null,
    alwaysInRange: null,
    EVENT_TYPES: ["loadstart", "loadend", "loadcancel", "visibilitychanged", "move", "moveend", "added", "removed", "tileloaded"],
    RESOLUTION_PROPERTIES: ["scales", "resolutions", "maxScale", "minScale", "maxResolution", "minResolution", "numZoomLevels", "maxZoomLevel"],
    events: null,
    map: null,
    isBaseLayer: false,
    alpha: false,
    displayInLayerSwitcher: true,
    visibility: true,
    inRange: false,
    imageSize: null,
    imageOffset: null,
    options: null,
    eventListeners: null,
    gutter: 0,
    projection: null,
    units: null,
    scales: null,
    resolutions: null,
    maxExtent: null,
    minExtent: null,
    maxResolution: null,
    minResolution: null,
    numZoomLevels: null,
    minScale: null,
    maxScale: null,
    displayOutsideMaxExtent: false,
    wrapDateLine: false,
    metadata: {},
    initialize: function(c, a) {
        this.addOptions(a);
        this.name = c;
        if (this.id == null) {
            this.id = SuperMap.Util.createUniqueID(this.CLASS_NAME + "_");
            this.div = SuperMap.Util.createDiv(this.id);
            this.div.style.width = "100%";
            this.div.style.height = "100%";
            this.div.dir = "ltr";
            this.events = new SuperMap.Events(this,this.div,this.EVENT_TYPES);
            if (this.eventListeners instanceof Object) {
                this.events.on(this.eventListeners)
            }
        }
        if (this.wrapDateLine) {
            this.displayOutsideMaxExtent = true
        }
    },
    destroy: function(a) {
        if (a == null) {
            a = true
        }
        if (this.map != null) {
            this.map.removeLayer(this, a)
        }
        this.projection = null;
        this.map = null;
        this.name = null;
        this.div = null;
        this.options = null;
        if (this.events) {
            if (this.eventListeners) {
                this.events.un(this.eventListeners)
            }
            this.events.destroy()
        }
        this.eventListeners = null;
        this.events = null
    },
    clone: function(a) {
        if (a == null) {
            a = new SuperMap.Layer(this.name,this.getOptions())
        }
        SuperMap.Util.applyDefaults(a, this);
        a.map = null;
        return a
    },
    getOptions: function() {
        var a = {};
        for (var c in this.options) {
            a[c] = this[c]
        }
        return a
    },
    setName: function(a) {
        if (a != this.name) {
            this.name = a;
            if (this.map != null) {
                this.map.events.triggerEvent("changelayer", {
                    layer: this,
                    property: "name"
                })
            }
        }
    },
    addOptions: function(f, a) {
        if (this.options == null) {
            this.options = {}
        }
        if (f) {
            if (typeof f.projection == "string") {
                f.projection = new SuperMap.Projection(f.projection)
            }
            if (f.projection) {
                SuperMap.Util.applyDefaults(f, SuperMap.Projection.defaults[f.projection.getCode()])
            }
            if (f.maxExtent && !(f.maxExtent instanceof SuperMap.Bounds)) {
                f.maxExtent = new SuperMap.Bounds(f.maxExtent)
            }
            if (f.minExtent && !(f.minExtent instanceof SuperMap.Bounds)) {
                f.minExtent = new SuperMap.Bounds(f.minExtent)
            }
        }
        SuperMap.Util.extend(this.options, f);
        SuperMap.Util.extend(this, f);
        if (this.projection && this.projection.getUnits()) {
            this.units = this.projection.getUnits()
        }
        if (this.map) {
            var c = this.map.getResolution();
            var d = this.RESOLUTION_PROPERTIES.concat(["projection", "units", "minExtent", "maxExtent"]);
            for (var e in f) {
                if (f.hasOwnProperty(e) && SuperMap.Util.indexOf(d, e) >= 0) {
                    this.initResolutions();
                    if (a && this.map.baseLayer === this) {
                        this.map.setCenter(this.map.getCenter(), this.map.getZoomForResolution(c), false, true);
                        this.map.events.triggerEvent("changebaselayer", {
                            layer: this
                        })
                    }
                    break
                }
            }
        }
    },
    onMapResize: function() {},
    redraw: function() {
        var c = false;
        if (this.map) {
            this.inRange = this.calculateInRange();
            var d = this.getExtent();
            if (d && this.inRange && this.visibility) {
                var a = true;
                this.moveTo(d, a, false);
                this.events.triggerEvent("moveend", {
                    zoomChanged: a
                });
                c = true
            }
        }
        return c
    },
    moveTo: function(c, a, d) {
        var e = this.visibility;
        if (!this.isBaseLayer) {
            e = e && this.inRange
        }
        this.display(e)
    },
    moveByPx: function(c, a) {},
    setMap: function(c) {
        if (this.map == null) {
            this.map = c;
            this.maxExtent = this.maxExtent || this.map.maxExtent;
            this.minExtent = this.minExtent || this.map.minExtent;
            this.projection = this.projection || this.map.projection;
            if (typeof this.projection == "string") {
                this.projection = new SuperMap.Projection(this.projection)
            }
            if (!this.units) {
                this.units = this.projection.getUnits() || this.map.units
            }
            this.initResolutions();
            if (!this.isBaseLayer) {
                this.inRange = this.calculateInRange();
                var a = ((this.visibility) && (this.inRange));
                this.div.style.display = a ? "" : "none"
            }
            this.setTileSize()
        }
    },
    afterAdd: function() {},
    removeMap: function(a) {},
    getImageSize: function(a) {
        return ( this.imageSize || this.tileSize)
    },
    setTileSize: function(a) {
        var c = (a) ? a : ((this.tileSize) ? this.tileSize : this.map.getTileSize());
        this.tileSize = c;
        if (this.gutter) {
            this.imageOffset = new SuperMap.Pixel(-this.gutter,-this.gutter);
            this.imageSize = new SuperMap.Size(c.w + (2 * this.gutter),c.h + (2 * this.gutter))
        }
    },
    getVisibility: function() {
        return this.visibility
    },
    setVisibility: function(a) {
        if (a != this.visibility) {
            this.visibility = a;
            this.display(a);
            this.redraw();
            if (this.map != null) {
                this.map.events.triggerEvent("changelayer", {
                    layer: this,
                    property: "visibility"
                })
            }
            this.events.triggerEvent("visibilitychanged")
        }
    },
    display: function(a) {
        if (a != (this.div.style.display != "none")) {
            this.div.style.display = (a && this.calculateInRange()) ? "block" : "none"
        }
    },
    calculateInRange: function() {
        var c = false;
        if (this.alwaysInRange) {
            c = true
        } else {
            if (this.map) {
                var a = this.map.getResolution();
                c = ((a >= this.minResolution) && (a <= this.maxResolution))
            }
        }
        return c
    },
    setIsBaseLayer: function(a) {
        if (a != this.isBaseLayer) {
            this.isBaseLayer = a;
            if (this.map != null) {
                this.map.events.triggerEvent("changebaselayer", {
                    layer: this
                })
            }
        }
    },
    initResolutions: function() {
        var f, a, j;
        var g = {}
          , e = true;
        for (f = 0,
        a = this.RESOLUTION_PROPERTIES.length; f < a; f++) {
            j = this.RESOLUTION_PROPERTIES[f];
            g[j] = this.options[j];
            if (e && this.options[j]) {
                e = false
            }
        }
        if (this.alwaysInRange == null) {
            this.alwaysInRange = e
        }
        if (g.resolutions == null) {
            g.resolutions = this.resolutionsFromScales(g.scales)
        }
        if (g.resolutions == null) {
            g.resolutions = this.calculateResolutions(g)
        }
        if (g.resolutions == null) {
            for (f = 0,
            a = this.RESOLUTION_PROPERTIES.length; f < a; f++) {
                j = this.RESOLUTION_PROPERTIES[f];
                g[j] = this.options[j] != null ? this.options[j] : this.map[j]
            }
            if (g.resolutions == null) {
                g.resolutions = this.resolutionsFromScales(g.scales)
            }
            if (g.resolutions == null) {
                g.resolutions = this.calculateResolutions(g)
            }
        }
        var d;
        if (this.options.maxResolution && this.options.maxResolution !== "auto") {
            d = this.options.maxResolution
        }
        if (this.options.minScale) {
            d = SuperMap.Util.getResolutionFromScale(this.options.minScale, this.units)
        }
        var c;
        if (this.options.minResolution && this.options.minResolution !== "auto") {
            c = this.options.minResolution
        }
        if (this.options.maxScale) {
            c = SuperMap.Util.getResolutionFromScale(this.options.maxScale, this.units)
        }
        if (g.resolutions) {
            g.resolutions.sort(function(k, i) {
                return ( i - k)
            });
            if (!d) {
                d = g.resolutions[0]
            }
            if (!c) {
                var h = g.resolutions.length - 1;
                c = g.resolutions[h]
            }
        }
        this.resolutions = g.resolutions;
        if (this.resolutions) {
            a = this.resolutions.length;
            this.scales = new Array(a);
            for (f = 0; f < a; f++) {
                this.scales[f] = SuperMap.Util.getScaleFromResolution(this.resolutions[f], this.units)
            }
            this.numZoomLevels = a
        }
        this.minResolution = c;
        if (c) {
            this.maxScale = SuperMap.Util.getScaleFromResolution(c, this.units)
        }
        this.maxResolution = d;
        if (d) {
            this.minScale = SuperMap.Util.getScaleFromResolution(d, this.units)
        }
    },
    resolutionsFromScales: function(e) {
        if (e == null) {
            return
        }
        var c, d, a;
        a = e.length;
        c = new Array(a);
        for (d = 0; d < a; d++) {
            c[d] = SuperMap.Util.getResolutionFromScale(e[d], this.units)
        }
        return c
    },
    calculateResolutions: function(l) {
        var m, k, h;
        var n = l.maxResolution;
        if (l.minScale != null) {
            n = SuperMap.Util.getResolutionFromScale(l.minScale, this.units)
        } else {
            if (n == "auto" && this.maxExtent != null) {
                m = this.map.getSize();
                k = this.maxExtent.getWidth() / m.w;
                h = this.maxExtent.getHeight() / m.h;
                n = Math.max(k, h)
            }
        }
        var g = l.minResolution;
        if (l.maxScale != null) {
            g = SuperMap.Util.getResolutionFromScale(l.maxScale, this.units)
        } else {
            if (l.minResolution == "auto" && this.minExtent != null) {
                m = this.map.getSize();
                k = this.minExtent.getWidth() / m.w;
                h = this.minExtent.getHeight() / m.h;
                g = Math.max(k, h)
            }
        }
        if (typeof n !== "number" && typeof g !== "number" && this.maxExtent != null) {
            var o = this.map.getTileSize();
            n = Math.max(this.maxExtent.getWidth() / o.w, this.maxExtent.getHeight() / o.h)
        }
        var a = l.maxZoomLevel;
        var c = l.numZoomLevels;
        if (typeof g === "number" && typeof n === "number" && c === undefined) {
            var j = n / g;
            c = Math.floor(Math.log(j) / Math.log(2)) + 1
        } else {
            if (c === undefined && a != null) {
                c = a + 1
            }
        }
        if (typeof c !== "number" || c <= 0 || (typeof n !== "number" && typeof g !== "number")) {
            return
        }
        var e = new Array(c);
        var d = 2;
        if (typeof g == "number" && typeof n == "number") {
            d = Math.pow((n / g), (1 / (c - 1)))
        }
        var f;
        if (typeof n === "number") {
            for (f = 0; f < c; f++) {
                e[f] = n / Math.pow(d, f)
            }
        } else {
            for (f = 0; f < c; f++) {
                e[c - 1 - f] = g * Math.pow(d, f)
            }
        }
        return e
    },
    getResolution: function() {
        var a = this.map.getZoom();
        return this.getResolutionForZoom(a)
    },
    getExtent: function() {
        return this.map.calculateBounds()
    },
    getZoomForExtent: function(c, d) {
        var e = this.map.getSize();
        var a = Math.max(c.getWidth() / e.w, c.getHeight() / e.h);
        return this.getZoomForResolution(a, d)
    },
    getDataExtent: function() {},
    getResolutionForZoom: function(d) {
        d = Math.max(0, Math.min(d, this.resolutions.length - 1));
        var c;
        if (this.map.fractionalZoom) {
            var a = Math.floor(d);
            var e = Math.ceil(d);
            c = this.resolutions[a] - ((d - a) * (this.resolutions[a] - this.resolutions[e]))
        } else {
            c = this.resolutions[Math.round(d)]
        }
        return c
    },
    getScaleForZoom: function(e) {
        var d, c, a;
        d = this.getResolutionForZoom(e);
        a = this.units;
        if (this.dpi) {
            c = SuperMap.Util.getScaleFromResolutionDpi(d, this.dpi, a, this.datumAxis)
        } else {
            c = SuperMap.Util.getScaleFromResolution(d, a)
        }
        return c
    },
    getZoomForResolution: function(f, c) {
        if (!f) {
            return 0
        }
        var o, g, h;
        if (this.map.fractionalZoom) {
            var l = 0;
            var d = this.resolutions.length - 1;
            var e = this.resolutions[l];
            var a = this.resolutions[d];
            var k;
            for (g = 0,
            h = this.resolutions.length; g < h; ++g) {
                k = this.resolutions[g];
                if (k >= f) {
                    e = k;
                    l = g
                }
                if (k <= f) {
                    a = k;
                    d = g;
                    break
                }
            }
            var j = e - a;
            if (j > 0) {
                o = l + ((e - f) / j)
            } else {
                o = l
            }
        } else {
            var m;
            var n = Number.POSITIVE_INFINITY;
            for (g = 0,
            h = this.resolutions.length; g < h; g++) {
                if (c) {
                    m = Math.abs(this.resolutions[g] - f);
                    if (m > n) {
                        break
                    }
                    n = m
                } else {
                    if (this.resolutions[g] < f) {
                        break
                    }
                }
            }
            o = Math.max(0, g - 1)
        }
        return o
    },
    getLonLatFromViewPortPx: function(c) {
        var e = null;
        var g = this.map;
        if (c != null && g.minPx) {
            var d = g.getResolution();
            var a = g.getMaxExtent({
                restricted: true
            });
            var h = (c.x - g.minPx.x) * d + a.left;
            var f = (g.minPx.y - c.y) * d + a.top;
            e = new SuperMap.LonLat(h,f);
            if (this.wrapDateLine) {
                e = e.wrapDateLine(this.maxExtent)
            }
        }
        return e
    },
    getViewPortPxFromLonLat: function(e) {
        var c = null;
        if (e != null) {
            var a = this.map.getResolution();
            var d = this.map.getExtent();
            c = new SuperMap.Pixel((1 / a * (e.lon - d.left)),(1 / a * (d.top - e.lat)))
        }
        return c
    },
    setOpacity: function(c) {
        if (c != this.opacity) {
            this.opacity = c;
            if (this.useCanvas) {
                this.redraw()
            } else {
                for (var e = 0, a = this.div.childNodes.length; e < a; ++e) {
                    var d = this.div.childNodes[e].firstChild;
                    SuperMap.Util.modifyDOMElement(d, null, null, null, null, null, null, c)
                }
            }
            if (this.map != null) {
                this.map.events.triggerEvent("changelayer", {
                    layer: this,
                    property: "opacity"
                })
            }
        }
    },
    getZIndex: function() {
        return this.div.style.zIndex
    },
    setZIndex: function(a) {
        this.div.style.zIndex = a
    },
    adjustBounds: function(c) {
        if (this.gutter) {
            var a = this.gutter * this.map.getResolution();
            c = new SuperMap.Bounds(c.left - a,c.bottom - a,c.right + a,c.top + a)
        }
        if (this.wrapDateLine) {
            var d = {
                rightTolerance: this.getResolution(),
                leftTolerance: this.getResolution()
            };
            c = c.wrapDateLine(this.maxExtent, d)
        }
        return c
    },
    CLASS_NAME: "SuperMap.Layer"
});
SuperMap.REST.GeometryType = {
    LINE: "LINE",
    LINEM: "LINEM",
    POINT: "POINT",
    REGION: "REGION",
    ELLIPSE: "ELLIPSE",
    CIRCLE: "CIRCLE",
    TEXT: "TEXT",
    UNKNOWN: "UNKNOWN"
};
SuperMap.REST.QueryOption = {
    ATTRIBUTE: "ATTRIBUTE",
    ATTRIBUTEANDGEOMETRY: "ATTRIBUTEANDGEOMETRY",
    GEOMETRY: "GEOMETRY"
};
SuperMap.REST.JoinType = {
    INNERJOIN: "INNERJOIN",
    LEFTJOIN: "LEFTJOIN"
};
SuperMap.REST.SpatialQueryMode = {
    CONTAIN: "CONTAIN",
    CROSS: "CROSS",
    DISJOINT: "DISJOINT",
    IDENTITY: "IDENTITY",
    INTERSECT: "INTERSECT",
    NONE: "NONE",
    OVERLAP: "OVERLAP",
    TOUCH: "TOUCH",
    WITHIN: "WITHIN"
};
SuperMap.REST.SpatialRelationType = {
    CONTAIN: "CONTAIN",
    INTERSECT: "INTERSECT",
    WITHIN: "WITHIN"
};
SuperMap.REST.MeasureMode = {
    DISTANCE: "DISTANCE",
    AREA: "AREA"
};
SuperMap.REST.Unit = {
    METER: "METER",
    KILOMETER: "KILOMETER",
    MILE: "MILE",
    YARD: "YARD",
    DEGREE: "DEGREE",
    MILLIMETER: "MILLIMETER",
    CENTIMETER: "CENTIMETER",
    INCH: "INCH",
    DECIMETER: "DECIMETER",
    FOOT: "FOOT",
    SECOND: "SECOND",
    MINUTE: "MINUTE",
    RADIAN: "RADIAN"
};
SuperMap.REST.EngineType = {
    IMAGEPLUGINS: "IMAGEPLUGINS",
    OGC: "OGC",
    ORACLEPLUS: "ORACLEPLUS",
    SDBPLUS: "SDBPLUS",
    SQLPLUS: "SQLPLUS",
    UDB: "UDB"
};
SuperMap.REST.ThemeGraphTextFormat = {
    CAPTION: "CAPTION",
    CAPTION_PERCENT: "CAPTION_PERCENT",
    CAPTION_VALUE: "CAPTION_VALUE",
    PERCENT: "PERCENT",
    VALUE: "VALUE"
};
SuperMap.REST.ThemeGraphType = {
    AREA: "AREA",
    BAR: "BAR",
    BAR3D: "BAR3D",
    LINE: "LINE",
    PIE: "PIE",
    PIE3D: "PIE3D",
    POINT: "POINT",
    RING: "RING",
    ROSE: "ROSE",
    ROSE3D: "ROSE3D",
    STACK_BAR: "STACK_BAR",
    STACK_BAR3D: "STACK_BAR3D",
    STEP: "STEP"
};
SuperMap.REST.GraduatedMode = {
    CONSTANT: "CONSTANT",
    LOGARITHM: "LOGARITHM",
    SQUAREROOT: "SQUAREROOT"
};
SuperMap.REST.RangeMode = {
    CUSTOMINTERVAL: "CUSTOMINTERVAL",
    EQUALINTERVAL: "EQUALINTERVAL",
    LOGARITHM: "LOGARITHM",
    QUANTILE: "QUANTILE",
    SQUAREROOT: "SQUAREROOT",
    STDDEVIATION: "STDDEVIATION"
};
SuperMap.REST.ThemeType = {
    DOTDENSITY: "DOTDENSITY",
    GRADUATEDSYMBOL: "GRADUATEDSYMBOL",
    GRAPH: "GRAPH",
    LABEL: "LABEL",
    RANGE: "RANGE",
    UNIQUE: "UNIQUE"
};
SuperMap.REST.ColorGradientType = {
    BLACK_WHITE: "BLACKWHITE",
    BLUE_BLACK: "BLUEBLACK",
    BLUE_RED: "BLUERED",
    BLUE_WHITE: "BLUEWHITE",
    CYAN_BLACK: "CYANBLACK",
    CYAN_BLUE: "CYANBLUE",
    CYAN_GREEN: "CYANGREEN",
    CYAN_WHITE: "CYANWHITE",
    GREEN_BLACK: "GREENBLACK",
    GREEN_BLUE: "GREENBLUE",
    GREEN_ORANGE_VIOLET: "GREENORANGEVIOLET",
    GREEN_RED: "GREENRED",
    GREEN_WHITE: "GREENWHITE",
    PINK_BLACK: "PINKBLACK",
    PINK_BLUE: "PINKBLUE",
    PINK_RED: "PINKRED",
    PINK_WHITE: "PINKWHITE",
    RAIN_BOW: "RAINBOW",
    RED_BLACK: "REDBLACK",
    RED_WHITE: "REDWHITE",
    SPECTRUM: "SPECTRUM",
    TERRAIN: "TERRAIN",
    YELLOW_BLACK: "YELLOWBLACK",
    YELLOW_BLUE: "YELLOWBLUE",
    YELLOW_GREEN: "YELLOWGREEN",
    YELLOW_RED: "YELLOWRED",
    YELLOW_WHITE: "YELLOWWHITE"
};
SuperMap.REST.TextAlignment = {
    TOPLEFT: "TOPLEFT",
    TOPCENTER: "TOPCENTER",
    TOPRIGHT: "TOPRIGHT",
    BASELINELEFT: "BASELINELEFT",
    BASELINECENTER: "BASELINECENTER",
    BASELINERIGHT: "BASELINERIGHT",
    BOTTOMLEFT: "BOTTOMLEFT",
    BOTTOMCENTER: "BOTTOMCENTER",
    BOTTOMRIGHT: "BOTTOMRIGHT",
    MIDDLELEFT: "MIDDLELEFT",
    MIDDLECENTER: "MIDDLECENTER",
    MIDDLERIGHT: "MIDDLERIGHT"
};
SuperMap.REST.FillGradientMode = {
    NONE: "NONE",
    LINEAR: "LINEAR",
    RADIAL: "RADIAL",
    CONICAL: "CONICAL",
    SQUARE: "SQUARE"
};
SuperMap.REST.AlongLineDirection = {
    NORMAL: "ALONG_LINE_NORMAL",
    LB_TO_RT: "LEFT_BOTTOM_TO_RIGHT_TOP",
    LT_TO_RB: "LEFT_TOP_TO_RIGHT_BOTTOM",
    RB_TO_LT: "RIGHT_BOTTOM_TO_LEFT_TOP",
    RT_TO_LB: "RIGHT_TOP_TO_LEFT_BOTTOM"
};
SuperMap.REST.LabelBackShape = {
    DIAMOND: "DIAMOND",
    ELLIPSE: "ELLIPSE",
    MARKER: "MARKER",
    NONE: "NONE",
    RECT: "RECT",
    ROUNDRECT: "ROUNDRECT",
    TRIANGLE: "TRIANGLE"
};
SuperMap.REST.LabelOverLengthMode = {
    NEWLINE: "NEWLINE",
    NONE: "NONE",
    OMIT: "OMIT"
};
SuperMap.REST.DirectionType = {
    EAST: "EAST",
    NONE: "NONE",
    NORTH: "NORTH",
    SOURTH: "SOURTH",
    WEST: "WEST"
};
SuperMap.REST.SideType = {
    LEFT: "LEFT",
    MIDDLE: "MIDDLE",
    NONE: "NONE",
    RIGHT: "RIGHT"
};
SuperMap.REST.SupplyCenterType = {
    FIXEDCENTER: "FIXEDCENTER",
    NULL: "NULL",
    OPTIONALCENTER: "OPTIONALCENTER"
};
SuperMap.REST.TurnType = {
    AHEAD: "AHEAD",
    BACK: "BACK",
    END: "END",
    LEFT: "LEFT",
    NONE: "NONE",
    RIGHT: "RIGHT"
};
SuperMap.REST.BufferEndType = {
    FLAT: "FLAT",
    ROUND: "ROUND"
};
SuperMap.REST.OverlayOperationType = {
    CLIP: "CLIP",
    ERASE: "ERASE",
    IDENTITY: "IDENTITY",
    INTERSECT: "INTERSECT",
    UNION: "UNION",
    UPDATE: "UPDATE",
    XOR: "XOR"
};
SuperMap.REST.SmoothMethod = {
    BSPLINE: "BSPLINE",
    POLISH: "POLISH"
};
SuperMap.REST.SurfaceAnalystMethod = {
    ISOLINE: "ISOLINE",
    ISOREGION: "ISOREGION"
};
SuperMap.REST.DataReturnMode = {
    DATASET_AND_RECORDSET: "DATASET_AND_RECORDSET",
    DATASET_ONLY: "DATASET_ONLY",
    RECORDSET_ONLY: "RECORDSET_ONLY"
};
SuperMap.REST.EditType = {
    ADD: "add",
    UPDATE: "update",
    DELETE: "delete"
};
SuperMap.REST.TransferTactic = {
    LESS_TIME: "LESS_TIME",
    LESS_TRANSFER: "LESS_TRANSFER",
    LESS_WALK: "LESS_WALK",
    MIN_DISTANCE: "MIN_DISTANCE"
};
SuperMap.REST.TransferPreference = {
    BUS: "BUS",
    SUBWAY: "SUBWAY",
    NO_SUBWAY: "NO_SUBWAY",
    NONE: "NONE"
};
SuperMap.REST.GridType = {
    CROSS: "CROSS",
    GRID: "GRID",
    POINT: "POINT"
};
SuperMap.REST.ColorSpaceType = {
    CMYK: "CMYK",
    RGB: "RGB"
};
SuperMap.REST.LayerType = {
    UGC: "UGC",
    WMS: "WMS",
    WFS: "WFS",
    CUSTOM: "CUSTOM"
};
SuperMap.REST.StatisticMode = {
    AVERAGE: "AVERAGE",
    MAX: "MAX",
    MIN: "MIN",
    STDDEVIATION: "STDDEVIATION",
    SUM: "SUM",
    VARIANCE: "VARIANCE"
};
SuperMap.REST.PixelFormat = {
    BIT16: "BIT16",
    BIT32: "BIT32",
    BIT64: "BIT64",
    SINGLE: "SINGLE",
    DOUBLE: "DOUBLE",
    UBIT1: "UBIT1",
    UBIT4: "UBIT4",
    UBIT8: "UBIT8",
    UBIT24: "UBIT24",
    UBIT32: "UBIT32"
};
SuperMap.REST.SearchMode = {
    KDTREE_FIXED_COUNT: "KDTREE_FIXED_COUNT",
    KDTREE_FIXED_RADIUS: "KDTREE_FIXED_RADIUS",
    NONE: "NONE",
    QUADTREE: "QUADTREE"
};
SuperMap.REST.InterpolationAlgorithmType = {
    KRIGING: "KRIGING",
    SimpleKriging: "SimpleKriging",
    UniversalKriging: "UniversalKriging"
};
SuperMap.REST.VariogramMode = {
    EXPONENTIAL: "EXPONENTIAL",
    GAUSSIAN: "GAUSSIAN",
    SPHERICAL: "SPHERICAL"
};
SuperMap.REST.Exponent = {
    EXP1: "EXP1",
    EXP2: "EXP2"
};
SuperMap.Icon = SuperMap.Class({
    url: null,
    size: null,
    offset: null,
    calculateOffset: null,
    imageDiv: null,
    px: null,
    initialize: function(a, c, e, d) {
        this.url = a;
        this.size = (c) ? c : new SuperMap.Size(20,20);
        this.offset = e ? e : new SuperMap.Pixel(-(this.size.w / 2),-(this.size.h / 2));
        this.calculateOffset = d;
        var f = SuperMap.Util.createUniqueID("OL_Icon_");
        this.imageDiv = SuperMap.Util.createAlphaImageDiv(f)
    },
    destroy: function() {
        this.erase();
        SuperMap.Event.stopObservingElement(this.imageDiv.firstChild);
        this.imageDiv.innerHTML = "";
        this.imageDiv = null
    },
    clone: function() {
        return new SuperMap.Icon(this.url,this.size,this.offset,this.calculateOffset)
    },
    setSize: function(a) {
        if (a != null) {
            this.size = a
        }
        this.draw()
    },
    setUrl: function(a) {
        if (a != null) {
            this.url = a
        }
        this.draw()
    },
    draw: function(a) {
        SuperMap.Util.modifyAlphaImageDiv(this.imageDiv, null, null, this.size, this.url, "absolute");
        this.moveTo(a);
        return this.imageDiv
    },
    erase: function() {
        if (this.imageDiv != null && this.imageDiv.parentNode != null) {
            SuperMap.Element.remove(this.imageDiv)
        }
    },
    setOpacity: function(a) {
        SuperMap.Util.modifyAlphaImageDiv(this.imageDiv, null, null, null, null, null, null, null, a)
    },
    moveTo: function(a) {
        if (a != null) {
            this.px = a
        }
        if (this.imageDiv != null) {
            if (this.px == null) {
                this.display(false)
            } else {
                if (this.calculateOffset) {
                    this.offset = this.calculateOffset(this.size)
                }
                var c = this.px.offset(this.offset);
                SuperMap.Util.modifyAlphaImageDiv(this.imageDiv, null, c)
            }
        }
    },
    display: function(a) {
        this.imageDiv.style.display = (a) ? "" : "none"
    },
    isDrawn: function() {
        var a = (this.imageDiv && this.imageDiv.parentNode && (this.imageDiv.parentNode.nodeType != 11));
        return a
    },
    CLASS_NAME: "SuperMap.Icon"
});
SuperMap.Marker = SuperMap.Class({
    icon: null,
    lonlat: null,
    events: null,
    map: null,
    initialize: function(d, c) {
        this.lonlat = d;
        var a = (c) ? c : SuperMap.Marker.defaultIcon();
        if (this.icon == null) {
            this.icon = a
        } else {
            this.icon.url = a.url;
            this.icon.size = a.size;
            this.icon.offset = a.offset;
            this.icon.calculateOffset = a.calculateOffset
        }
        this.events = new SuperMap.Events(this,this.icon.imageDiv,null)
    },
    getLonLat: function() {
        return this.lonlat
    },
    destroy: function() {
        this.erase();
        this.map = null;
        this.events.destroy();
        this.events = null;
        if (this.icon != null) {
            this.icon.destroy();
            this.icon = null
        }
    },
    draw: function(a) {
        return this.icon.draw(a)
    },
    erase: function() {
        if (this.icon != null) {
            this.icon.erase()
        }
    },
    moveTo: function(a) {
        if ((a != null) && (this.icon != null)) {
            this.icon.moveTo(a)
        }
        this.lonlat = this.map.getLonLatFromLayerPx(a)
    },
    isDrawn: function() {
        var a = (this.icon && this.icon.isDrawn());
        return a
    },
    onScreen: function() {
        var c = false;
        if (this.map) {
            var a = this.map.getExtent();
            c = a.containsLonLat(this.lonlat)
        }
        return c
    },
    inflate: function(c) {
        if (this.icon) {
            var a = new SuperMap.Size(this.icon.size.w * c,this.icon.size.h * c);
            this.icon.setSize(a)
        }
    },
    setOpacity: function(a) {
        this.icon.setOpacity(a)
    },
    setUrl: function(a) {
        this.icon.setUrl(a)
    },
    display: function(a) {
        this.icon.display(a)
    },
    CLASS_NAME: "SuperMap.Marker"
});
SuperMap.Marker.defaultIcon = function() {
    var a = SuperMap.Util.getImagesLocation() + "marker.png";
    var c = new SuperMap.Size(21,25);
    var d = function(e) {
        return new SuperMap.Pixel(-(e.w / 2),-e.h)
    };
    return new SuperMap.Icon(a,c,null,d)
}
;
SuperMap.Popup = SuperMap.Class({
    events: null,
    id: "",
    lonlat: null,
    div: null,
    contentSize: null,
    size: null,
    contentHTML: null,
    backgroundColor: "",
    opacity: "",
    border: "",
    contentDiv: null,
    groupDiv: null,
    closeDiv: null,
    autoSize: false,
    minSize: null,
    maxSize: null,
    displayClass: "olPopup",
    contentDisplayClass: "smPopupContent",
    padding: 0,
    disableFirefoxOverflowHack: false,
    fixPadding: function() {
        if (typeof this.padding == "number") {
            this.padding = new SuperMap.Bounds(this.padding,this.padding,this.padding,this.padding)
        }
    },
    panMapIfOutOfView: false,
    keepInMap: false,
    closeOnMove: false,
    map: null,
    initialize: function(h, d, g, c, f, e) {
        if (h == null) {
            h = SuperMap.Util.createUniqueID(this.CLASS_NAME + "_")
        }
        this.id = h;
        this.lonlat = d;
        this.contentSize = (g != null) ? g : new SuperMap.Size(SuperMap.Popup.WIDTH,SuperMap.Popup.HEIGHT);
        if (c != null) {
            this.contentHTML = c
        }
        this.backgroundColor = SuperMap.Popup.COLOR;
        this.opacity = SuperMap.Popup.OPACITY;
        this.border = SuperMap.Popup.BORDER;
        this.div = SuperMap.Util.createDiv(this.id, null, null, null, null, null, "visible");
        this.div.className = this.displayClass;
        var a = this.id + "_GroupDiv";
        this.groupDiv = SuperMap.Util.createDiv(a, null, null, null, "relative", null, "visible");
        var h = this.div.id + "_contentDiv";
        this.contentDiv = SuperMap.Util.createDiv(h, null, this.contentSize.clone(), null, "relative");
        this.contentDiv.className = this.contentDisplayClass;
        this.groupDiv.appendChild(this.contentDiv);
        this.div.appendChild(this.groupDiv);
        if (f) {
            this.addCloseBox(e)
        }
        this.registerEvents()
    },
    destroy: function() {
        this.id = null;
        this.lonlat = null;
        this.size = null;
        this.contentHTML = null;
        this.backgroundColor = null;
        this.opacity = null;
        this.border = null;
        if (this.closeOnMove && this.map) {
            this.map.events.unregister("movestart", this, this.hide)
        }
        this.events.destroy();
        this.events = null;
        if (this.closeDiv) {
            SuperMap.Event.stopObservingElement(this.closeDiv);
            this.groupDiv.removeChild(this.closeDiv)
        }
        this.closeDiv = null;
        this.div.removeChild(this.groupDiv);
        this.groupDiv = null;
        if (this.map != null) {
            this.map.removePopup(this)
        }
        this.map = null;
        this.div = null;
        this.autoSize = null;
        this.minSize = null;
        this.maxSize = null;
        this.padding = null;
        this.panMapIfOutOfView = null
    },
    draw: function(a) {
        if (a == null) {
            if ((this.lonlat != null) && (this.map != null)) {
                a = this.map.getLayerPxFromLonLat(this.lonlat)
            }
        }
        if (this.closeOnMove) {
            this.map.events.register("movestart", this, this.hide)
        }
        if (!this.disableFirefoxOverflowHack && SuperMap.Browser.name == "firefox") {
            this.map.events.register("movestart", this, function() {
                var c = document.defaultView.getComputedStyle(this.contentDiv, null);
                var d = c.getPropertyValue("overflow");
                if (d != "hidden") {
                    this.contentDiv._oldOverflow = d;
                    this.contentDiv.style.overflow = "hidden"
                }
            });
            this.map.events.register("moveend", this, function() {
                var c = this.contentDiv._oldOverflow;
                if (c) {
                    this.contentDiv.style.overflow = c;
                    this.contentDiv._oldOverflow = null
                }
            })
        }
        this.moveTo(a);
        if (!this.autoSize && !this.size) {
            this.setSize(this.contentSize)
        }
        this.setBackgroundColor();
        this.setOpacity();
        this.setBorder();
        this.setContentHTML();
        if (this.panMapIfOutOfView) {
            this.panIntoView()
        }
        return this.div
    },
    updatePosition: function() {
        if ((this.lonlat) && (this.map)) {
            var a = this.map.getLayerPxFromLonLat(this.lonlat);
            if (a) {
                this.moveTo(a)
            }
        }
    },
    moveTo: function(a) {
        if ((a != null) && (this.div != null)) {
            this.div.style.left = a.x + "px";
            this.div.style.top = a.y + "px"
        }
        if ((a != null) && (this.shadowDiv != null)) {
            this.shadowDiv.style.left = a.x + "px";
            this.shadowDiv.style.top = a.y + parseInt(this.div.style.height) / 3 + 15 + "px"
        }
    },
    visible: function() {
        return SuperMap.Element.visible(this.div)
    },
    toggle: function() {
        if (this.visible()) {
            this.hide()
        } else {
            this.show()
        }
    },
    show: function() {
        this.div.style.display = "";
        if (this.panMapIfOutOfView) {
            this.panIntoView()
        }
    },
    hide: function() {
        if (this.div) {
            this.div.style.display = "none"
        }
    },
    setSize: function(d) {
        this.size = d.clone();
        var c = this.getContentDivPadding();
        var a = c.left + c.right;
        var f = c.top + c.bottom;
        this.fixPadding();
        a += this.padding.left + this.padding.right;
        f += this.padding.top + this.padding.bottom;
        if (this.closeDiv) {
            var e = parseInt(this.closeDiv.style.width);
            a += e + c.right
        }
        this.size.w += a;
        this.size.h += f;
        if (SuperMap.Browser.name == "msie") {
            this.contentSize.w += c.left + c.right;
            this.contentSize.h += c.bottom + c.top
        }
        if (this.div != null) {
            this.div.style.width = this.size.w + "px";
            this.div.style.height = this.size.h + "px"
        }
        if (this.contentDiv != null) {
            this.contentDiv.style.width = d.w + "px";
            this.contentDiv.style.height = d.h + "px"
        }
    },
    updateSize: function() {
        var f = "<div class='" + this.contentDisplayClass + "'>" + this.contentDiv.innerHTML + "</div>";
        var i = (this.map) ? this.map.layerContainerDiv : document.body;
        var j = SuperMap.Util.getRenderedDimensions(f, null, {
            displayClass: this.displayClass,
            containerElement: i
        });
        var h = this.getSafeContentSize(j);
        var g = null;
        if (h.equals(j)) {
            g = j
        } else {
            var c = new SuperMap.Size();
            c.w = (h.w < j.w) ? h.w : null;
            c.h = (h.h < j.h) ? h.h : null;
            if (c.w && c.h) {
                g = h
            } else {
                var e = SuperMap.Util.getRenderedDimensions(f, c, {
                    displayClass: this.contentDisplayClass,
                    containerElement: i
                });
                var d = SuperMap.Element.getStyle(this.contentDiv, "overflow");
                if ((d != "hidden") && (e.equals(h))) {
                    var a = SuperMap.Util.getScrollbarWidth();
                    if (c.w) {
                        e.h += a
                    } else {
                        e.w += a
                    }
                }
                g = this.getSafeContentSize(e)
            }
        }
        this.setSize(g)
    },
    setBackgroundColor: function(a) {
        if (a != undefined) {
            this.backgroundColor = a
        }
        if (this.div != null) {
            this.div.style.backgroundColor = this.backgroundColor
        }
    },
    setOpacity: function(a) {
        if (a != undefined) {
            this.opacity = a
        }
        if (this.div != null) {
            this.div.style.opacity = this.opacity;
            this.div.style.filter = "alpha(opacity=" + this.opacity * 100 + ")"
        }
    },
    setBorder: function(a) {
        if (a != undefined) {
            this.border = a
        }
        if (this.div != null) {
            this.div.style.border = this.border
        }
    },
    setContentHTML: function(a) {
        if (a != null) {
            this.contentHTML = a
        }
        if ((this.contentDiv != null) && (this.contentHTML != null) && (this.contentHTML != this.contentDiv.innerHTML)) {
            this.contentDiv.innerHTML = this.contentHTML;
            if (this.autoSize) {
                this.registerImageListeners();
                this.updateSize()
            }
        }
    },
    registerImageListeners: function() {
        var g = function() {
            this.popup.updateSize();
            if (this.popup.visible() && this.popup.panMapIfOutOfView) {
                this.popup.panIntoView()
            }
            SuperMap.Event.stopObserving(this.img, "load", this.img._onImageLoad)
        };
        var c = this.contentDiv.getElementsByTagName("img");
        for (var f = 0, a = c.length; f < a; f++) {
            var d = c[f];
            if (d.width == 0 || d.height == 0) {
                var e = {
                    popup: this,
                    img: d
                };
                d._onImgLoad = SuperMap.Function.bind(g, e);
                SuperMap.Event.observe(d, "load", d._onImgLoad)
            }
        }
    },
    getSafeContentSize: function(l) {
        var e = l.clone();
        var j = this.getContentDivPadding();
        var k = j.left + j.right;
        var h = j.top + j.bottom;
        this.fixPadding();
        k += this.padding.left + this.padding.right;
        h += this.padding.top + this.padding.bottom;
        if (this.closeDiv) {
            var d = parseInt(this.closeDiv.style.width);
            k += d + j.right
        }
        if (this.minSize) {
            e.w = Math.max(e.w, (this.minSize.w - k));
            e.h = Math.max(e.h, (this.minSize.h - h))
        }
        if (this.maxSize) {
            e.w = Math.min(e.w, (this.maxSize.w - k));
            e.h = Math.min(e.h, (this.maxSize.h - h))
        }
        if (this.map && this.map.size) {
            var g = 0
              , f = 0;
            if (this.keepInMap && !this.panMapIfOutOfView) {
                var i = this.map.getPixelFromLonLat(this.lonlat);
                switch (this.relativePosition) {
                case "tr":
                    g = i.x;
                    f = this.map.size.h - i.y;
                    break;
                case "tl":
                    g = this.map.size.w - i.x;
                    f = this.map.size.h - i.y;
                    break;
                case "bl":
                    g = this.map.size.w - i.x;
                    f = i.y;
                    break;
                case "br":
                    g = i.x;
                    f = i.y;
                    break;
                default:
                    g = i.x;
                    f = this.map.size.h - i.y;
                    break
                }
            }
            var a = this.map.size.h - this.map.paddingForPopups.top - this.map.paddingForPopups.bottom - h - f;
            var c = this.map.size.w - this.map.paddingForPopups.left - this.map.paddingForPopups.right - k - g;
            e.w = Math.min(e.w, c);
            e.h = Math.min(e.h, a)
        }
        return e
    },
    getContentDivPadding: function() {
        var a = this._contentDivPadding;
        if (!a) {
            if (this.div.parentNode == null) {
                this.div.style.display = "none";
                document.body.appendChild(this.div)
            }
            a = new SuperMap.Bounds(SuperMap.Element.getStyle(this.contentDiv, "padding-left"),SuperMap.Element.getStyle(this.contentDiv, "padding-bottom"),SuperMap.Element.getStyle(this.contentDiv, "padding-right"),SuperMap.Element.getStyle(this.contentDiv, "padding-top"));
            this._contentDivPadding = a;
            if (this.div.parentNode == document.body) {
                document.body.removeChild(this.div);
                this.div.style.display = ""
            }
        }
        return a
    },
    addCloseBox: function(d) {
        this.closeDiv = SuperMap.Util.createDiv(this.id + "_close", null, new SuperMap.Size(17,17));
        this.closeDiv.className = "smPopupCloseBox";
        var c = this.getContentDivPadding();
        this.closeDiv.style.right = c.right + "px";
        this.closeDiv.style.top = c.top + "px";
        this.groupDiv.appendChild(this.closeDiv);
        var a = d || function(f) {
            this.hide();
            SuperMap.Event.stop(f)
        }
        ;
        SuperMap.Event.observe(this.closeDiv, "touchend", SuperMap.Function.bindAsEventListener(a, this));
        SuperMap.Event.observe(this.closeDiv, "click", SuperMap.Function.bindAsEventListener(a, this))
    },
    panIntoView: function() {
        var f = this.map.getSize();
        var e = this.map.getViewPortPxFromLayerPx(new SuperMap.Pixel(parseInt(this.div.style.left),parseInt(this.div.style.top)));
        var d = e.clone();
        if (e.x < this.map.paddingForPopups.left) {
            d.x = this.map.paddingForPopups.left
        } else {
            if ((e.x + this.size.w) > (f.w - this.map.paddingForPopups.right)) {
                d.x = f.w - this.map.paddingForPopups.right - this.size.w
            }
        }
        if (e.y < this.map.paddingForPopups.top) {
            d.y = this.map.paddingForPopups.top
        } else {
            if ((e.y + this.size.h) > (f.h - this.map.paddingForPopups.bottom)) {
                d.y = f.h - this.map.paddingForPopups.bottom - this.size.h
            }
        }
        var c = e.x - d.x;
        var a = e.y - d.y;
        this.map.pan(c, a)
    },
    registerEvents: function() {
        this.events = new SuperMap.Events(this,this.div,null,true);
        function a(c) {
            SuperMap.Event.stop(c, true)
        }
        this.events.on({
            mousedown: this.onmousedown,
            mousemove: this.onmousemove,
            mouseup: this.onmouseup,
            click: this.onclick,
            mouseout: this.onmouseout,
            dblclick: this.ondblclick,
            touchstart: a,
            scope: this
        })
    },
    onmousedown: function(a) {
        this.mousedown = true;
        SuperMap.Event.stop(a, true)
    },
    onmousemove: function(a) {
        if (this.mousedown) {
            SuperMap.Event.stop(a, true)
        }
    },
    onmouseup: function(a) {
        if (this.mousedown) {
            this.mousedown = false;
            SuperMap.Event.stop(a, true)
        }
    },
    onclick: function(a) {
        SuperMap.Event.stop(a, true)
    },
    onmouseout: function(a) {
        this.mousedown = false
    },
    ondblclick: function(a) {
        SuperMap.Event.stop(a, true)
    },
    CLASS_NAME: "SuperMap.Popup"
});
SuperMap.Popup.WIDTH = 200;
SuperMap.Popup.HEIGHT = 200;
SuperMap.Popup.COLOR = "white";
SuperMap.Popup.OPACITY = 1;
SuperMap.Popup.BORDER = "0px";
SuperMap.Tile = SuperMap.Class({
    EVENT_TYPES: ["loadstart", "loadend", "reload", "unload"],
    events: null,
    id: null,
    layer: null,
    url: null,
    bounds: null,
    size: null,
    position: null,
    isLoading: false,
    initialize: function(f, a, g, d, e, c) {
        this.layer = f;
        this.position = a.clone();
        this.bounds = g.clone();
        this.url = d;
        if (e) {
            this.size = e.clone()
        }
        this.id = SuperMap.Util.createUniqueID("Tile_");
        this.events = new SuperMap.Events(this,null,this.EVENT_TYPES);
        SuperMap.Util.extend(this, c)
    },
    unload: function() {
        if (this.isLoading) {
            this.isLoading = false;
            this.events.triggerEvent("unload")
        }
    },
    destroy: function() {
        this.layer = null;
        this.bounds = null;
        this.size = null;
        this.position = null;
        this.events.destroy();
        this.events = null
    },
    clone: function(a) {
        if (a == null) {
            a = new SuperMap.Tile(this.layer,this.position,this.bounds,this.url,this.size)
        }
        SuperMap.Util.applyDefaults(a, this);
        return a
    },
    draw: function() {
        var a = this.layer.maxExtent;
        var c = (a && this.bounds.intersectsBounds(a, false));
        this.shouldDraw = (c || this.layer.displayOutsideMaxExtent);
        this.clear();
        return this.shouldDraw
    },
    moveTo: function(c, a, d) {
        if (d == null) {
            d = true
        }
        this.bounds = c.clone();
        this.position = a.clone();
        if (d) {
            this.draw()
        }
    },
    clear: function() {},
    getBoundsFromBaseLayer: function(a) {
        var e = this.layer.map.getLonLatFromLayerPx(a);
        var d = a.clone();
        d.x += this.size.w;
        d.y += this.size.h;
        var c = this.layer.map.getLonLatFromLayerPx(d);
        if (e.lon > c.lon) {
            if (e.lon < 0) {
                e.lon = -180 - (e.lon + 180)
            } else {
                c.lon = 180 + c.lon + 180
            }
        }
        var f = new SuperMap.Bounds(e.lon,c.lat,c.lon,e.lat);
        return f
    },
    showTile: function() {
        if (this.shouldDraw) {
            this.show()
        }
    },
    show: function() {},
    hide: function() {},
    getCanvasContext: function() {
        var a = this.imgDiv || this.lastImage;
        if (SuperMap.Util.supportCanvas() && a && !this.isLoading) {
            if (!this.canvasContext) {
                var c = document.createElement("canvas");
                c.width = this.size.w;
                c.height = this.size.h;
                this.canvasContext = c.getContext("2d");
                this.canvasContext.drawImage(a, 0, 0)
            }
            return this.canvasContext
        }
    },
    CLASS_NAME: "SuperMap.Tile"
});
SuperMap.Tile.Image = SuperMap.Class(SuperMap.Tile, {
    url: null,
    imgDiv: null,
    frame: null,
    layerAlphaHack: null,
    isFirstDraw: true,
    maxGetUrlLength: null,
    initialize: function(f, a, g, d, e, c) {
        SuperMap.Tile.prototype.initialize.apply(this, arguments);
        if (this.maxGetUrlLength != null) {
            SuperMap.Util.extend(this, SuperMap.Tile.Image.IFrame)
        }
        this.url = d;
        this.frame = document.createElement("div");
        this.frame.style.overflow = "hidden";
        this.frame.style.position = "absolute";
        this.layerAlphaHack = this.layer.alpha && SuperMap.Util.alphaHack()
    },
    destroy: function() {
        if (this.imgDiv != null) {
            this.removeImgDiv()
        }
        this.imgDiv = null;
        if ((this.frame != null) && (this.frame.parentNode == this.layer.div)) {
            this.layer.div.removeChild(this.frame)
        }
        this.frame = null;
        this.layer.events.unregister("loadend", this, this.showTile);
        SuperMap.Tile.prototype.destroy.apply(this, arguments)
    },
    clone: function(a) {
        if (a == null) {
            a = new SuperMap.Tile.Image(this.layer,this.position,this.bounds,this.url,this.size)
        }
        a = SuperMap.Tile.prototype.clone.apply(this, [a]);
        a.imgDiv = null;
        return a
    },
    draw: function() {
        if (this.layer != this.layer.map.baseLayer && this.layer.reproject) {
            this.bounds = this.getBoundsFromBaseLayer(this.position)
        }
        var a = SuperMap.Tile.prototype.draw.apply(this, arguments);
        if ((SuperMap.Util.indexOf(this.layer.SUPPORTED_TRANSITIONS, this.layer.transitionEffect) != -1) || this.layer.singleTile) {
            if (a) {
                this.events.register("loadend", this, this.showTile);
                this.layer.events.register("loadend", this, this.showTile)
            } else {}
        } else {
            if (a && this.isFirstDraw) {
                this.events.register("loadend", this, this.showTile);
                this.isFirstDraw = false
            }
        }
        if (!a) {
            return false
        }
        if (this.isLoading) {
            this.events.triggerEvent("reload")
        } else {
            this.isLoading = true;
            this.events.triggerEvent("loadstart")
        }
        return this.renderTile()
    },
    renderTile: function() {
        this.url = this.layer.getURL(this.bounds);
        this.events.triggerEvent(this._loadEvent);
        this.initImgDiv();
        this.positionImage();
        return true
    },
    positionImage: function() {
        if (this.layer === null) {
            return
        }
        SuperMap.Util.modifyDOMElement(this.frame, null, this.position, this.size);
        this.imgDiv.style.opacity = 0;
        var a = this.layer.getImageSize(this.bounds);
        if (this.layerAlphaHack) {
            SuperMap.Util.modifyAlphaImageDiv(this.imgDiv, null, null, a, this.url)
        } else {
            SuperMap.Util.modifyDOMElement(this.imgDiv, null, null, a);
            this.imgDiv.src = this.url
        }
    },
    onImageLoad: function() {
        var a = this.imgDiv;
        this.canvasContext = null;
        a.style.visibility = "inherit";
        a.style.opacity = 0;
        this.events.triggerEvent("loadend");
        window.setTimeout(function(c) {
            return function() {
                var d = c.layer.opacity;
                a.style.opacity = (d || d == 0) ? d : 1
            }
        }(this), 10)
    },
    clear: function() {
        if (this.imgDiv) {
            this.hide();
            if (SuperMap.Tile.Image.useBlankTile) {
                this.imgDiv.src = SuperMap.Util.getImagesLocation() + "blank.gif"
            }
        }
        this.canvasContext = null
    },
    initImgDiv: function() {
        if (this.imgDiv == null) {
            var e = this.layer.imageOffset;
            var c = this.layer.getImageSize(this.bounds);
            if (this.layerAlphaHack) {
                this.imgDiv = SuperMap.Util.createAlphaImageDiv(null, e, c, null, "relative", null, null, null, true)
            } else {
                this.imgDiv = SuperMap.Util.createImage(null, e, c, null, "relative", null, null, true)
            }
            if (SuperMap.Util.isArray(this.layer.url)) {
                this.imgDiv.urls = this.layer.url.slice()
            }
            this.imgDiv.className = "smTileImage";
            this.frame.style.zIndex = this.isBackBuffer ? 0 : 1;
            this.frame.appendChild(this.imgDiv);
            this.layer.div.appendChild(this.frame);
            if (this.layer.opacity != null) {
                SuperMap.Util.modifyDOMElement(this.imgDiv, null, null, null, null, null, null, this.layer.opacity)
            }
            this.imgDiv.map = this.layer.map;
            var d = function() {
                if (this.isLoading) {
                    this.isLoading = false;
                    this.onImageLoad()
                }
            };
            if (this.layerAlphaHack) {
                SuperMap.Event.observe(this.imgDiv.childNodes[0], "load", SuperMap.Function.bind(d, this))
            } else {
                SuperMap.Event.observe(this.imgDiv, "load", SuperMap.Function.bind(d, this))
            }
            var a = function() {
                if (this.imgDiv._attempts > SuperMap.IMAGE_RELOAD_ATTEMPTS) {
                    d.call(this)
                }
            };
            SuperMap.Event.observe(this.imgDiv, "error", SuperMap.Function.bind(a, this))
        }
        this.imgDiv.viewRequestID = this.layer.map.viewRequestID
    },
    drawImgData: function(a) {
        this.imgDiv.removeAttribute("crossorigin");
        this.imgDiv.src = a
    },
    removeImgDiv: function() {
        SuperMap.Event.stopObservingElement(this.imgDiv);
        if (this.imgDiv.parentNode == this.frame) {
            this.frame.removeChild(this.imgDiv);
            this.imgDiv.map = null
        }
        this.imgDiv.urls = null;
        var a = this.imgDiv.firstChild;
        if (a) {
            SuperMap.Event.stopObservingElement(a);
            this.imgDiv.removeChild(a);
            delete a
        } else {
            this.imgDiv.src = SuperMap.Util.getImagesLocation() + "blank.gif"
        }
    },
    checkImgURL: function() {
        if (this.layer) {
            var a = this.layerAlphaHack ? this.imgDiv.firstChild.src : this.imgDiv.src;
            if (!SuperMap.Util.isEquivalentUrl(a, this.url)) {
                this.hide()
            }
        }
    },
    show: function() {
        this.frame.style.display = "";
        if (SuperMap.Util.indexOf(this.layer.SUPPORTED_TRANSITIONS, this.layer.transitionEffect) != -1) {
            if (SuperMap.IS_GECKO === true) {
                this.frame.scrollLeft = this.frame.scrollLeft
            }
        }
    },
    hide: function() {
        this.frame.style.display = "none"
    },
    createBackBuffer: function() {
        if (!this.imgDiv || this.isLoading) {
            return
        }
        var c;
        if (this.frame) {
            var a = this.frame.cloneNode(false);
            c = this.imgDiv;
            c.style.position = "absolute";
            c.style.left = a.style.left.replace(/px/, "%");
            c.style.right = a.style.right.replace(/px/, "%");
            c.style.width = a.style.width.replace(/px/, "%");
            c.style.height = a.style.height.replace(/px/, "%")
        } else {
            c = this.imgDiv
        }
        this.imgDiv = null;
        return c
    },
    CLASS_NAME: "SuperMap.Tile.Image"
});
SuperMap.Tile.Image.useBlankTile = (SuperMap.Browser.name == "safari" || SuperMap.Browser.name == "opera");
SuperMap.Animal = SuperMap.Class({
    count: 6,
    ratio: 0,
    lefttop: null,
    backupCanvas: null,
    backupCtx: null,
    aniCanvas: null,
    aniCtx: null,
    width: 0,
    height: 0,
    callback: null,
    timeoutID: null,
    layer: null,
    baseCanvas: null,
    baseCanvasCtx: null,
    aniFinish: true,
    step: 0,
    initialize: function(a) {
        this.layer = a;
        this.backupCanvas = document.createElement("canvas");
        this.backupCanvas.style.display = "none";
        this.backupCtx = this.backupCanvas.getContext("2d");
        if (this.layer.useHighSpeed && SuperMap.Browser.device === "pc") {
            this.aniCanvas = document.createElement("canvas");
            this.aniCtx = this.aniCanvas.getContext("2d");
            this.aniCanvas.style.position = "absolute"
        }
    },
    begin: function(a, c, d) {
        this.ratio = this.layer.lastResolution / this.layer.map.getResolution();
        this.leftTop = c;
        this.baseCanvas = a;
        this.baseCanvasCtx = a.getContext("2d");
        this.width = a.width;
        this.height = a.height;
        this.backupCanvas.width = this.width;
        this.backupCanvas.height = this.height;
        this.backupCtx.drawImage(this.baseCanvas, 0, 0);
        this.layer.resetCanvas();
        this.baseCanvasCtx.drawImage(this.backupCanvas, this.leftTop.x, this.leftTop.y, this.width * this.ratio, this.height * this.ratio);
        if (SuperMap.Browser.device === "pc") {
            this.triggerAnimal(d)
        }
    },
    triggerAnimal: function(a) {
        if (!this.aniFinish) {
            return
        }
        this.layer.div.appendChild(this.aniCanvas);
        this.aniCanvas.width = this.width;
        this.aniCanvas.height = this.height;
        this.aniCanvas.style.left = this.baseCanvas.style.left;
        this.aniCanvas.style.top = this.baseCanvas.style.top;
        this.aniFinish = false;
        this.step = 0;
        this.baseCanvas.style.display = "none";
        this.execZoomTo(a)
    },
    animalEnd: function() {
        this.aniFinish = true;
        this.layer.div.removeChild(this.aniCanvas);
        this.baseCanvas.style.display = ""
    },
    execZoomTo: function(h) {
        var e = this;
        var g = (this.leftTop.x) / this.count
          , d = (this.leftTop.y) / this.count;
        var a = (this.ratio - 1) * this.width / this.count
          , f = (this.ratio - 1) * this.height / this.count;
        e.step++;
        e.aniCtx.clearRect(0, 0, this.width, this.height);
        e.aniCtx.drawImage(e.backupCanvas, g * e.step, d * e.step, a * e.step + this.width, f * e.step + this.height);
        e.timeoutID && window.clearTimeout(e.timeoutID);
        if (e.step == e.count) {
            this.animalEnd();
            h && h()
        } else {
            var c = SuperMap.Function.bind(arguments.callee, this, h);
            e.timeoutID = window.setTimeout(c, 30)
        }
    },
    destroy: function() {
        var a = this;
        a.leftTop = null;
        a.backupCanvas = null;
        a.backupCtx = null;
        a.AniCanvas = null;
        a.AniCtx = null;
        a.callback = null;
        a.baseCanvas = null;
        a.baseCanvasCtx = null;
        a.layer = null;
        a.timeoutID && window.clearTimeout(a.timeoutID);
        a.timeoutID = null
    }
});
SuperMap.Animal2 = SuperMap.Class(SuperMap.Animal, {
    initialize: function(a) {
        this.layer = a;
        this.backupCanvas = document.createElement("canvas");
        this.backupCanvas.style.display = "none";
        this.backupCtx = this.backupCanvas.getContext("2d");
        this.aniCanvas = document.createElement("canvas");
        this.aniCtx = this.aniCanvas.getContext("2d");
        this.aniCanvas.style.position = "absolute";
        this.layer.div.appendChild(this.aniCanvas)
    },
    begin: function(a, c, d) {
        this.ratio = this.layer.lastResolution / this.layer.map.getResolution();
        this.leftTop = c;
        this.baseCanvas = a;
        this.baseCanvasCtx = a.getContext("2d");
        this.width = a.width;
        this.height = a.height;
        this.backupCanvas.width = this.width;
        this.backupCanvas.height = this.height;
        this.backupCtx.drawImage(this.baseCanvas, 0, 0);
        this.baseCanvasCtx.clearRect(0, 0, this.width, this.height);
        this.triggerAnimal(d)
    }
});
SuperMap.Layer.HTTPRequest = SuperMap.Class(SuperMap.Layer, {
    URL_HASH_FACTOR: (Math.sqrt(5) - 1) / 2,
    url: null,
    params: null,
    reproject: false,
    initialize: function(d, c, e, a) {
        SuperMap.Layer.prototype.initialize.apply(this, [d, a]);
        this.url = c;
        this.params = SuperMap.Util.extend({}, e)
    },
    destroy: function() {
        this.url = null;
        this.params = null;
        SuperMap.Layer.prototype.destroy.apply(this, arguments)
    },
    clone: function(a) {
        if (a == null) {
            a = new SuperMap.Layer.HTTPRequest(this.name,this.url,this.params,this.getOptions())
        }
        a = SuperMap.Layer.prototype.clone.apply(this, [a]);
        return a
    },
    setUrl: function(a) {
        this.url = a
    },
    mergeNewParams: function(c) {
        this.params = SuperMap.Util.extend(this.params, c);
        var a = this.redraw();
        if (this.map != null) {
            this.map.events.triggerEvent("changelayer", {
                layer: this,
                property: "params"
            })
        }
        return a
    },
    redraw: function(a) {
        if (a) {
            return this.mergeNewParams({
                _olSalt: Math.random()
            })
        } else {
            return SuperMap.Layer.prototype.redraw.apply(this, [])
        }
    },
    selectUrl: function(f, e) {
        var d = 1;
        for (var c = 0, a = f.length; c < a; c++) {
            d *= f.charCodeAt(c) * this.URL_HASH_FACTOR;
            d -= Math.floor(d)
        }
        this._attempts = (this._attempts) ? (this._attempts) : 0;
        return e[(Math.floor(d * e.length) + this._attempts) % e.length]
    },
    getFullRequestString: function(h, e) {
        var c = e || this.url;
        var g = SuperMap.Util.extend({}, this.params);
        g = SuperMap.Util.extend(g, h);
        var f = SuperMap.Util.getParameterString(g);
        if (SuperMap.Util.isArray(c)) {
            c = this.selectUrl(f, c)
        }
        var a = SuperMap.Util.upperCaseObject(SuperMap.Util.getParameters(c));
        for (var d in g) {
            if (d.toUpperCase()in a) {
                delete g[d]
            }
        }
        f = SuperMap.Util.getParameterString(g);
        return SuperMap.Util.urlAppend(c, f)
    },
    CLASS_NAME: "SuperMap.Layer.HTTPRequest"
});
SuperMap.Layer.Grid = SuperMap.Class(SuperMap.Layer.HTTPRequest, {
    tileSize: null,
    tileOriginCorner: "bl",
    tileOrigin: null,
    tileOptions: null,
    grid: null,
    singleTile: false,
    ratio: 1.5,
    buffer: 0,
    transitionEffect: null,
    SUPPORTED_TRANSITIONS: ["resize"],
    backBuffer: null,
    backBufferp: null,
    gridResolution: null,
    backBufferResolution: null,
    backBufferLonLat: null,
    backBufferTimerId: null,
    removeBackBufferDelay: null,
    numLoadingTiles: 0,
    tileLoadingDelay: 100,
    timerId: null,
    initialize: function(d, c, e, a) {
        SuperMap.Layer.HTTPRequest.prototype.initialize.apply(this, arguments);
        if (this.removeBackBufferDelay === null) {
            this.removeBackBufferDelay = this.singleTile ? 0 : 2500
        }
        this.events.addEventType("tileloaded");
        this.grid = [];
        this._moveGriddedTiles = SuperMap.Function.bind(this.moveGriddedTiles, this)
    },
    removeMap: function(a) {
        if (this.timerId != null) {
            window.clearTimeout(this.timerId);
            this.timerId = null
        }
        if (this.backBufferTimerId !== null) {
            window.clearTimeout(this.backBufferTimerId);
            this.backBufferTimerId = null
        }
    },
    destroy: function() {
        this.clearGrid();
        this.grid = null;
        this.tileSize = null;
        SuperMap.Layer.HTTPRequest.prototype.destroy.apply(this, arguments)
    },
    clearGrid: function() {
        if (this.grid) {
            for (var g = 0, c = this.grid.length; g < c; g++) {
                var f = this.grid[g];
                for (var d = 0, a = f.length; d < a; d++) {
                    var e = f[d];
                    this.removeTileMonitoringHooks(e);
                    e.destroy()
                }
            }
            this.grid = [];
            this.gridResolution = null
        }
    },
    clone: function(a) {
        if (a == null) {
            a = new SuperMap.Layer.Grid(this.name,this.url,this.params,this.getOptions())
        }
        a = SuperMap.Layer.HTTPRequest.prototype.clone.apply(this, [a]);
        if (this.tileSize != null) {
            a.tileSize = this.tileSize.clone()
        }
        a.grid = [];
        a.gridResolution = null;
        a.backBuffer = null;
        a.backBufferp = null;
        a.backBufferTimerId = null;
        return a
    },
    moveTo: function(e, a, f) {
        SuperMap.Layer.HTTPRequest.prototype.moveTo.apply(this, arguments);
        e = e || this.map.getExtent();
        if (e != null) {
            var d = !this.grid.length || a;
            var c = this.getTilesBounds();
            if (this.singleTile) {
                if (d || (!f && !c.containsBounds(e))) {
                    this.initSingleTile(e)
                }
            } else {
                if (d || !c.containsBounds(e, true)) {
                    this.initGriddedTiles(e)
                } else {
                    this.scheduleMoveGriddedTiles()
                }
            }
        }
    },
    applyBackBuffer: function(d) {
        if (this.backBufferTimerId !== null) {
            this.removeBackBuffer()
        }
        var k = this.backBuffer;
        if (!k) {
            var e = this.createBackBuffer();
            k = e[1];
            var h = this.backBufferp = e[0];
            if (!k) {
                return
            }
            this.div.insertBefore(h, this.div.firstChild);
            this.backBuffer = k;
            var f = this.grid[0][0].bounds;
            this.backBufferLonLat = {
                lon: f.left,
                lat: f.top
            };
            this.backBufferResolution = this.gridResolution
        }
        var a = k.style;
        var j = this.backBufferResolution / d;
        a.width = 100 * j + "%";
        a.height = 100 * j + "%";
        var i = this.getViewPortPxFromLonLat(this.backBufferLonLat, d);
        var c = parseInt(this.map.layerContainerDiv.style.left, 10);
        var g = parseInt(this.map.layerContainerDiv.style.top, 10);
        k.style.left = Math.round(i.x - c) + "%";
        k.style.top = Math.round(i.y - g) + "%"
    },
    createBackBuffer: function() {
        var e;
        if (this.grid.length > 0) {
            var d = document.createElement("div");
            d.id = this.div.id + "_pp";
            d.className = "smBackBufferpp";
            d.style.position = "absolute";
            d.style.width = "100px";
            d.style.height = "100px";
            e = document.createElement("div");
            e.id = this.div.id + "_bb";
            e.className = "smBackBuffer";
            e.style.position = "absolute";
            e.style.width = "100%";
            e.style.height = "100%";
            d.appendChild(e);
            for (var g = 0, c = this.grid.length; g < c; g++) {
                for (var f = 0, a = this.grid[g].length; f < a; f++) {
                    var h = this.grid[g][f].createBackBuffer();
                    if (!h) {
                        continue
                    }
                    h.style.top = (g * this.tileSize.h) + "%";
                    h.style.left = (f * this.tileSize.w) + "%";
                    e.appendChild(h)
                }
            }
        }
        return [d, e]
    },
    removeBackBuffer: function() {
        if (this.backBuffer) {
            this.div.removeChild(this.backBufferp);
            this.backBuffer = null;
            this.backBufferp = null;
            this.backBufferResolution = null;
            if (this.backBufferTimerId !== null) {
                window.clearTimeout(this.backBufferTimerId);
                this.backBufferTimerId = null
            }
        }
    },
    moveByPx: function(c, a) {
        if (!this.singleTile) {
            this.scheduleMoveGriddedTiles()
        }
    },
    scheduleMoveGriddedTiles: function() {
        if (this.timerId != null) {
            window.clearTimeout(this.timerId)
        }
        this.timerId = window.setTimeout(this._moveGriddedTiles, this.tileLoadingDelay)
    },
    setTileSize: function(a) {
        if (this.singleTile) {
            a = this.map.getSize();
            a.h = parseInt(a.h * this.ratio);
            a.w = parseInt(a.w * this.ratio)
        }
        SuperMap.Layer.HTTPRequest.prototype.setTileSize.apply(this, [a])
    },
    getTilesBounds: function() {
        var f = null;
        if (this.grid.length) {
            var a = this.grid.length - 1;
            var e = this.grid[a][0];
            var c = this.grid[0].length - 1;
            var d = this.grid[0][c];
            f = new SuperMap.Bounds(e.bounds.left,e.bounds.bottom,d.bounds.right,d.bounds.top)
        }
        return f
    },
    initSingleTile: function(g) {
        var a = g.getCenterLonLat();
        var i = g.getWidth() * this.ratio;
        var c = g.getHeight() * this.ratio;
        var h = new SuperMap.Bounds(a.lon - (i / 2),a.lat - (c / 2),a.lon + (i / 2),a.lat + (c / 2));
        var e = new SuperMap.LonLat(h.left,h.top);
        var d = this.map.getLayerPxFromLonLat(e);
        if (!this.grid.length) {
            this.grid[0] = []
        }
        var f = this.grid[0][0];
        if (!f) {
            f = this.addTile(h, d);
            this.addTileMonitoringHooks(f);
            f.draw();
            this.grid[0][0] = f
        } else {
            f.moveTo(h, d)
        }
        this.removeExcessTiles(1, 1)
    },
    calculateGridLayout: function(a, o, f) {
        var l = f * this.tileSize.w;
        var d = f * this.tileSize.h;
        var j = a.left - o.lon;
        var m = Math.floor(j / l) - this.buffer;
        var k = j / l - m;
        var g = -k * this.tileSize.w;
        var n = o.lon + m * l;
        var c = a.top - (o.lat + d);
        var i = Math.ceil(c / d) + this.buffer;
        var p = i - c / d;
        var e = -p * this.tileSize.h;
        var h = o.lat + i * d;
        return {
            tilelon: l,
            tilelat: d,
            tileoffsetlon: n,
            tileoffsetlat: h,
            tileoffsetx: g,
            tileoffsety: e
        }
    },
    getTileOrigin: function() {
        var c = this.tileOrigin;
        if (!c) {
            var d = this.getMaxExtent();
            var a = ({
                tl: ["left", "top"],
                tr: ["right", "top"],
                bl: ["left", "bottom"],
                br: ["right", "bottom"]
            })[this.tileOriginCorner];
            c = new SuperMap.LonLat(d[a[0]],d[a[1]])
        }
        return c
    },
    initGriddedTiles: function(k) {
        var h = this.map.getSize();
        var B = Math.ceil(h.h / this.tileSize.h) + Math.max(1, 2 * this.buffer);
        var E = Math.ceil(h.w / this.tileSize.w) + Math.max(1, 2 * this.buffer);
        var H = this.getTileOrigin();
        var t = this.map.getResolution();
        var s = this.calculateGridLayout(k, H, t);
        var g = Math.round(s.tileoffsetx);
        var d = Math.round(s.tileoffsety);
        var m = s.tileoffsetlon;
        var p = s.tileoffsetlat;
        var f = s.tilelon;
        var l = s.tilelat;
        this.origin = new SuperMap.Pixel(g,d);
        var A = g;
        var D = m;
        var z = 0;
        var a = parseInt(this.map.layerContainerDiv.style.left);
        var v = parseInt(this.map.layerContainerDiv.style.top);
        var C = []
          , F = this.map.getCenter();
        do {
            var j = this.grid[z++];
            if (!j) {
                j = [];
                this.grid.push(j)
            }
            m = D;
            g = A;
            var e = 0;
            do {
                var c = new SuperMap.Bounds(m,p,m + f,p + l);
                var o = g;
                o -= a;
                var n = d;
                n -= v;
                var r = new SuperMap.Pixel(o,n);
                var G = j[e++];
                if (!G) {
                    G = this.addTile(c, r);
                    this.addTileMonitoringHooks(G);
                    j.push(G)
                } else {
                    G.moveTo(c, r, false)
                }
                var u = c.getCenterLonLat();
                C.push({
                    tile: G,
                    distance: Math.pow(u.lon - F.lon, 2) + Math.pow(u.lat - F.lat, 2)
                });
                m += f;
                g += this.tileSize.w
            } while ((m <= k.right + f * this.buffer) || e < E || !((m = D) == 0 ? true : true));p -= l;
            d += this.tileSize.h
        } while ((p >= k.bottom - l * this.buffer) || z < B);this.gridResolution = this.map.getResolution();
        this.removeExcessTiles(z, e);
        C.sort(function(x, i) {
            return x.distance - i.distance
        });
        for (var w = 0, q = C.length; w < q; ++w) {
            C[w].tile.draw()
        }
    },
    getMaxExtent: function() {
        return this.maxExtent
    },
    addTile: function(c, a) {
        return new SuperMap.Tile.Image(this,a,c,null,this.tileSize,this.tileOptions)
    },
    addTileMonitoringHooks: function(a) {
        a.onLoadStart = function() {
            if (this.numLoadingTiles == 0) {
                this.events.triggerEvent("loadstart")
            }
            this.numLoadingTiles++
        }
        ;
        a.events.register("loadstart", this, a.onLoadStart);
        a.onLoadEnd = function(c) {
            this.numLoadingTiles--;
            this.events.triggerEvent("tileloaded", {
                tile: a,
                idx: c.idx
            });
            if (this.numLoadingTiles == 0) {
                this.events.triggerEvent("loadend");
                if (this.backBuffer) {
                    this.backBufferTimerId = window.setTimeout(SuperMap.Function.bind(this.removeBackBuffer, this), this.removeBackBufferDelay)
                }
            }
        }
        ;
        a.events.register("loadend", this, a.onLoadEnd);
        a.events.register("unload", this, a.onLoadEnd)
    },
    removeTileMonitoringHooks: function(a) {
        a.unload();
        a.events.un({
            loadstart: a.onLoadStart,
            loadend: a.onLoadEnd,
            unload: a.onLoadEnd,
            scope: this
        })
    },
    moveGriddedTiles: function() {
        var e = true;
        var d = this.buffer || 1;
        var c = this.grid[0][0].position;
        var a = parseInt(this.map.layerContainerDiv.style.left);
        var g = parseInt(this.map.layerContainerDiv.style.top);
        var f = c.add(a, g);
        if (f.x > -this.tileSize.w * (d - 1)) {
            this.shiftColumn(true)
        } else {
            if (f.x < -this.tileSize.w * d) {
                this.shiftColumn(false)
            } else {
                if (f.y > -this.tileSize.h * (d - 1)) {
                    this.shiftRow(true)
                } else {
                    if (f.y < -this.tileSize.h * d) {
                        this.shiftRow(false)
                    } else {
                        e = false
                    }
                }
            }
        }
        if (e) {
            this.timerId = window.setTimeout(this._moveGriddedTiles, 0)
        }
    },
    shiftRow: function(o) {
        var d = (o) ? 0 : (this.grid.length - 1);
        var c = this.grid;
        var g = c[d];
        var f = this.map.getResolution();
        var j = (o) ? -this.tileSize.h : this.tileSize.h;
        var h = f * -j;
        var n = (o) ? c.pop() : c.shift();
        for (var k = 0, m = g.length; k < m; k++) {
            var e = g[k];
            var a = e.bounds.clone();
            var l = e.position.clone();
            a.bottom = a.bottom + h;
            a.top = a.top + h;
            l.y = l.y + j;
            n[k].moveTo(a, l)
        }
        if (o) {
            c.unshift(n)
        } else {
            c.push(n)
        }
    },
    shiftColumn: function(n) {
        var e = (n) ? -this.tileSize.w : this.tileSize.w;
        var d = this.map.getResolution();
        var l = d * e;
        for (var f = 0, h = this.grid.length; f < h; f++) {
            var m = this.grid[f];
            var k = (n) ? 0 : (m.length - 1);
            var c = m[k];
            var a = c.bounds.clone();
            var g = c.position.clone();
            a.left = a.left + l;
            a.right = a.right + l;
            g.x = g.x + e;
            var j = n ? this.grid[f].pop() : this.grid[f].shift();
            j.moveTo(a, g);
            if (n) {
                m.unshift(j)
            } else {
                m.push(j)
            }
        }
    },
    removeExcessTiles: function(f, d) {
        while (this.grid.length > f) {
            var g = this.grid.pop();
            for (var c = 0, a = g.length; c < a; c++) {
                var e = g[c];
                this.removeTileMonitoringHooks(e);
                e.destroy()
            }
        }
        while (this.grid[0].length > d) {
            for (var c = 0, a = this.grid.length; c < a; c++) {
                var g = this.grid[c];
                if (g.length <= d) {
                    continue
                }
                var e = g.pop();
                this.removeTileMonitoringHooks(e);
                e.destroy()
            }
        }
    },
    onMapResize: function() {
        if (this.singleTile) {
            this.clearGrid();
            this.setTileSize()
        }
    },
    getTileBounds: function(e) {
        var d = this.maxExtent;
        var g = this.getResolution();
        var f = g * this.tileSize.w;
        var c = g * this.tileSize.h;
        var i = this.getLonLatFromViewPortPx(e);
        var a = d.left + (f * Math.floor((i.lon - d.left) / f));
        var h = d.bottom + (c * Math.floor((i.lat - d.bottom) / c));
        return new SuperMap.Bounds(a,h,a + f,h + c)
    },
    getServerResolution: function(c) {
        c = c || this.map.getResolution();
        if (this.serverResolutions && SuperMap.Util.indexOf(this.serverResolutions, c) === -1) {
            var d, a;
            for (d = this.serverResolutions.length - 1; d >= 0; d--) {
                a = this.serverResolutions[d];
                if (a > c) {
                    c = a;
                    break
                }
            }
            if (d === -1) {
                throw "no appropriate resolution in serverResolutions"
            }
        }
        return c
    },
    CLASS_NAME: "SuperMap.Layer.Grid"
});
SuperMap.Tile.CanvasImage = SuperMap.Class(SuperMap.Tile, {
    url: null,
    newImgTag: null,
    canvasType: null,
    frame: null,
    isLoading: false,
    canvas: null,
    lastImage: null,
    lastBounds: null,
    isBackBuffer: false,
    backBufferTile: null,
    fadingTimer: null,
    initialize: function(f, a, h, d, e, c) {
        var g = this;
        SuperMap.Tile.prototype.initialize.apply(g, arguments);
        g.url = d;
        g.canvasType = c;
        g.events.addEventType("reprojectionProgress");
        g.events.addEventType("filterProgress")
    },
    destroy: function() {
        SuperMap.Tile.prototype.destroy.apply(this, arguments);
        var a = this;
        a.lastImage = null;
        a.canvas = null;
        a.canvasContext = null;
        if (a.backBufferTile) {
            a.backBufferTile.destroy();
            a.backBufferTile = null;
            a.layer.events.unregister("loadend", a, a.hideBackBuffer)
        }
    },
    clone: function(c) {
        var a = this;
        if (c == null) {
            c = new SuperMap.Tile.CanvasImage(a.layer,a.position,a.bounds,a.url,a.size,a.canvasType)
        }
        c = SuperMap.Tile.prototype.clone.apply(a, [c]);
        c.canvas = null;
        return c
    },
    draw: function() {
        var c = this;
        if (c.layer != c.layer.map.baseLayer && c.layer.reproject) {
            c.bounds = c.getBoundsFromBaseLayer(c.position)
        }
        var a = SuperMap.Tile.prototype.draw.apply(c, arguments);
        c.startTransition(a);
        if (!a) {
            return
        }
        if (c.isLoading) {
            c.events.triggerEvent("reload")
        } else {
            c.isLoading = true;
            c.events.triggerEvent("loadstart")
        }
        return c.renderTile()
    },
    startTransition: function(a) {},
    renderTile: function() {
        var a = this;
        a.url = a.layer.getURL(a.bounds);
        a.positionImage();
        return true
    },
    createImage: function() {
        if (this.lastImage !== null && !this.lastImage.complete) {
            this.lastImage.src = ""
        }
        var f = this
          , c = f.layer.getMemoryImg(f.bounds);
        f.lastBounds = f.bounds.clone();
        if (c) {
            f.newImgTag = "";
            f.lastImage = c;
            f.layer.drawCanvasTile(c, f.position);
            if (f.firstInView) {
                f.setFirstInView()
            }
        } else {
            var j = f.layer.getXYZ(f.bounds);
            if (!SuperMap.isApp) {
                f.newImgTag = j.x + "_" + j.y + "_" + j.z;
                f.loadTileImage()
            } else {
                var h = j.x, g = j.y, e;
                if (f.layer instanceof SuperMap.Layer.CloudLayer || f.layer.storageType == "db") {
                    e = j.z
                } else {
                    e = f.layer.scales[j.z].toExponential()
                }
                var d = {
                    tile: f,
                    X: h,
                    Y: g,
                    Z: e,
                    viewRequestID: f.layer.map.viewRequestID
                };
                f.newImgTag = h + "_" + g + "_" + e;
                f.lastImage = new Image();
                var i = f.getMethodName();
                var a = function(k, l) {
                    return function(m) {
                        window[l] = null;
                        k.tile.onLoadsaveUrlFunction(k, m)
                    }
                }(d, i);
                window[i] = a;
                cordova.exec(function() {}, function(k) {}, "LocalStoragePlugin", "getImg", [f.url, f.layer.name, h, g, e, i])
            }
        }
    },
    getMethodName: function() {
        var i = new Date();
        var f = i.getFullYear();
        var g = i.getMonth() + 1;
        var h = i.getDate();
        var d = i.getHours();
        var e = i.getMinutes();
        var j = i.getSeconds();
        var c = i.getMilliseconds();
        var a = "getImgFromLocal_" + f + g + h + d + e + j + c + (Math.round(Math.random() * 10000));
        return a
    },
    onLoadsaveUrlFunction: function(a, e) {
        var d = this;
        var c = e.x + "_" + e.y + "_" + e.z;
        if (d.newImgTag != c) {
            return
        }
        if (e.data) {
            if (e.data == "null") {
                return false
            }
            var f = "data:image/jpeg;base64," + e.data
        } else {
            var f = d.layer.sdcardPath + "SuperMap/" + d.layer.name + "/" + a.Z + "/" + a.X + "_" + a.Y + ".png"
        }
        d.url = f;
        d.loadTileImage()
    },
    loadTileImage: function() {
        var e = this
          , f = new Image();
        f.firstInView = true;
        e.lastImage = f;
        var d = {
            image: f,
            tile: e,
            viewRequestID: e.layer.map.viewRequestID,
            newImgTag: e.newImgTag
        };
        var a = function() {
            if (this.tile.newImgTag == this.newImgTag) {
                this.tile.onLoadFunction(this)
            }
        };
        var c = function() {
            this.tile.onErrorFunction(this)
        };
        f.onload = SuperMap.Function.bind(a, d);
        f.onerror = SuperMap.Function.bind(c, d);
        f.src = e.url
    },
    positionImage: function() {
        var a = this;
        if (!a.layer) {
            return
        }
        a.createImage()
    },
    onLoadFunction: function(a) {
        if ((this.layer === null) || (a.viewRequestID !== this.layer.map.viewRequestID) || (a.image !== this.lastImage)) {
            return
        }
        this.canvasContext = null;
        var c = a.image;
        if (a.tile.shouldDraw) {
            this.displayImage(c, a.newImgTag)
        }
        this.layer.addMemoryImg(this.lastBounds, c, a)
    },
    drawImgData: function(e, d) {
        var c, a = d.idx;
        c = new Image();
        c.onload = function(h, g, f) {
            return function() {
                if (f == h.newImgTag) {
                    h.lastImage = g;
                    h.layer.drawCanvasTile(g, h.position)
                }
            }
        }(this, c, a);
        if (a == this.newImgTag) {
            c.src = e
        }
    },
    displayImage: function(e, a) {
        var d = this
          , c = d.layer;
        if (c.canvasFilter && !e.filtered) {
            d.filter(e);
            return
        }
        c.drawCanvasTile(e, d.position);
        d.isLoading = false;
        if (e.firstInView) {
            d.setFirstInView()
        }
        d.events.triggerEvent("loadend", {
            idx: a
        })
    },
    onErrorFunction: function(a) {
        var c = this;
        if (a.image !== c.lastImage) {
            return
        }
        c._attempts = (c._attempts) ? (c._attempts + 1) : 1;
        if (c._attempts <= SuperMap.IMAGE_RELOAD_ATTEMPTS) {
            if (c.layer.url && SuperMap.Util.isArray(c.layer.url) && c.layer.url.length > 1) {
                c.layer._attempts = c._attempts;
                c.draw();
                return
            }
        } else {
            c._attempts = 0
        }
        c.events.triggerEvent("loadend")
    },
    setFirstInView: function() {
        var c = this;
        if (!c.fadingTimer) {
            var a = {
                canvasImage: c,
                image: c.lastImage
            };
            c.fadingTimer = window.setTimeout(SuperMap.Function.bind(c.setNotFirstInView, a), 100)
        }
    },
    setNotFirstInView: function() {
        var a = this;
        a.image.firstInView = false;
        window.clearTimeout(a.canvasImage.fadingTimer);
        a.canvasImage.fadingTimer = null;
        a.canvasImage.displayImage(a.image)
    },
    show: function() {},
    hide: function() {},
    isTooBigCanvas: function(a) {
        return a.w > 5000
    },
    moveTo: function(c, a, d) {
        if (d == null) {
            d = true
        }
        this.bounds = c.clone();
        this.position = a.clone();
        this.layer.redrawCanvas = false;
        if (d) {
            this.draw()
        }
    },
    CLASS_NAME: "SuperMap.Tile.CanvasImage"
});
SuperMap.CanvasLayer = SuperMap.Class(SuperMap.Layer.Grid, {
    useCanvas: true,
    canvas: null,
    canvasContext: null,
    lastResolution: null,
    lastCanvasPosition: null,
    redrawCanvas: false,
    format: "png",
    dpi: null,
    isBaseLayer: true,
    tileOriginCorner: "tl",
    datumAxis: null,
    timeoutID: null,
    memoryImg: null,
    memoryKeys: [],
    bufferImgCount: 1000,
    isFirstLoad: true,
    zoomDuration: 500,
    isZoomming: null,
    useHighSpeed: true,
    changeDx: null,
    changeDy: null,
    lenColumn: null,
    lenRow: null,
    sdcardPath: null,
    storageType: "File",
    transitionObj: null,
    inZoom: false,
    initialize: function(d, c, g, a) {
        var e = this
          , f = SuperMap.Browser;
        if (!!SuperMap.isApp) {
            e.bufferImgCount = 500
        }
        SuperMap.Layer.Grid.prototype.initialize.apply(e, arguments);
        if (e.useCanvas) {
            e.useCanvas = SuperMap.Util.supportCanvas()
        }
        if (f.device === "android") {
            e.useCanvas = false
        }
        if (SuperMap.isApp) {
            e.sdcardPath = "file://" + cordova.exec(function() {}, function(h) {}, "LocalStoragePlugin", "getsdcard", []).sdcard + "/";
            e.useCanvas = true
        }
        if (e.useCanvas) {
            e.canvas = document.createElement("canvas");
            e.canvas.id = "Canvas_" + e.id;
            e.canvas.style.position = "absolute";
            e.div.appendChild(e.canvas);
            e.canvasContext = e.canvas.getContext("2d");
            e.transitionObj = new SuperMap.Animal(e);
            e.memoryImg = {}
        }
        e.useHighSpeed = e.useCanvas ? true : false;
        e.isFirstLoad = true
    },
    removeMap: function(a) {
        SuperMap.Layer.Grid.prototype.removeMap.apply(this, [a]);
        this._timeoutId && window.clearTimeout(this._timeoutId);
        this._timeoutId = null
    },
    destroy: function() {
        var a = this;
        SuperMap.Layer.Grid.prototype.destroy.apply(a, arguments);
        a.format = null;
        a.dpi = null;
        a.datumAxis = null;
        a.isBaseLayer = null;
        a.tileOriginCorner = null;
        a.tileSize = null;
        a.bufferContext = null;
        if (a.transitionObj) {
            a.transitionObj.destroy();
            a.trnasitionObj = null
        }
        if (a.useCanvas) {
            a.canvas = null;
            a.memoryImg = null
        }
    },
    clone: function(c) {
        var a = this;
        if (c == null) {
            c = new SuperMap.CanvasLayer(a.name,a.url,a.params,a.getOptions())
        }
        c = SuperMap.Layer.Grid.prototype.clone.apply(a, [c]);
        return c
    },
    moveTo: function(a, c, n) {
        var j = this
          , i = this.lastResolution / this.map.getResolution()
          , d = this.map.layerContainerDiv.style
          , e = parseInt(d.left)
          , l = parseInt(d.top);
        this.inZoom = c ? true : false;
        this.changeDx = -e;
        this.changeDy = -l;
        if (!c && !j.isZoomming && j.useCanvas) {
            this.fixPosition()
        }
        SuperMap.Layer.HTTPRequest.prototype.moveTo.apply(j, arguments);
        a = a || j.map.getExtent();
        j.redrawCanvas = c;
        j.dragging = n;
        var g = this.map.getResolution();
        if (j.useCanvas && i != 1) {
            if (!c || n || (this.lastResolution === null) || (this.lastCanvasPosition === null)) {} else {
                var f = this.getLayerPxFromLonLat(this.lastCanvasPosition);
                if (!this.map.isIEMultipTouch) {
                    this.transitionObj.begin(this.canvas, f)
                }
            }
        }
        if (a != null) {
            var h = !j.grid.length || c;
            var m = j.getTilesBounds();
            if (this.singleTile) {
                if (h || (!n && !m.containsBounds(a))) {
                    if (c && this.transitionEffect !== "resize") {
                        this.removeBackBuffer()
                    }
                    if (!c || this.transitionEffect === "resize") {
                        this.applyBackBuffer(g)
                    }
                    this.initSingleTile(a)
                }
            } else {
                if (h || !m.containsBounds(a, true)) {
                    if (this.useCanvas) {
                        if (this.isFirstLoad) {
                            this.redrawCanvas = true;
                            this.inZoom = true;
                            this.isFirstLoad = false
                        }
                    }
                    if (this.zoomDuration && j.useCanvas) {
                        this.resetCanvas();
                        this.isZoomming = true;
                        window.clearTimeout(this._timeoutId);
                        this._timeoutId = window.setTimeout(SuperMap.Function.bind(function() {
                            this.initGriddedTiles(a)
                        }, this), this.zoomDuration)
                    } else {
                        if (c && this.transitionEffect === "resize") {
                            this.applyBackBuffer(g)
                        }
                        this.initGriddedTiles(a)
                    }
                } else {
                    this.scheduleMoveGriddedTiles()
                }
            }
        }
        if (j.useCanvas) {
            var k = new SuperMap.Pixel(this.changeDx,this.changeDy);
            this.lastCanvasPosition = this.map.getLonLatFromLayerPx(k)
        }
    },
    scheduleMoveGriddedTiles: function() {
        if (this.useHighSpeed) {
            this.moveGriddedTiles()
        } else {
            this.timerId && window.clearTimeout(this.timerId);
            this.timerId = window.setTimeout(this._moveGriddedTiles, this.tileLoadingDelay)
        }
    },
    moveGriddedTiles: function() {
        var e = true;
        var d = this.buffer || 1;
        var c = this.grid[0][0].position;
        var a = -this.changeDx;
        var g = -this.changeDy;
        var f = c.add(a, g);
        if (f.x > -this.tileSize.w * (d - 1)) {
            this.shiftColumn(true)
        } else {
            if (f.x < -this.tileSize.w * d) {
                this.shiftColumn(false)
            } else {
                if (f.y > -this.tileSize.h * (d - 1)) {
                    this.shiftRow(true)
                } else {
                    if (f.y < -this.tileSize.h * d) {
                        this.shiftRow(false)
                    } else {
                        e = false
                    }
                }
            }
        }
        if (e) {
            if (this.useHighSpeed) {
                this.moveGriddedTiles()
            } else {
                this.timerId = window.setTimeout(this._moveGriddedTiles, 0)
            }
        } else {}
    },
    moveByPx: function(c, a) {
        this._timeoutId && window.clearTimeout(this._timeoutId);
        this.changeDx += c;
        this.changeDy += a;
        if (this.useHighSpeed) {
            this.fixPosition();
            this.scheduleMoveGriddedTiles()
        }
    },
    fixPosition: function() {
        var g, h, c, a, f = this;
        f.canvasContext.clearRect(0, 0, f.canvas.width, f.canvas.height);
        for (c = 0; c < this.lenRow; c++) {
            for (a = 0; a < this.lenColumn; a++) {
                g = f.grid[c][a];
                h = g.lastImage;
                if ((h != null) && (g.shouldDraw === true) && (h.width > 0 && h.height > 0) && h.complete) {
                    var e = g.position.x - f.changeDx;
                    var d = g.position.y - f.changeDy;
                    if (g.lastImage.firstInView) {
                        if (f.getExtent().containsLonLat(g.bounds.getCenterLonLat())) {
                            g.lastImage.firstInView = false
                        } else {
                            if (f.getExtent().intersectsBounds(g.bounds)) {
                                g.setFirstInView()
                            }
                        }
                    }
                    f.drawCanvasTile2(g.lastImage, e, d, false)
                }
            }
        }
    },
    addTile: function(c, a) {
        return this.useCanvas ? new SuperMap.Tile.CanvasImage(this,a,c,null,this.tileSize,this.useCanvas) : new SuperMap.Tile.Image(this,a,c,null,this.tileSize,this.useCanvas)
    },
    drawCanvasTile: function(h, a) {
        if (this.dragging) {
            return
        }
        if (this.inZoom) {
            h.firstInView = false
        }
        this.resetCanvas();
        var c = this.map.layerContainerDiv.style;
        var g = parseInt(c.left)
          , f = parseInt(c.top);
        if (SuperMap.Browser.name === "msie") {
            var d = {
                layer: this,
                position: a,
                image: h,
                mapStyle: c
            };
            var e = SuperMap.Function.bind(this.drawCanvasIE, d);
            window.setTimeout(e, 100)
        } else {
            this.drawCanvasTile2(h, a.x + g, a.y + f)
        }
    },
    drawImgData: function(f, e) {
        var a = this.map.layerContainerDiv.style;
        var d = parseInt(a.left)
          , c = parseInt(a.top);
        this.canvasContext.putImageData(f, e.x + d, e.y + c)
    },
    drawCanvasIE: function() {
        this.layer.drawCanvasTile2(this.image, this.position.x + parseInt(this.mapStyle.left), this.position.y + parseInt(this.mapStyle.top))
    },
    drawCanvasTile2: function(f, e, d, a) {
        a = a || true;
        if (f) {
            a && this.canvasContext.clearRect(e, d, f.width, f.height);
            if (typeof this.opacity == "number") {
                var c = this.opacity > 0.3 ? this.opacity - 0.3 : 0.1;
                this.canvasContext.globalAlpha = f.firstInView ? c : this.opacity
            } else {
                this.canvasContext.globalAlpha = f.firstInView ? 0.6 : 1
            }
            this.canvasContext.drawImage(f, e, d)
        }
    },
    resetCanvas: function() {
        if (this.redrawCanvas) {
            this.redrawCanvas = false;
            this.canvas.width = this.map.viewPortDiv.clientWidth;
            this.canvas.height = this.map.viewPortDiv.clientHeight;
            this.canvasContext.clearRect(0, 0, this.canvas.width, this.canvas.height);
            if (this.useCanvas) {
                this.lastResolution = this.map.getResolution()
            }
            return true
        }
        return false
    },
    initGriddedTiles: function(a) {
        this.isZoomming = false;
        SuperMap.Layer.Grid.prototype.initGriddedTiles.apply(this, arguments);
        this.lenRow = this.grid.length;
        this.lenColumn = this.grid[0].length
    },
    getLayerPxFromLonLat: function(a) {
        return this.usesCanvas ? this.map.getPixelFromLonLat(a) : this.map.getLayerPxFromLonLat(a)
    },
    getViewPortPxFromLayerPx: function(a) {
        return this.useCanvas ? a : this.map.getViewPortPxFromLayerPx(a)
    },
    getURL: function(d) {
        var c = this, a;
        d = c.adjustBounds(d);
        a = c.getXYZ(d);
        return c.getTileUrl(a)
    },
    getXYZ: function(c) {
        var g = this, i, h, f, d = g.map, e = d.getResolution(), a = g.getTileOrigin(), j = g.tileSize;
        i = Math.round((c.left - a.lon) / (e * j.w));
        h = Math.round((a.lat - c.top) / (e * j.h));
        f = d.getZoom();
        return {
            x: i,
            y: h,
            z: f
        }
    },
    getMemoryImg: function(d) {
        var c = this
          , a = c.getXYZ(d);
        a = "x" + a.x + "y" + a.y + "z" + a.z;
        return c.memoryImg[a]
    },
    addMemoryImg: function(g, i, d) {
        var f = this;
        if (f.bufferImgCount == 0) {
            return
        }
        var h = d.newImgTag;
        if (h && h != "") {
            if (f.memoryKeys.length >= f.bufferImgCount) {
                var a = f.memoryKeys.shift();
                f.memoryImg[a] = null;
                delete f.memoryImg[a]
            }
            var e = h.split("_");
            var c = "x" + e[0] + "y" + e[1] + "z" + e[2];
            f.memoryImg[c] = i;
            f.memoryKeys.push(c)
        }
    },
    initResolutions: function() {
        var j = this, e, h, a, g, k = {}, f = true;
        if (j.resolutions && j.scales) {
            var h = j.resolutions.length;
            j.resolutions.sort(function(m, i) {
                return ( i - m)
            });
            if (!j.maxResolution) {
                j.maxResolution = j.resolutions[0]
            }
            if (!j.minResolution) {
                j.minResolution = j.resolutions[h - 1]
            }
            j.scales.sort(function(m, i) {
                return ( m - i)
            });
            if (!j.maxScale) {
                j.maxScale = j.scales[h - 1]
            }
            if (!j.minScale) {
                j.minScale = j.scales[0]
            }
            j.numZoomLevels = h;
            return
        }
        for (e = 0,
        h = j.RESOLUTION_PROPERTIES.length; e < h; e++) {
            a = j.RESOLUTION_PROPERTIES[e];
            k[a] = j.options[a];
            if (f && j.options[a]) {
                f = false
            }
        }
        if (j.alwaysInRange == null) {
            j.alwaysInRange = f
        }
        if (k.resolutions == null) {
            k.resolutions = j.resolutionsFromScales(k.scales)
        }
        if (k.resolutions == null) {
            k.resolutions = j.calculateResolutions(k)
        }
        if (j.map.resolutions && j.map.scales) {
            j.resolutions = j.map.resolutions;
            j.scales = j.map.scales;
            var h = j.resolutions.length;
            j.resolutions.sort(function(m, i) {
                return ( i - m)
            });
            if (!j.maxResolution) {
                j.maxResolution = j.resolutions[0]
            }
            if (!j.minResolution) {
                j.minResolution = j.resolutions[h - 1]
            }
            j.scales.sort(function(m, i) {
                return ( m - i)
            });
            if (!j.maxScale) {
                j.maxScale = j.scales[h - 1]
            }
            if (!j.minScale) {
                j.minScale = j.scales[0]
            }
            j.numZoomLevels = h;
            return
        }
        if (k.resolutions == null) {
            for (e = 0,
            h = j.RESOLUTION_PROPERTIES.length; e < h; e++) {
                a = j.RESOLUTION_PROPERTIES[e];
                k[a] = j.options[a] != null ? j.options[a] : j.map[a]
            }
            if (k.resolutions == null) {
                k.resolutions = j.resolutionsFromScales(k.scales)
            }
            if (k.resolutions == null) {
                if (j.map.baseLayer != null) {
                    k.resolutions = j.map.baseLayer.resolutions
                }
            }
            if (k.resolutions == null) {
                k.resolutions = j.calculateResolutions(k)
            }
        }
        var d;
        if (j.options.maxResolution && j.options.maxResolution !== "auto") {
            d = j.options.maxResolution
        }
        if (j.options.minScale) {
            d = SuperMap.Util.getResolutionFromScaleDpi(j.options.minScale, j.dpi, j.units, j.datumAxis)
        }
        var c;
        if (j.options.minResolution && j.options.minResolution !== "auto") {
            c = j.options.minResolution
        }
        if (j.options.maxScale) {
            c = SuperMap.Util.getResolutionFromScaleDpi(j.options.maxScale, j.dpi, j.units, j.datumAxis)
        }
        if (k.resolutions) {
            k.resolutions.sort(function(m, i) {
                return ( i - m)
            });
            if (!d) {
                d = k.resolutions[0]
            }
            if (!c) {
                var l = k.resolutions.length - 1;
                c = k.resolutions[l]
            }
        }
        j.resolutions = k.resolutions;
        if (j.resolutions) {
            h = j.resolutions.length;
            j.scales = [h];
            if (j.map.baseLayer) {
                g = this.calculateResolutionsLevel(j.resolutions)
            } else {
                g = 0
            }
            for (e = g; e < h + g; e++) {
                j.scales[e] = SuperMap.Util.getScaleFromResolutionDpi(j.resolutions[e - g], j.dpi, j.units, j.datumAxis)
            }
            j.numZoomLevels = h
        }
        j.minResolution = c;
        if (c) {
            j.maxScale = SuperMap.Util.getScaleFromResolutionDpi(c, j.dpi, j.units, j.datumAxis)
        }
        j.maxResolution = d;
        if (d) {
            j.minScale = SuperMap.Util.getScaleFromResolutionDpi(d, j.dpi, j.units, j.datumAxis)
        }
    },
    calculateResolutionsLevel: function(c) {
        var f = this, e, a, d, g;
        g = f.map.baseLayer.resolutions;
        a = g.length;
        d = c[0];
        for (e = 0; e < a; e++) {
            if (d == g[e]) {
                return e
            }
        }
        return 0
    },
    resolutionsFromScales: function(f) {
        if (f == null) {
            return
        }
        var e = this, c, a;
        a = f.length;
        c = [a];
        for (var d = 0; d < a; d++) {
            c[d] = SuperMap.Util.getResolutionFromScaleDpi(f[d], e.dpi, e.units, e.datumAxis)
        }
        return c
    },
    calculateResolutions: function(m) {
        var l = this
          , o = m.maxResolution;
        if (m.minScale != null) {
            o = SuperMap.Util.getResolutionFromScaleDpi(m.minScale, l.dpi, l.units, l.datumAxis)
        } else {
            if (o == "auto" && l.maxExtent != null) {
                var n, k, h;
                n = l.map.getSize();
                k = l.maxExtent.getWidth() / n.w;
                h = l.maxExtent.getHeight() / n.h;
                o = Math.max(k, h)
            }
        }
        var g = m.minResolution;
        if (m.maxScale != null) {
            g = SuperMap.Util.getResolutionFromScaleDpi(m.maxScale, l.dpi, l.units, l.datumAxis)
        } else {
            if (m.minResolution == "auto" && l.minExtent != null) {
                var n, k, h;
                n = l.map.getSize();
                k = l.minExtent.getWidth() / n.w;
                h = l.minExtent.getHeight() / n.h;
                g = Math.max(k, h)
            }
        }
        if (typeof o !== "number" && typeof g !== "number" && this.maxExtent != null) {
            var p = this.map.getTileSize();
            o = Math.max(this.maxExtent.getWidth() / p.w, this.maxExtent.getHeight() / p.h)
        }
        var a = m.maxZoomLevel;
        var c = m.numZoomLevels;
        if (typeof g === "number" && typeof o === "number" && c === undefined) {
            var j = o / g;
            c = Math.floor(Math.log(j) / Math.log(2)) + 1
        } else {
            if (c === undefined && a != null) {
                c = a + 1
            }
        }
        if (typeof c !== "number" || c <= 0 || (typeof o !== "number" && typeof g !== "number")) {
            return
        }
        var e = [c];
        var d = 2;
        if (typeof g == "number" && typeof o == "number") {
            d = Math.pow((o / g), (1 / (c - 1)))
        }
        if (typeof o === "number") {
            for (var f = 0; f < c; f++) {
                e[f] = o / Math.pow(d, f)
            }
        } else {
            for (f = 0; f < c; f++) {
                e[c - 1 - f] = g * Math.pow(d, f)
            }
        }
        return e
    },
    CLASS_NAME: "SuperMap.CanvasLayer"
});
SuperMap.Layer.TiledDynamicRESTLayer = SuperMap.Class(SuperMap.CanvasLayer, {
    DEFAULT_PARAMS: {
        transparent: false,
        cacheEnabled: true
    },
    prjStr1: null,
    getMapStatusService: null,
    viewBounds: null,
    viewer: null,
    scale: null,
    dpi: null,
    overlapDisplayed: true,
    redirect: false,
    overlapDisplayedOptions: null,
    initialize: function(c, d, e, k) {
        var i = this;
        SuperMap.CanvasLayer.prototype.initialize.apply(i, arguments);
        SuperMap.Util.applyDefaults(i.params, i.DEFAULT_PARAMS);
        i.events.addEventType("layerInitialized");
        if (i.params.transparent) {
            if (i.format === "jpg") {
                i.format = SuperMap.Util.alphaHack() ? "gif" : "png"
            }
            if (i.format === "bmp") {
                i.format = SuperMap.Util.alphaHack() ? "bmp" : "png"
            }
        }
        if (typeof i.params.clipRegion !== "undefined") {
            if (i.params.clipRegion instanceof SuperMap.Geometry) {
                i.params.clipRegionEnabled = true;
                var h = SuperMap.REST.ServerGeometry.fromGeometry(i.params.clipRegion);
                i.params.clipRegion = SuperMap.Util.toJSON(h)
            } else {
                delete i.params.clipRegion
            }
        }
        if (typeof i.params.layersID !== "undefined") {
            if (!i.params.layersID) {
                delete i.params.layersID
            }
        }
        if (i.params.redirect) {
            i.redirect = true
        }
        if (i.units) {
            i.units = i.units.toLowerCase()
        }
        if (i.dpi && i.maxExtent && (i.resolutions || i.scales)) {} else {
            if (!i.dpi && (!i.viewBounds || !i.viewer || !i.scale)) {
                if (!!SuperMap.isApp) {
                    var j = {
                        tile: i
                    };
                    cordova.exec(function(l) {
                        return function(m) {
                            l.tile.getAppStatusSucceed(l, m)
                        }
                    }(j), function(l) {}, "LocalStoragePlugin", "getconfig", [this.name, this.storageType])
                } else {
                    var f = i.url;
                    if (SuperMap.Util.isArray(d)) {
                        f = d[0]
                    }
                    var a = new SuperMap.REST.MapService(f,{
                        eventListeners: {
                            processCompleted: i.getStatusSucceed,
                            scope: i,
                            processFailed: i.getStatusFailed
                        },
                        projection: i.projection
                    });
                    a.processAsync()
                }
            }
        }
        if (i.projection) {
            if (typeof i.projection == "string") {
                i.projection = new SuperMap.Projection(i.projection)
            }
            var g = i.projection.getCode().split(":");
            if (g instanceof Array && g.length == 2) {
                i.prjStr1 = '{"epsgCode":' + g[1] + "}"
            }
        }
    },
    getAppStatusSucceed: function(layerContext, r) {
        var mapStatus = r.json;
        var me = this;
        if (mapStatus != "false") {
            mapStatus = eval("(" + mapStatus + ")");
            var bounds = mapStatus.bounds;
            bounds = new SuperMap.Bounds(bounds.left,bounds.bottom,bounds.right,bounds.top);
            me.maxExtent = bounds;
            if (mapStatus.dpi) {
                me.dpi = mapStatus.dpi;
                me.options.scales = mapStatus.scales;
                me.units = mapStatus.unit;
                me.datumAxis = 6378137
            } else {
                var viewBounds = mapStatus.viewBounds
                  , coordUnit = mapStatus.coordUnit
                  , viewer = mapStatus.viewer
                  , scale = mapStatus.scale
                  , datumAxis = mapStatus.datumAxis;
                viewBounds = new SuperMap.Bounds(viewBounds.left,viewBounds.bottom,viewBounds.right,viewBounds.top);
                me.viewBounds = viewBounds;
                viewer = new SuperMap.Size(viewer.rightBottom.x,viewer.rightBottom.y);
                me.viewer = viewer;
                me.scale = scale;
                coordUnit = coordUnit.toLowerCase();
                me.units = me.units || coordUnit;
                me.datumAxis = datumAxis;
                me.dpi = SuperMap.Util.calculateDpi(viewBounds, viewer, scale, me.units, datumAxis)
            }
            me.events.triggerEvent("layerInitialized", me)
        } else {
            var strServiceUrl = me.url;
            if (SuperMap.Util.isArray(me.url)) {
                strServiceUrl = me.url[0]
            }
            var getMapStatusService = new SuperMap.REST.MapService(strServiceUrl,{
                eventListeners: {
                    processCompleted: me.getStatusSucceed,
                    scope: me,
                    processFailed: me.getStatusFailed
                },
                projection: me.projection
            });
            getMapStatusService.processAsync()
        }
    },
    getStatusSucceed: function(g) {
        var e = this;
        if (g.result) {
            var g = g.result;
            var d = g.bounds
              , f = g.viewBounds
              , a = g.coordUnit
              , i = g.viewer
              , h = g.scale
              , c = g.datumAxis;
            f = new SuperMap.Bounds(f.left,f.bottom,f.right,f.top);
            e.viewBounds = f;
            i = new SuperMap.Size(i.rightBottom.x,i.rightBottom.y);
            e.viewer = i;
            e.scale = h;
            d = new SuperMap.Bounds(d.left,d.bottom,d.right,d.top);
            e.maxExtent = d;
            a = a.toLowerCase();
            e.units = e.units || a;
            e.datumAxis = c;
            e.dpi = SuperMap.Util.calculateDpi(f, i, h, e.units, c);
            if (!!SuperMap.isApp) {
                cordova.exec(function() {}, function(j) {}, "LocalStoragePlugin", "savaconfig", [this.name, g])
            }
            e.events.triggerEvent("layerInitialized", e)
        }
    },
    getStatusFailed: function(a) {},
    destroy: function() {
        var a = this;
        if (a.getMapStatusService) {
            a.getMapStatusService.events.listeners = null;
            a.getMapStatusService.destroy()
        }
        a.viewBounds = null;
        a.viewer = null;
        a.scale = null;
        SuperMap.CanvasLayer.prototype.destroy.apply(a, arguments);
        a.DEFAULT_PARAMS = null
    },
    clone: function(c) {
        var a = this;
        if (c == null) {
            c = new SuperMap.Layer.TiledDynamicRESTLayer(a.name,a.url,a.params,a.getOptions())
        }
        c = SuperMap.CanvasLayer.prototype.clone.apply(a, [c]);
        c._timeoutId = null;
        return c
    },
    getTileUrl: function(a) {
        var c = this, f, d = c.tileSize, e = c.scales[a.z];
        if (!e) {
            e = this.getScaleForZoom(a.z)
        }
        f = {
            width: d.w,
            height: d.h,
            x: a.x,
            y: a.y,
            scale: e,
            redirect: c.redirect
        };
        if (SuperMap.Credential.CREDENTIAL) {
            f.token = SuperMap.Credential.CREDENTIAL.getValue()
        }
        if (!c.params.cacheEnabled) {
            f.t = new Date().getTime()
        }
        if (typeof c.params.layersID !== "undefined" && typeof f.layersID == "undefined") {
            if (c.params.layersID && c.params.layersID.length > 0) {
                f.layersID = c.params.layersID
            }
        }
        if (c.prjStr1) {
            f.prjCoordSys = c.prjStr1
        }
        return c.getFullRequestString(f)
    },
    getFullRequestString: function(f, e) {
        var h = this, c = e || this.url, g, a, d;
        g = SuperMap.Util.extend({}, h.params),
        g = SuperMap.Util.extend(g, f);
        if (g.overlapDisplayed === false) {
            h.overlapDisplayedOptions = g.overlapDisplayedOptions;
            h.overlapDisplayed = g.overlapDisplayed;
            delete g.overlapDisplayed;
            delete g.overlapDisplayedOptions
        }
        a = SuperMap.Util.getParameterString(g);
        if (SuperMap.Util.isArray(c)) {
            var j = "" + f.x + f.y;
            c = h.selectUrl(j, c)
        }
        c = c + "/tileImage." + h.format;
        d = SuperMap.Util.upperCaseObject(SuperMap.Util.getParameters(c));
        for (var i in g) {
            if (i.toUpperCase()in d) {
                delete g[i]
            }
        }
        a = SuperMap.Util.getParameterString(g);
        if (h.tileOrigin) {
            a = a + '&origin={"x":' + h.tileOrigin.lon + ',"y":' + h.tileOrigin.lat + "}"
        }
        if (h.overlapDisplayed === false) {
            h.overlapDisplayedOptions = h.overlapDisplayedOptions ? h.overlapDisplayedOptions : new SuperMap.REST.OverlapDisplayedOptions();
            a += "&overlapDisplayed=false&overlapDisplayedOptions=" + h.overlapDisplayedOptions.toString()
        }
        return SuperMap.Util.urlAppend(c, a)
    },
    mergeNewParams: function(c) {
        if (typeof (c.clipRegion) != "undefined") {
            if (c.clipRegion instanceof SuperMap.Geometry) {
                c.clipRegionEnabled = true;
                var a = SuperMap.REST.ServerGeometry.fromGeometry(c.clipRegion);
                c.clipRegion = SuperMap.Util.toJSON(a)
            } else {
                delete c.clipRegion
            }
        }
        return SuperMap.Layer.HTTPRequest.prototype.mergeNewParams.apply(this, [c])
    },
    CLASS_NAME: "SuperMap.Layer.TiledDynamicRESTLayer"
});
SuperMap.Layer.SimpleCachedLayer = SuperMap.Class(SuperMap.CanvasLayer, {
    urlTemplate: "${layerName}_${w}x${h}/${scale}/${x}/${y}.${format}",
    layerName: null,
    initialize: function(e, d, c, a) {
        var f = this;
        f.layerName = c;
        SuperMap.CanvasLayer.prototype.initialize.apply(f, [e, d, {}, a])
    },
    clone: function(c) {
        var a = this;
        if (c == null) {
            c = new SuperMap.Layer.SimpleCachedLayer(a.name,a.url,a.layerName,a.getOptions())
        }
        c = SuperMap.CanvasLayer.prototype.clone.apply(a, [c]);
        return c
    },
    destroy: function() {
        var a = this;
        SuperMap.CanvasLayer.prototype.destroy.apply(a, arguments);
        a.layerName = null;
        a.urlTemplate = null
    },
    getTileUrl: function(g) {
        var f = this
          , i = f.tileSize
          , c = f.scales[g.z]
          , a = f.url
          , e = f.urlTemplate
          , d = f.layerName
          , h = f.format;
        if (SuperMap.Util.isArray(a)) {
            var j = "" + g.x + g.y + g.z + i.h + i.w + d + h;
            a = f.selectUrl(j, a)
        }
        a = (a.charAt(a.length - 1) == "/") ? a + e : a + "/" + e;
        return SuperMap.String.format(a, {
            x: g.x,
            y: g.y,
            scale: Math.round(1 / c),
            h: i.h,
            w: i.w,
            layerName: d,
            format: h
        })
    },
    CLASS_NAME: "SuperMap.Layer.SimpleCachedLayer"
});
SuperMap.Layer.CloudLayer = SuperMap.Class(SuperMap.CanvasLayer, {
    name: "CloudLayer",
    url: "http://t0.supermapcloud.com/FileService/image",
    mapName: "quanguo",
    type: "web",
    initialize: function(a) {
        var c = this;
        c.url = c.url + "?map=${mapName}&type=${type}&x=${x}&y=${y}&z=${z}";
        a = SuperMap.Util.extend({
            maxExtent: new SuperMap.Bounds(-20037508.3427892,-20037508.3427892,20037508.3427892,20037508.3427892),
            resolutions: [156605.46875, 78302.734375, 39151.3671875, 19575.68359375, 9787.841796875, 4893.9208984375, 2446.96044921875, 1223.48022460937, 611.740112304687, 305.870056152344, 152.935028076172, 76.4675140380859, 38.233757019043, 19.1168785095215, 9.55843925476074, 4.77921962738037, 2.38960981369019, 1.19480490684509, 0.597402453422546]
        }, a);
        SuperMap.CanvasLayer.prototype.initialize.apply(c, [c.name, c.url, null, a]);
        c.units = "meter"
    },
    destroy: function() {
        var a = this;
        SuperMap.CanvasLayer.prototype.destroy.apply(a, arguments);
        a.mapName = null;
        a.name = null;
        a.url = null
    },
    clone: function(c) {
        var a = this;
        if (c == null) {
            c = new SuperMap.Layer.CloudLayer(a.name,a.url,a.layerName,a.getOptions())
        }
        c = SuperMap.CanvasLayer.prototype.clone.apply(a, [c]);
        return c
    },
    getTileUrl: function(a) {
        var d = this
          , c = d.url;
        return SuperMap.String.format(c, {
            mapName: d.mapName,
            type: d.type,
            x: a.x,
            y: a.y,
            z: a.z
        })
    },
    CLASS_NAME: "SuperMap.Layer.CloudLayer"
});
SuperMap.Layer.Markers = SuperMap.Class(SuperMap.Layer, {
    isBaseLayer: false,
    markers: null,
    drawn: false,
    initialize: function(c, a) {
        SuperMap.Layer.prototype.initialize.apply(this, arguments);
        this.markers = []
    },
    destroy: function() {
        this.clearMarkers();
        this.markers = null;
        SuperMap.Layer.prototype.destroy.apply(this, arguments)
    },
    setOpacity: function(c) {
        if (c != this.opacity) {
            this.opacity = c;
            for (var d = 0, a = this.markers.length; d < a; d++) {
                this.markers[d].setOpacity(this.opacity)
            }
        }
    },
    moveTo: function(e, c, f) {
        SuperMap.Layer.prototype.moveTo.apply(this, arguments);
        if (c || !this.drawn) {
            for (var d = 0, a = this.markers.length; d < a; d++) {
                this.drawMarker(this.markers[d])
            }
            this.drawn = true
        }
    },
    addMarker: function(a) {
        this.markers.push(a);
        if (this.opacity != null) {
            a.setOpacity(this.opacity)
        }
        if (this.map && this.map.getExtent()) {
            a.map = this.map;
            this.drawMarker(a)
        }
    },
    removeMarker: function(a) {
        if (this.markers && this.markers.length) {
            SuperMap.Util.removeItem(this.markers, a);
            a.erase()
        }
    },
    clearMarkers: function() {
        if (this.markers != null) {
            while (this.markers.length > 0) {
                this.removeMarker(this.markers[0])
            }
        }
    },
    drawMarker: function(a) {
        var c = this.map.getLayerPxFromLonLat(a.lonlat);
        if (c == null) {
            a.display(false)
        } else {
            if (!a.isDrawn()) {
                var d = a.draw(c);
                this.div.appendChild(d)
            } else {
                if (a.icon) {
                    a.icon.moveTo(c)
                }
            }
        }
    },
    getDataExtent: function() {
        var c = null;
        if (this.markers && (this.markers.length > 0)) {
            var c = new SuperMap.Bounds();
            for (var e = 0, a = this.markers.length; e < a; e++) {
                var d = this.markers[e];
                c.extend(d.lonlat)
            }
        }
        return c
    },
    CLASS_NAME: "SuperMap.Layer.Markers"
});
SuperMap.Layer.WMS = SuperMap.Class(SuperMap.Layer.Grid, {
    DEFAULT_PARAMS: {
        service: "WMS",
        version: "1.1.1",
        request: "GetMap",
        styles: "",
        format: "image/png"
    },
    reproject: false,
    isBaseLayer: true,
    encodeBBOX: false,
    noMagic: false,
    yx: {
        "EPSG:4326": true
    },
    initialize: function(e, d, f, c) {
        var a = [];
        f = SuperMap.Util.upperCaseObject(f);
        if (parseFloat(f.VERSION) >= 1.3 && !f.EXCEPTIONS) {
            f.EXCEPTIONS = "INIMAGE"
        }
        a.push(e, d, f, c);
        SuperMap.Layer.Grid.prototype.initialize.apply(this, a);
        SuperMap.Util.applyDefaults(this.params, SuperMap.Util.upperCaseObject(this.DEFAULT_PARAMS));
        if (!this.noMagic && this.params.TRANSPARENT && this.params.TRANSPARENT.toString().toLowerCase() == "true") {
            if ((c == null) || (!c.isBaseLayer)) {
                this.isBaseLayer = false
            }
            if (this.params.FORMAT == "image/jpeg") {
                this.params.FORMAT = SuperMap.Util.alphaHack() ? "image/gif" : "image/png"
            }
        }
    },
    destroy: function() {
        SuperMap.Layer.Grid.prototype.destroy.apply(this, arguments)
    },
    clone: function(a) {
        if (a == null) {
            a = new SuperMap.Layer.WMS(this.name,this.url,this.params,this.getOptions())
        }
        a = SuperMap.Layer.Grid.prototype.clone.apply(this, [a]);
        return a
    },
    reverseAxisOrder: function() {
        var a = this.projection.getCode();
        return parseFloat(this.params.VERSION) >= 1.3 && !!(this.yx[a] || SuperMap.Projection.defaults[a].yx)
    },
    getURL: function(d) {
        d = this.adjustBounds(d);
        var e = this.getImageSize();
        var f = {};
        var c = this.reverseAxisOrder();
        f.BBOX = this.encodeBBOX ? d.toBBOX(null, c) : d.toArray(c);
        f.WIDTH = e.w;
        f.HEIGHT = e.h;
        if (SuperMap.Credential.CREDENTIAL) {
            f.token = SuperMap.Credential.CREDENTIAL.getValue()
        }
        var a = this.getFullRequestString(f);
        return a
    },
    mergeNewParams: function(d) {
        var c = SuperMap.Util.upperCaseObject(d);
        var a = [c];
        return SuperMap.Layer.Grid.prototype.mergeNewParams.apply(this, a)
    },
    getFullRequestString: function(f, d) {
        var c = this.map.getProjectionObject();
        var a = this.projection && this.projection.equals(c) ? this.projection.getCode() : c.getCode();
        var e = (a == "none") ? null : a;
        if (parseFloat(this.params.VERSION) >= 1.3) {
            this.params.CRS = e
        } else {
            this.params.SRS = e
        }
        if (typeof this.params.TRANSPARENT == "boolean") {
            f.TRANSPARENT = this.params.TRANSPARENT ? "TRUE" : "FALSE"
        }
        return SuperMap.Layer.Grid.prototype.getFullRequestString.apply(this, arguments)
    },
    CLASS_NAME: "SuperMap.Layer.WMS"
});
SuperMap.Layer.WMTS = SuperMap.Class(SuperMap.Layer.Grid, {
    isBaseLayer: true,
    version: "1.0.0",
    requestEncoding: "KVP",
    url: null,
    layer: null,
    matrixSet: null,
    style: null,
    format: "image/png",
    tileOrigin: null,
    tileFullExtent: null,
    formatSuffix: null,
    matrixIds: null,
    dimensions: null,
    params: null,
    zoomOffset: 0,
    formatSuffixMap: {
        "image/png": "png",
        "image/png8": "png",
        "image/png24": "png",
        "image/png32": "png",
        png: "png",
        "image/jpeg": "jpg",
        "image/jpg": "jpg",
        jpeg: "jpg",
        jpg: "jpg"
    },
    matrix: null,
    initialize: function(d) {
        var g = {
            url: true,
            layer: true,
            style: true,
            matrixSet: true
        };
        for (var h in g) {
            if (!(h in d)) {
                throw new Error("Missing property '" + h + "' in layer configuration.")
            }
        }
        d.params = SuperMap.Util.upperCaseObject(d.params);
        var c = [d.name, d.url, d.params, d];
        SuperMap.Layer.Grid.prototype.initialize.apply(this, c);
        if (!this.formatSuffix) {
            this.formatSuffix = this.formatSuffixMap[this.format] || this.format.split("/").pop()
        }
        if (this.matrixIds) {
            var a = this.matrixIds.length;
            if (a && typeof this.matrixIds[0] === "string") {
                var f = this.matrixIds;
                this.matrixIds = new Array(a);
                for (var e = 0; e < a; ++e) {
                    this.matrixIds[e] = {
                        identifier: f[e]
                    }
                }
            }
        }
    },
    setMap: function() {
        SuperMap.Layer.Grid.prototype.setMap.apply(this, arguments);
        this.updateMatrixProperties()
    },
    updateMatrixProperties: function() {
        this.matrix = this.getMatrix();
        if (this.matrix) {
            if (this.matrix.topLeftCorner) {
                this.tileOrigin = this.matrix.topLeftCorner
            }
            if (this.matrix.tileWidth && this.matrix.tileHeight) {
                this.tileSize = new SuperMap.Size(this.matrix.tileWidth,this.matrix.tileHeight)
            }
            if (!this.tileOrigin) {
                this.tileOrigin = new SuperMap.LonLat(this.maxExtent.left,this.maxExtent.top)
            }
            if (!this.tileFullExtent) {
                this.tileFullExtent = this.maxExtent
            }
        }
    },
    moveTo: function(c, a, d) {
        if (a || !this.matrix) {
            this.updateMatrixProperties()
        }
        return SuperMap.Layer.Grid.prototype.moveTo.apply(this, arguments)
    },
    clone: function(a) {
        if (a == null) {
            a = new SuperMap.Layer.WMTS(this.options)
        }
        a = SuperMap.Layer.Grid.prototype.clone.apply(this, [a]);
        return a
    },
    getMatrix: function() {
        var c;
        if (!this.matrixIds || this.matrixIds.length === 0) {
            c = {
                identifier: this.map.getZoom() + this.zoomOffset
            }
        } else {
            if ("scaleDenominator"in this.matrixIds[0]) {
                var a = SuperMap.METERS_PER_INCH * SuperMap.INCHES_PER_UNIT[this.units] * this.map.getResolution() / 0.00028;
                var f = Number.POSITIVE_INFINITY;
                var g;
                for (var d = 0, e = this.matrixIds.length; d < e; ++d) {
                    g = Math.abs(1 - (this.matrixIds[d].scaleDenominator / a));
                    if (g < f) {
                        f = g;
                        c = this.matrixIds[d]
                    }
                }
            } else {
                c = this.matrixIds[this.map.getZoom() + this.zoomOffset]
            }
        }
        return c
    },
    getTileInfo: function(g) {
        var c = this.map.getResolution();
        var e = (g.lon - this.tileOrigin.lon) / (c * this.tileSize.w);
        var d = (this.tileOrigin.lat - g.lat) / (c * this.tileSize.h);
        var a = Math.floor(e);
        var f = Math.floor(d);
        return {
            col: a,
            row: f,
            i: Math.floor((e - a) * this.tileSize.w),
            j: Math.floor((d - f) * this.tileSize.h)
        }
    },
    getURL: function(e) {
        e = this.adjustBounds(e);
        var c = "";
        if (!this.tileFullExtent || this.tileFullExtent.intersectsBounds(e)) {
            var a = e.getCenterLonLat();
            var g = this.getTileInfo(a);
            var j = this.matrix.identifier;
            if (this.requestEncoding.toUpperCase() === "REST") {
                var f = this.layer + "/" + this.style + "/";
                if (this.dimensions) {
                    for (var d = 0; d < this.dimensions.length; d++) {
                        if (this.params[this.dimensions[d]]) {
                            f = f + this.params[this.dimensions[d]] + "/"
                        }
                    }
                }
                f = f + this.matrixSet + "/" + this.matrix.identifier + "/" + g.row + "/" + g.col + "." + this.formatSuffix;
                if (SuperMap.Util.isArray(this.url)) {
                    c = this.selectUrl(f, this.url)
                } else {
                    c = this.url
                }
                if (!c.match(/\/$/)) {
                    c = c + "/"
                }
                c = c + f
            } else {
                if (this.requestEncoding.toUpperCase() === "KVP") {
                    var h = {
                        SERVICE: "WMTS",
                        REQUEST: "GetTile",
                        VERSION: this.version,
                        LAYER: this.layer,
                        STYLE: this.style,
                        TILEMATRIXSET: this.matrixSet,
                        TILEMATRIX: this.matrix.identifier,
                        TILEROW: g.row,
                        TILECOL: g.col,
                        FORMAT: this.format
                    };
                    if (SuperMap.Credential.CREDENTIAL) {
                        h.token = SuperMap.Credential.CREDENTIAL.getValue()
                    }
                    c = SuperMap.Layer.Grid.prototype.getFullRequestString.apply(this, [h])
                }
            }
        }
        return c
    },
    mergeNewParams: function(a) {
        if (this.requestEncoding.toUpperCase() === "KVP") {
            return SuperMap.Layer.Grid.prototype.mergeNewParams.apply(this, [SuperMap.Util.upperCaseObject(a)])
        }
    },
    CLASS_NAME: "SuperMap.Layer.WMTS"
});
SuperMap.Layer.HeatMapLayer = SuperMap.Class(SuperMap.Layer, {
    radius: 50,
    features: null,
    maxWeight: null,
    featureWeight: null,
    featureRadius: null,
    EVENT_TYPES: ["featuresadded", "featuresremoved", "featuresdrawcompleted"],
    supported: false,
    rootCanvas: null,
    canvasContext: null,
    pixelHeatPoints: null,
    alphaValues: null,
    colorValues: null,
    canvasData: null,
    tempMaxValue: null,
    maxWidth: null,
    maxHeight: null,
    initialize: function(c, a) {
        this.EVENT_TYPES = SuperMap.Layer.HeatMapLayer.prototype.EVENT_TYPES.concat(SuperMap.Layer.prototype.EVENT_TYPES);
        SuperMap.Layer.prototype.initialize.apply(this, arguments);
        this.rootCanvas = document.createElement("canvas");
        if (!this.rootCanvas.getContext) {
            return
        }
        this.supported = true;
        this.rootCanvas.id = "Canvas_" + this.id;
        this.rootCanvas.style.position = "absolute";
        this.div.appendChild(this.rootCanvas);
        this.canvasContext = this.rootCanvas.getContext("2d")
    },
    addFeatures: function(a) {
        if (!(SuperMap.Util.isArray(a))) {
            a = [a]
        }
        this.features = this.features || [];
        if (0 == this.features.length) {
            this.features = a
        } else {
            this.features.concat(a)
        }
        this.events.triggerEvent("featuresadded", {
            features: a,
            succeed: true
        });
        this.refresh()
    },
    removeFeatures: function(f) {
        if (!f || f.length === 0 || !this.features || this.features.length === 0) {
            return
        }
        if (f === this.features) {
            return this.removeAllFeatures()
        }
        if (!(SuperMap.Util.isArray(f))) {
            f = [f]
        }
        var d, c, h = [];
        for (var e = 0, a = f.length; e < a; e++) {
            d = f[e];
            c = SuperMap.Util.indexOf(this.features, d);
            if (c === -1) {
                h.push(d);
                continue
            }
            this.features.splice(c, 1)
        }
        var g = h.length == 0 ? true : false;
        this.refresh();
        this.events.triggerEvent("featuresremoved", {
            features: h,
            succeed: g
        })
    },
    removeAllFeatures: function() {
        if (this.features && this.features.length > 0) {
            for (var c = 0, a = this.features.length; c < a; c++) {
                this.features[c].destroy();
                this.features[c] = null
            }
        }
        this.features = [];
        this.refresh()
    },
    refresh: function() {
        if (this.map) {
            var a = this.map.getExtent();
            this.updateHeatPoints(a)
        }
    },
    destroy: function() {
        if (this.features && this.features.length > 0) {
            for (var c = 0, a = this.features.length; c < a; c++) {
                this.features[c].destroy();
                this.features[c] = null
            }
        }
        this.features = null;
        this.radius = null;
        this.supported = null;
        this.canvasContext = null;
        this.pixelHeatPoints = null;
        this.rootCanvas = null;
        this.alphaValues = null;
        this.colorValues = null;
        this.canvasData = null;
        this.maxWeight = null;
        this.maxWidth = null;
        this.maxHeight = null;
        SuperMap.Layer.prototype.destroy.apply(this, arguments)
    },
    setMap: function(a) {
        SuperMap.Layer.prototype.setMap.apply(this, arguments);
        if (!this.supported) {
            this.map.removeLayer(this)
        } else {
            this.redraw()
        }
    },
    moveTo: function(d, a, e) {
        SuperMap.Layer.prototype.moveTo.apply(this, arguments);
        if (!this.supported) {
            return
        }
        this.zoomChanged = a;
        if (!e) {
            this.div.style.visibility = "hidden";
            this.div.style.left = -parseInt(this.map.layerContainerDiv.style.left) + "px";
            this.div.style.top = -parseInt(this.map.layerContainerDiv.style.top) + "px";
            var c = this.map.getSize();
            this.rootCanvas.width = parseInt(c.w);
            this.rootCanvas.height = parseInt(c.h);
            this.maxWidth = c.w;
            this.maxHeight = c.h;
            this.div.style.visibility = "visible";
            if (!a) {
                this.updateHeatPoints(d)
            }
        }
        if (a) {
            this.updateHeatPoints(d)
        }
    },
    updateHeatPoints: function(a) {
        this.pixelHeatPoints = [];
        if (this.features && this.features.length > 0) {
            this.convertToPixelPoints(a);
            this.drawHeatPoints(a)
        } else {
            this.canvasContext.clearRect(0, 0, this.maxWidth, this.maxWidth)
        }
    },
    convertToPixelPoints: function(h) {
        var k = -1
          , c = this.map.getResolution();
        for (var d = this.features.length - 1; d >= 0; d--) {
            var j = this.features[d];
            var a = j.geometry;
            if (h.contains(a.x, a.y)) {
                var e = this.getPixelXY(a.x, a.y, h, c);
                e.weight = j.attributes[this.featureWeight];
                var g = this.featureRadius && j.attributes[this.featureRadius] ? j.attributes[this.featureRadius] : null;
                e.geoRadius = g ? parseInt(g / c) : g;
                this.pixelHeatPoints.push(e);
                k = Math.max(k, e.weight)
            }
        }
        this.tempValue = this.maxWeight ? this.maxWeight : k
    },
    drawHeatPoints: function(d) {
        this.canvasData = this.canvasContext.createImageData(this.maxWidth, this.maxHeight);
        this.alphaValues = [];
        this.colorValues = [];
        var e = [0, 0, 0, 0], c, a;
        for (c = this.maxWidth - 1; c >= 0; c--) {
            this.alphaValues.push(new Array(this.maxHeight));
            this.colorValues.push(new Array(this.maxHeight))
        }
        for (c = this.pixelHeatPoints.length - 1; c >= 0; c--) {
            this.showPoint(this.pixelHeatPoints[c].x, this.pixelHeatPoints[c].y, this.pixelHeatPoints[c].weight, this.pixelHeatPoints[c].geoRadius)
        }
        this.canvasContext.clearRect(0, 0, this.maxWidth, this.maxHeight);
        this.canvasContext.putImageData(this.canvasData, 0, 0);
        this.events.triggerEvent("featuresdrawcompleted")
    },
    showPoint: function(l, h, m, g) {
        if (0 == m) {
            return
        }
        var d = m / this.tempValue, c = 3 + parseInt(this.radius * d), a, n, k;
        if (g || 0 == g) {
            c = g
        }
        for (var f = 0; f < c; f++) {
            for (var e = 0; e <= c; e++) {
                if (f && e) {
                    a = 1 - Math.sqrt(f * f + e * e) / c;
                    if (a <= 0) {
                        n = 0;
                        k = 0
                    } else {
                        k = a * d;
                        n = a * a * (0.1 + 0.9 * d)
                    }
                    if (k <= 0) {
                        break
                    }
                    this.setPixelColor(l - f, h - e, n, k);
                    this.setPixelColor(l - f, h + e, n, k);
                    this.setPixelColor(l + f, h - e, n, k);
                    this.setPixelColor(l + f, h + e, n, k)
                } else {
                    if (!e) {
                        a = 1 - f / c;
                        k = a * d;
                        n = a * a * (0.1 + 0.9 * d);
                        if (0 != f) {
                            this.setPixelColor(l + f, h, n, k);
                            this.setPixelColor(l - f, h, n, k)
                        } else {
                            this.setPixelColor(l, h, n, k)
                        }
                    } else {
                        if (!f) {
                            a = 1 - e / c;
                            k = a * d;
                            n = a * a * (0.1 + 0.9 * d);
                            this.setPixelColor(l, h - e, n, k);
                            this.setPixelColor(l, h + e, n, k)
                        }
                    }
                }
            }
        }
    },
    setPixelColor: function(i, g, j, h) {
        if (i >= 0 && i < this.maxWidth && g >= 0 && g < this.maxHeight) {
            var a = this.alphaValues[i][g]
              , c = this.colorValues[i][g]
              , f = g * this.maxWidth * 4 + i * 4
              , d = this.canvasData;
            if (a) {
                a = a + j - j * a;
                c = c + h - h * c
            } else {
                a = j;
                c = h
            }
            this.alphaValues[i][g] = a;
            this.colorValues[i][g] = c;
            var e = this.convertWeightToColor(c * c * c);
            d.data[f] = e.red;
            d.data[f + 1] = e.gre;
            d.data[f + 2] = 0;
            d.data[f + 3] = a * 255
        }
    },
    convertWeightToColor: function(c) {
        var d, a;
        if (c < 0.65) {
            a = 240;
            d = 370 * c
        } else {
            d = 240;
            a = 50 + (636 - 636 * c)
        }
        return {
            red: d,
            gre: a
        }
    },
    getPixelXY: function(a, e, d, c) {
        var a = (a / c + (-d.left / c));
        var e = ((d.top / c) - e / c);
        return {
            x: parseInt(a),
            y: parseInt(e)
        }
    },
    CLASS_NAME: "SuperMap.Layer.HeatMapLayer"
});
SuperMap.Layer.Image = SuperMap.Class(SuperMap.Layer, {
    isBaseLayer: true,
    url: null,
    useCanvas: true,
    extent: null,
    changeDx: 0,
    changeDy: 0,
    memoryImg: null,
    tile: null,
    initialize: function(d, c, e, a) {
        var f = SuperMap.Browser;
        this.url = c;
        this.extent = e;
        this.maxExtent = e;
        SuperMap.Layer.prototype.initialize.apply(this, [d, a]);
        if (this.useCanvas) {
            this.useCanvas = SuperMap.Util.supportCanvas()
        }
        if (f.device === "android") {
            this.useCanvas = false
        }
        if (this.useCanvas) {
            this.canvas = document.createElement("canvas");
            this.canvas.id = "Canvas_" + this.id;
            this.canvas.style.position = "absolute";
            this.div.appendChild(this.canvas);
            this.canvasContext = this.canvas.getContext("2d")
        }
    },
    destroy: function() {
        if (this.tile) {
            this.removeTileMonitoringHooks(this.tile);
            this.tile.destroy();
            this.tile = null
        }
        this.url = null;
        this.useCanvas = true;
        this.memoryImg = null;
        this.isBaseLayer = true;
        this.extent = null;
        SuperMap.Layer.prototype.destroy.apply(this, arguments)
    },
    clone: function(a) {
        if (a == null) {
            a = new SuperMap.Layer.Image(this.name,this.url,this.extent,this.getOptions())
        }
        a = SuperMap.Layer.prototype.clone.apply(this, [a]);
        return a
    },
    moveTo: function(f, a, g) {
        var e = this.map.layerContainerDiv.style
          , i = parseInt(e.left)
          , h = parseInt(e.top);
        this.changeDx = -i;
        this.changeDy = -h;
        SuperMap.Layer.prototype.moveTo.apply(this, arguments);
        var c = (this.tile == null);
        if (a || c) {
            this.setTileSize();
            var d = this.map.getLayerPxFromLonLat({
                lon: this.extent.left,
                lat: this.extent.top
            });
            if (c) {
                if (this.useCanvas) {
                    this.tile = new SuperMap.Tile.CanvasImage(this,d,this.extent,null,this.tileSize,this.useCanvas);
                    this.addTileMonitoringHooks(this.tile)
                } else {
                    this.tile = new SuperMap.Tile.Image(this,d,this.extent,null,this.tileSize);
                    this.addTileMonitoringHooks(this.tile)
                }
            } else {
                this.tile.size = this.tileSize.clone();
                if (this.useCanvas) {
                    this.tile.position = new SuperMap.Pixel(d.x - this.changeDx,d.y - this.changeDy)
                } else {
                    this.tile.position = d.clone()
                }
            }
            this.tile.draw();
            this.tile.position = d.clone();
            if (!this.useCanvas) {
                this.tile.frame.style.display = "";
                this.tile.imgDiv.style.opacity = 1
            }
        } else {
            if (this.useCanvas) {
                this.fixPosition()
            }
        }
    },
    fixPosition: function() {
        var d = this.tile.position.x - this.changeDx;
        var c = this.tile.position.y - this.changeDy;
        var a = new SuperMap.Pixel(d,c);
        this.drawCanvasTile(this.tile.lastImage, a)
    },
    moveByPx: function(c, a) {
        if (this.useCanvas) {
            this.changeDx += c;
            this.changeDy += a;
            this.fixPosition()
        }
    },
    drawCanvasTile: function(c, a) {
        this.canvas.width = this.map.viewPortDiv.clientWidth;
        this.canvas.height = this.map.viewPortDiv.clientHeight;
        this.canvasContext.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.canvasContext.drawImage(c, a.x, a.y, this.tile.size.w, this.tile.size.h)
    },
    getMemoryImg: function(a) {
        return this.memoryImg
    },
    addMemoryImg: function(a, c) {
        this.memoryImg = c
    },
    getXYZ: function(a) {
        return {
            x: 0,
            y: 0,
            z: 0
        }
    },
    setTileSize: function() {
        var c = this.extent.getWidth() / this.map.getResolution();
        var a = this.extent.getHeight() / this.map.getResolution();
        this.tileSize = new SuperMap.Size(c,a)
    },
    addTileMonitoringHooks: function(a) {
        a.onLoadStart = function() {
            this.events.triggerEvent("loadstart")
        }
        ;
        a.events.register("loadstart", this, a.onLoadStart);
        a.onLoadEnd = function() {
            this.events.triggerEvent("loadend")
        }
        ;
        a.events.register("loadend", this, a.onLoadEnd);
        a.events.register("unload", this, a.onLoadEnd)
    },
    removeTileMonitoringHooks: function(a) {
        a.unload();
        a.events.un({
            loadstart: a.onLoadStart,
            loadend: a.onLoadEnd,
            unload: a.onLoadEnd,
            scope: this
        })
    },
    getURL: function() {
        return this.url
    },
    initResolutions: function() {
        var j = this, e, h, a, g, k = {}, f = true;
        if (j.resolutions && j.scales) {
            var h = j.resolutions.length;
            j.resolutions.sort(function(m, i) {
                return ( i - m)
            });
            if (!j.maxResolution) {
                j.maxResolution = j.resolutions[0]
            }
            if (!j.minResolution) {
                j.minResolution = j.resolutions[h - 1]
            }
            j.scales.sort(function(m, i) {
                return ( m - i)
            });
            if (!j.maxScale) {
                j.maxScale = j.scales[h - 1]
            }
            if (!j.minScale) {
                j.minScale = j.scales[0]
            }
            j.numZoomLevels = h;
            return
        }
        for (e = 0,
        h = j.RESOLUTION_PROPERTIES.length; e < h; e++) {
            a = j.RESOLUTION_PROPERTIES[e];
            k[a] = j.options[a];
            if (f && j.options[a]) {
                f = false
            }
        }
        if (j.alwaysInRange == null) {
            j.alwaysInRange = f
        }
        if (k.resolutions == null) {
            k.resolutions = j.resolutionsFromScales(k.scales)
        }
        if (k.resolutions == null) {
            k.resolutions = j.calculateResolutions(k)
        }
        if (j.map.resolutions && j.map.scales) {
            j.resolutions = j.map.resolutions;
            j.scales = j.map.scales;
            var h = j.resolutions.length;
            j.resolutions.sort(function(m, i) {
                return ( i - m)
            });
            if (!j.maxResolution) {
                j.maxResolution = j.resolutions[0]
            }
            if (!j.minResolution) {
                j.minResolution = j.resolutions[h - 1]
            }
            j.scales.sort(function(m, i) {
                return ( m - i)
            });
            if (!j.maxScale) {
                j.maxScale = j.scales[h - 1]
            }
            if (!j.minScale) {
                j.minScale = j.scales[0]
            }
            j.numZoomLevels = h;
            return
        }
        if (k.resolutions == null) {
            for (e = 0,
            h = j.RESOLUTION_PROPERTIES.length; e < h; e++) {
                a = j.RESOLUTION_PROPERTIES[e];
                k[a] = j.options[a] != null ? j.options[a] : j.map[a]
            }
            if (k.resolutions == null) {
                k.resolutions = j.resolutionsFromScales(k.scales)
            }
            if (k.resolutions == null) {
                if (j.map.baseLayer != null) {
                    k.resolutions = j.map.baseLayer.resolutions
                }
            }
            if (k.resolutions == null) {
                k.resolutions = j.calculateResolutions(k)
            }
        }
        var d;
        if (j.options.maxResolution && j.options.maxResolution !== "auto") {
            d = j.options.maxResolution
        }
        if (j.options.minScale) {
            d = SuperMap.Util.getResolutionFromScaleDpi(j.options.minScale, j.dpi, j.units, j.datumAxis)
        }
        var c;
        if (j.options.minResolution && j.options.minResolution !== "auto") {
            c = j.options.minResolution
        }
        if (j.options.maxScale) {
            c = SuperMap.Util.getResolutionFromScaleDpi(j.options.maxScale, j.dpi, j.units, j.datumAxis)
        }
        if (k.resolutions) {
            k.resolutions.sort(function(m, i) {
                return ( i - m)
            });
            if (!d) {
                d = k.resolutions[0]
            }
            if (!c) {
                var l = k.resolutions.length - 1;
                c = k.resolutions[l]
            }
        }
        j.resolutions = k.resolutions;
        if (j.resolutions) {
            h = j.resolutions.length;
            j.scales = [h];
            if (j.map.baseLayer) {
                g = this.calculateResolutionsLevel(j.resolutions)
            } else {
                g = 0
            }
            for (e = g; e < h + g; e++) {
                j.scales[e] = SuperMap.Util.getScaleFromResolutionDpi(j.resolutions[e - g], j.dpi, j.units, j.datumAxis)
            }
            j.numZoomLevels = h
        }
        j.minResolution = c;
        if (c) {
            j.maxScale = SuperMap.Util.getScaleFromResolutionDpi(c, j.dpi, j.units, j.datumAxis)
        }
        j.maxResolution = d;
        if (d) {
            j.minScale = SuperMap.Util.getScaleFromResolutionDpi(d, j.dpi, j.units, j.datumAxis)
        }
    },
    calculateResolutionsLevel: function(c) {
        var f = this, e, a, d, g;
        g = f.map.baseLayer.resolutions;
        a = g.length;
        d = c[0];
        for (e = 0; e < a; e++) {
            if (d == g[e]) {
                return e
            }
        }
        return 0
    },
    CLASS_NAME: "SuperMap.Layer.Image"
});
SuperMap.Feature = SuperMap.Class({
    layer: null,
    id: null,
    lonlat: null,
    data: null,
    marker: null,
    popupClass: null,
    popup: null,
    initialize: function(a, d, c) {
        this.layer = a;
        this.lonlat = d;
        this.data = (c != null) ? c : {};
        this.id = SuperMap.Util.createUniqueID(this.CLASS_NAME + "_")
    },
    destroy: function() {
        if ((this.layer != null) && (this.layer.map != null)) {
            if (this.popup != null) {
                this.layer.map.removePopup(this.popup)
            }
        }
        if (this.layer != null && this.marker != null) {
            this.layer.removeMarker(this.marker)
        }
        this.layer = null;
        this.id = null;
        this.lonlat = null;
        this.data = null;
        if (this.marker != null) {
            this.destroyMarker(this.marker);
            this.marker = null
        }
        if (this.popup != null) {
            this.destroyPopup(this.popup);
            this.popup = null
        }
    },
    onScreen: function() {
        var c = false;
        if ((this.layer != null) && (this.layer.map != null)) {
            var a = this.layer.map.getExtent();
            c = a.containsLonLat(this.lonlat)
        }
        return c
    },
    createMarker: function() {
        if (this.lonlat != null) {
            this.marker = new SuperMap.Marker(this.lonlat,this.data.icon)
        }
        return this.marker
    },
    destroyMarker: function() {
        this.marker.destroy()
    },
    createPopup: function(c) {
        if (this.lonlat != null) {
            if (!this.popup) {
                var a = (this.marker) ? this.marker.icon : null;
                var d = this.popupClass ? this.popupClass : SuperMap.Popup.AnchoredBubble;
                this.popup = new d(this.id + "_popup",this.lonlat,this.data.popupSize,this.data.popupContentHTML,a,c)
            }
            if (this.data.overflow != null) {
                this.popup.contentDiv.style.overflow = this.data.overflow
            }
            this.popup.feature = this
        }
        return this.popup
    },
    destroyPopup: function() {
        if (this.popup) {
            this.popup.feature = null;
            this.popup.destroy();
            this.popup = null
        }
    },
    CLASS_NAME: "SuperMap.Feature"
});
SuperMap.State = {
    UNKNOWN: "Unknown",
    INSERT: "Insert",
    UPDATE: "Update",
    DELETE: "Delete"
};
SuperMap.Feature.Vector = SuperMap.Class(SuperMap.Feature, {
    fid: null,
    geometry: null,
    attributes: null,
    bounds: null,
    state: null,
    style: null,
    url: null,
    renderIntent: "default",
    modified: null,
    initialize: function(d, a, c) {
        SuperMap.Feature.prototype.initialize.apply(this, [null, null, a]);
        this.lonlat = null;
        this.geometry = d ? d : null;
        this.state = null;
        this.attributes = {};
        if (a) {
            this.attributes = SuperMap.Util.extend(this.attributes, a)
        }
        this.style = c ? c : null
    },
    destroy: function() {
        if (this.layer) {
            this.layer.removeFeatures(this);
            this.layer = null
        }
        this.geometry = null;
        this.modified = null;
        SuperMap.Feature.prototype.destroy.apply(this, arguments)
    },
    clone: function() {
        return new SuperMap.Feature.Vector(this.geometry ? this.geometry.clone() : null,this.attributes,this.style)
    },
    onScreen: function(e) {
        var d = false;
        if (this.layer && this.layer.map) {
            var a = this.layer.map.getExtent();
            if (e) {
                var c = this.geometry.getBounds();
                d = a.intersectsBounds(c)
            } else {
                var f = a.toGeometry();
                d = f.intersects(this.geometry)
            }
        }
        return d
    },
    getVisibility: function() {
        return !(this.style && this.style.display == "none" || !this.layer || this.layer && this.layer.styleMap && this.layer.styleMap.createSymbolizer(this, this.renderIntent).display == "none" || this.layer && !this.layer.getVisibility())
    },
    createMarker: function() {
        return null
    },
    destroyMarker: function() {},
    createPopup: function() {
        return null
    },
    atPoint: function(c, e, d) {
        var a = false;
        if (this.geometry) {
            a = this.geometry.atPoint(c, e, d)
        }
        return a
    },
    destroyPopup: function() {},
    move: function(a) {
        if (!this.layer || !this.geometry.move) {
            return undefined
        }
        var c;
        if (a.CLASS_NAME == "SuperMap.LonLat") {
            c = this.layer.getViewPortPxFromLonLat(a)
        } else {
            c = a
        }
        var e = this.layer.getViewPortPxFromLonLat(this.geometry.getBounds().getCenterLonLat());
        var d = this.layer.map.getResolution();
        this.geometry.move(d * (c.x - e.x), d * (e.y - c.y));
        this.layer.drawFeature(this);
        return e
    },
    toState: function(a) {
        if (a == SuperMap.State.UPDATE) {
            switch (this.state) {
            case SuperMap.State.UNKNOWN:
            case SuperMap.State.DELETE:
                this.state = a;
                break;
            case SuperMap.State.UPDATE:
            case SuperMap.State.INSERT:
                break
            }
        } else {
            if (a == SuperMap.State.INSERT) {
                switch (this.state) {
                case SuperMap.State.UNKNOWN:
                    break;
                default:
                    this.state = a;
                    break
                }
            } else {
                if (a == SuperMap.State.DELETE) {
                    switch (this.state) {
                    case SuperMap.State.INSERT:
                        break;
                    case SuperMap.State.DELETE:
                        break;
                    case SuperMap.State.UNKNOWN:
                    case SuperMap.State.UPDATE:
                        this.state = a;
                        break
                    }
                } else {
                    if (a == SuperMap.State.UNKNOWN) {
                        this.state = a
                    }
                }
            }
        }
    },
    CLASS_NAME: "SuperMap.Feature.Vector"
});
SuperMap.Feature.Vector.style = {
    "default": {
        fillColor: "#ee9900",
        fillOpacity: 0.4,
        hoverFillColor: "white",
        hoverFillOpacity: 0.8,
        strokeColor: "#ee9900",
        strokeOpacity: 1,
        strokeWidth: 1,
        strokeLinecap: "round",
        strokeDashstyle: "solid",
        hoverStrokeColor: "red",
        hoverStrokeOpacity: 1,
        hoverStrokeWidth: 0.2,
        pointRadius: 6,
        hoverPointRadius: 1,
        hoverPointUnit: "%",
        pointerEvents: "visiblePainted",
        cursor: "inherit",
        fontColor: "#000000",
        labelAlign: "cm",
        labelOutlineColor: "white",
        labelOutlineWidth: 3
    },
    select: {
        fillColor: "blue",
        fillOpacity: 0.4,
        hoverFillColor: "white",
        hoverFillOpacity: 0.8,
        strokeColor: "blue",
        strokeOpacity: 1,
        strokeWidth: 2,
        strokeLinecap: "round",
        strokeDashstyle: "solid",
        hoverStrokeColor: "red",
        hoverStrokeOpacity: 1,
        hoverStrokeWidth: 0.2,
        pointRadius: 6,
        hoverPointRadius: 1,
        hoverPointUnit: "%",
        pointerEvents: "visiblePainted",
        cursor: "pointer",
        fontColor: "#000000",
        labelAlign: "cm",
        labelOutlineColor: "white",
        labelOutlineWidth: 3
    },
    temporary: {
        fillColor: "#66cccc",
        fillOpacity: 0.2,
        hoverFillColor: "white",
        hoverFillOpacity: 0.8,
        strokeColor: "#66cccc",
        strokeOpacity: 1,
        strokeLinecap: "round",
        strokeWidth: 2,
        strokeDashstyle: "solid",
        hoverStrokeColor: "red",
        hoverStrokeOpacity: 1,
        hoverStrokeWidth: 0.2,
        pointRadius: 6,
        hoverPointRadius: 1,
        hoverPointUnit: "%",
        pointerEvents: "visiblePainted",
        cursor: "inherit",
        fontColor: "#000000",
        labelAlign: "cm",
        labelOutlineColor: "white",
        labelOutlineWidth: 3
    },
    "delete": {
        display: "none"
    }
};
SuperMap.Handler = SuperMap.Class({
    id: null,
    control: null,
    map: null,
    keyMask: null,
    active: false,
    evt: null,
    initialize: function(e, c, a) {
        SuperMap.Util.extend(this, a);
        this.control = e;
        this.callbacks = c;
        var d = this.map || e.map;
        if (d) {
            this.setMap(d)
        }
        this.id = SuperMap.Util.createUniqueID(this.CLASS_NAME + "_")
    },
    setMap: function(a) {
        this.map = a
    },
    checkModifiers: function(a) {
        if (this.keyMask == null) {
            return true
        }
        var c = (a.shiftKey ? SuperMap.Handler.MOD_SHIFT : 0) | (a.ctrlKey ? SuperMap.Handler.MOD_CTRL : 0) | (a.altKey ? SuperMap.Handler.MOD_ALT : 0);
        return ( c == this.keyMask)
    },
    activate: function() {
        if (this.active) {
            return false
        }
        var d = SuperMap.Events.prototype.BROWSER_EVENTS;
        for (var c = 0, a = d.length; c < a; c++) {
            if (this[d[c]]) {
                this.register(d[c], this[d[c]])
            }
        }
        this.active = true;
        return true
    },
    deactivate: function() {
        if (!this.active) {
            return false
        }
        var d = SuperMap.Events.prototype.BROWSER_EVENTS;
        for (var c = 0, a = d.length; c < a; c++) {
            if (this[d[c]]) {
                this.unregister(d[c], this[d[c]])
            }
        }
        this.active = false;
        return true
    },
    callback: function(c, a) {
        if (c && this.callbacks[c]) {
            this.callbacks[c].apply(this.control, a)
        }
    },
    register: function(a, c) {
        this.map.events.registerPriority(a, this, c);
        this.map.events.registerPriority(a, this, this.setEvent)
    },
    unregister: function(a, c) {
        this.map.events.unregister(a, this, c);
        this.map.events.unregister(a, this, this.setEvent)
    },
    setEvent: function(a) {
        this.evt = a;
        return true
    },
    destroy: function() {
        this.deactivate();
        this.control = this.map = null
    },
    CLASS_NAME: "SuperMap.Handler"
});
SuperMap.Handler.MOD_NONE = 0;
SuperMap.Handler.MOD_SHIFT = 1;
SuperMap.Handler.MOD_CTRL = 2;
SuperMap.Handler.MOD_ALT = 4;
SuperMap.Handler.Click = SuperMap.Class(SuperMap.Handler, {
    delay: 300,
    single: true,
    "double": false,
    pixelTolerance: 0,
    dblclickTolerance: 13,
    stopSingle: false,
    stopDouble: false,
    timerId: null,
    touch: false,
    down: null,
    last: null,
    first: null,
    rightclickTimerId: null,
    initialize: function(d, c, a) {
        SuperMap.Handler.prototype.initialize.apply(this, arguments)
    },
    touchstart: function(a) {
        if (!this.touch) {
            this.unregisterMouseListeners();
            this.touch = true
        }
        this.down = this.getEventInfo(a);
        this.last = this.getEventInfo(a);
        return true
    },
    touchmove: function(a) {
        this.last = this.getEventInfo(a);
        return true
    },
    touchend: function(a) {
        if (this.down) {
            a.xy = this.last.xy;
            a.lastTouches = this.last.touches;
            this.handleSingle(a);
            this.down = null
        }
        return true
    },
    unregisterMouseListeners: function() {
        this.map.events.un({
            mousedown: this.mousedown,
            mouseup: this.mouseup,
            click: this.click,
            dblclick: this.dblclick,
            scope: this
        })
    },
    mousedown: function(a) {
        this.down = this.getEventInfo(a);
        this.last = this.getEventInfo(a);
        return true
    },
    mouseup: function(c) {
        var a = true;
        if (this.checkModifiers(c) && this.control.handleRightClicks && SuperMap.Event.isRightClick(c)) {
            a = this.rightclick(c)
        }
        return a
    },
    rightclick: function(c) {
        if (this.passesTolerance(c)) {
            if (this.rightclickTimerId != null) {
                this.clearTimer();
                this.callback("dblrightclick", [c]);
                return !this.stopDouble
            } else {
                var a = this["double"] ? SuperMap.Util.extend({}, c) : this.callback("rightclick", [c]);
                var d = SuperMap.Function.bind(this.delayedRightCall, this, a);
                this.rightclickTimerId = window.setTimeout(d, this.delay)
            }
        }
        return !this.stopSingle
    },
    delayedRightCall: function(a) {
        this.rightclickTimerId = null;
        if (a) {
            this.callback("rightclick", [a])
        }
    },
    click: function(a) {
        if (!this.last) {
            this.last = this.getEventInfo(a)
        }
        this.handleSingle(a);
        return !this.stopSingle
    },
    dblclick: function(a) {
        this.handleDouble(a);
        return !this.stopDouble
    },
    handleDouble: function(a) {
        if (this["double"] && this.passesDblclickTolerance(a)) {
            this.callback("dblclick", [a])
        }
    },
    handleSingle: function(c) {
        if (this.passesTolerance(c)) {
            if (this.timerId != null) {
                if (this.last.touches && this.last.touches.length === 1) {
                    if (this["double"]) {
                        SuperMap.Event.stop(c)
                    }
                    this.handleDouble(c)
                }
                if (!this.last.touches || this.last.touches.length !== 2) {
                    this.clearTimer()
                }
            } else {
                this.first = this.getEventInfo(c);
                var a = this.single ? SuperMap.Util.extend({}, c) : null;
                this.queuePotentialClick(a)
            }
        }
    },
    queuePotentialClick: function(a) {
        this.timerId = window.setTimeout(SuperMap.Function.bind(this.delayedCall, this, a), this.delay)
    },
    passesTolerance: function(a) {
        var e = true;
        if (this.pixelTolerance != null && this.down && this.down.xy) {
            e = this.pixelTolerance >= this.down.xy.distanceTo(a.xy);
            if (e && this.touch && this.down.touches.length === this.last.touches.length) {
                for (var c = 0, d = this.down.touches.length; c < d; ++c) {
                    if (this.getTouchDistance(this.down.touches[c], this.last.touches[c]) > this.pixelTolerance) {
                        e = false;
                        break
                    }
                }
            }
        }
        return e
    },
    getTouchDistance: function(c, a) {
        return Math.sqrt(Math.pow(c.clientX - a.clientX, 2) + Math.pow(c.clientY - a.clientY, 2))
    },
    passesDblclickTolerance: function(a) {
        var c = true;
        if (this.down && this.first) {
            c = this.down.xy.distanceTo(this.first.xy) <= this.dblclickTolerance
        }
        return c
    },
    clearTimer: function() {
        if (this.timerId != null) {
            window.clearTimeout(this.timerId);
            this.timerId = null
        }
        if (this.rightclickTimerId != null) {
            window.clearTimeout(this.rightclickTimerId);
            this.rightclickTimerId = null
        }
    },
    delayedCall: function(a) {
        this.timerId = null;
        if (a) {
            this.callback("click", [a])
        }
    },
    getEventInfo: function(c) {
        var e;
        if (c.touches) {
            var a = c.touches.length;
            e = new Array(a);
            var f;
            for (var d = 0; d < a; d++) {
                f = c.touches[d];
                e[d] = {
                    clientX: f.clientX,
                    clientY: f.clientY
                }
            }
        }
        return {
            xy: c.xy,
            touches: e
        }
    },
    deactivate: function() {
        var a = false;
        if (SuperMap.Handler.prototype.deactivate.apply(this, arguments)) {
            this.clearTimer();
            this.down = null;
            this.first = null;
            this.last = null;
            this.touch = false;
            a = true
        }
        return a
    },
    CLASS_NAME: "SuperMap.Handler.Click"
});
SuperMap.Handler.Hover = SuperMap.Class(SuperMap.Handler, {
    delay: 500,
    pixelTolerance: null,
    stopMove: false,
    px: null,
    timerId: null,
    initialize: function(d, c, a) {
        SuperMap.Handler.prototype.initialize.apply(this, arguments)
    },
    mousemove: function(a) {
        if (this.passesTolerance(a.xy)) {
            this.clearTimer();
            this.callback("move", [a]);
            this.px = a.xy;
            a = SuperMap.Util.extend({}, a);
            this.timerId = window.setTimeout(SuperMap.Function.bind(this.delayedCall, this, a), this.delay)
        }
        return !this.stopMove
    },
    mouseout: function(a) {
        if (SuperMap.Util.mouseLeft(a, this.map.eventsDiv)) {
            this.clearTimer();
            this.callback("move", [a])
        }
        return true
    },
    passesTolerance: function(c) {
        var d = true;
        if (this.pixelTolerance && this.px) {
            var a = Math.sqrt(Math.pow(this.px.x - c.x, 2) + Math.pow(this.px.y - c.y, 2));
            if (a < this.pixelTolerance) {
                d = false
            }
        }
        return d
    },
    clearTimer: function() {
        if (this.timerId != null) {
            window.clearTimeout(this.timerId);
            this.timerId = null
        }
    },
    delayedCall: function(a) {
        this.callback("pause", [a])
    },
    deactivate: function() {
        var a = false;
        if (SuperMap.Handler.prototype.deactivate.apply(this, arguments)) {
            this.clearTimer();
            a = true
        }
        return a
    },
    CLASS_NAME: "SuperMap.Handler.Hover"
});
SuperMap.Handler.Point = SuperMap.Class(SuperMap.Handler, {
    point: null,
    layer: null,
    multi: false,
    mouseDown: false,
    stoppedDown: null,
    lastDown: null,
    lastUp: null,
    persist: false,
    stopDown: false,
    stopUp: false,
    layerOptions: null,
    pixelTolerance: 5,
    touch: false,
    lastTouchPx: null,
    initialize: function(d, c, a) {
        if (!(a && a.layerOptions && a.layerOptions.styleMap)) {
            this.style = SuperMap.Util.extend(SuperMap.Feature.Vector.style["default"], {})
        }
        SuperMap.Handler.prototype.initialize.apply(this, arguments)
    },
    activate: function() {
        if (!SuperMap.Handler.prototype.activate.apply(this, arguments)) {
            return false
        }
        var a = SuperMap.Util.extend({
            displayInLayerSwitcher: false,
            calculateInRange: SuperMap.Function.True
        }, this.layerOptions);
        this.layer = new SuperMap.Layer.Vector(this.CLASS_NAME,a);
        this.map.addLayer(this.layer);
        return true
    },
    createFeature: function(a) {
        var c = this.layer.getLonLatFromViewPortPx(a);
        var d = new SuperMap.Geometry.Point(c.lon,c.lat);
        this.point = new SuperMap.Feature.Vector(d);
        this.callback("create", [this.point.geometry, this.point]);
        this.point.geometry.clearBounds();
        this.layer.addFeatures([this.point], {
            silent: true
        })
    },
    deactivate: function() {
        if (!SuperMap.Handler.prototype.deactivate.apply(this, arguments)) {
            return false
        }
        this.cancel();
        if (this.layer.map != null) {
            this.destroyFeature(true);
            this.layer.destroy(false)
        }
        this.layer = null;
        this.touch = false;
        return true
    },
    destroyFeature: function(a) {
        if (this.layer && (a || !this.persist)) {
            this.layer.destroyFeatures()
        }
        this.point = null
    },
    destroyPersistedFeature: function() {
        var a = this.layer;
        if (a && a.features.length > 1) {
            this.layer.features[0].destroy()
        }
    },
    finalize: function(c) {
        var a = c ? "cancel" : "done";
        this.mouseDown = false;
        this.lastDown = null;
        this.lastUp = null;
        this.lastTouchPx = null;
        this.callback(a, [this.geometryClone()]);
        this.destroyFeature(c)
    },
    cancel: function() {
        this.finalize(true)
    },
    click: function(a) {
        SuperMap.Event.stop(a);
        return false
    },
    dblclick: function(a) {
        SuperMap.Event.stop(a);
        return false
    },
    modifyFeature: function(a) {
        if (!this.point) {
            this.createFeature(a)
        }
        var c = this.layer.getLonLatFromViewPortPx(a);
        this.point.geometry.x = c.lon;
        this.point.geometry.y = c.lat;
        this.callback("modify", [this.point.geometry, this.point, false]);
        this.point.geometry.clearBounds();
        this.drawFeature()
    },
    drawFeature: function() {
        this.layer.drawFeature(this.point, this.style)
    },
    getGeometry: function() {
        var a = this.point && this.point.geometry;
        if (a && this.multi) {
            a = new SuperMap.Geometry.MultiPoint([a])
        }
        return a
    },
    geometryClone: function() {
        var a = this.getGeometry();
        return a && a.clone()
    },
    mousedown: function(a) {
        return this.down(a)
    },
    touchstart: function(a) {
        if (!this.touch) {
            this.touch = true;
            this.map.events.un({
                mousedown: this.mousedown,
                mouseup: this.mouseup,
                mousemove: this.mousemove,
                click: this.click,
                dblclick: this.dblclick,
                scope: this
            })
        }
        this.lastTouchPx = a.xy;
        return this.down(a)
    },
    mousemove: function(a) {
        return this.move(a)
    },
    touchmove: function(a) {
        this.lastTouchPx = a.xy;
        return this.move(a)
    },
    mouseup: function(a) {
        return this.up(a)
    },
    touchend: function(a) {
        a.xy = this.lastTouchPx;
        return this.up(a)
    },
    down: function(a) {
        this.mouseDown = true;
        this.lastDown = a.xy;
        if (!this.touch) {
            this.modifyFeature(a.xy)
        }
        this.stoppedDown = this.stopDown;
        return !this.stopDown
    },
    move: function(a) {
        if (!this.touch && (!this.mouseDown || this.stoppedDown)) {
            this.modifyFeature(a.xy)
        }
        return true
    },
    up: function(a) {
        this.mouseDown = false;
        this.stoppedDown = this.stopDown;
        if (!this.checkModifiers(a)) {
            return true
        }
        if (this.lastUp && this.lastUp.equals(a.xy)) {
            return true
        }
        if (this.lastDown && this.passesTolerance(this.lastDown, a.xy, this.pixelTolerance)) {
            if (this.touch) {
                this.modifyFeature(a.xy)
            }
            if (this.persist) {
                this.destroyPersistedFeature()
            }
            this.lastUp = a.xy;
            this.finalize();
            return !this.stopUp
        } else {
            return true
        }
    },
    mouseout: function(a) {
        if (SuperMap.Util.mouseLeft(a, this.map.eventsDiv)) {
            this.stoppedDown = this.stopDown;
            this.mouseDown = false
        }
    },
    passesTolerance: function(f, e, a) {
        var c = true;
        if (a != null && f && e) {
            var d = f.distanceTo(e);
            if (d > a) {
                c = false
            }
        }
        return c
    },
    CLASS_NAME: "SuperMap.Handler.Point"
});
SuperMap.Handler.Path = SuperMap.Class(SuperMap.Handler.Point, {
    line: null,
    maxVertices: null,
    doubleTouchTolerance: 20,
    freehand: false,
    freehandToggle: "shiftKey",
    timerId: null,
    redoStack: null,
    initialize: function(d, c, a) {
        SuperMap.Handler.Point.prototype.initialize.apply(this, arguments)
    },
    createFeature: function(a) {
        var c = this.map.getLonLatFromPixel(a);
        var d = new SuperMap.Geometry.Point(c.lon,c.lat);
        this.point = new SuperMap.Feature.Vector(d);
        this.line = new SuperMap.Feature.Vector(new SuperMap.Geometry.LineString([this.point.geometry]));
        this.callback("create", [this.point.geometry, this.getSketch()]);
        this.point.geometry.clearBounds();
        this.layer.addFeatures([this.line, this.point], {
            silent: true
        })
    },
    destroyFeature: function(a) {
        SuperMap.Handler.Point.prototype.destroyFeature.call(this, a);
        this.line = null
    },
    destroyPersistedFeature: function() {
        var a = this.layer;
        if (a && a.features.length > 2) {
            this.layer.features[0].destroy()
        }
    },
    removePoint: function() {
        if (this.point) {
            this.layer.removeFeatures([this.point])
        }
    },
    addPoint: function(a) {
        this.layer.removeFeatures([this.point]);
        var c = this.layer.getLonLatFromViewPortPx(a);
        this.point = new SuperMap.Feature.Vector(new SuperMap.Geometry.Point(c.lon,c.lat));
        this.line.geometry.addComponent(this.point.geometry, this.line.geometry.components.length);
        this.layer.addFeatures([this.point]);
        this.callback("point", [this.point.geometry, this.getGeometry()]);
        this.callback("modify", [this.point.geometry, this.getSketch()]);
        this.drawFeature();
        delete this.redoStack
    },
    insertXY: function(a, c) {
        this.line.geometry.addComponent(new SuperMap.Geometry.Point(a,c), this.getCurrentPointIndex());
        this.drawFeature();
        delete this.redoStack
    },
    insertDeltaXY: function(c, a) {
        var d = this.getCurrentPointIndex() - 1;
        var e = this.line.geometry.components[d];
        if (e && !isNaN(e.x) && !isNaN(e.y)) {
            this.insertXY(e.x + c, e.y + a)
        }
    },
    insertDirectionLength: function(e, d) {
        e *= Math.PI / 180;
        var c = d * Math.cos(e);
        var a = d * Math.sin(e);
        this.insertDeltaXY(c, a)
    },
    insertDeflectionLength: function(d, c) {
        var e = this.getCurrentPointIndex() - 1;
        if (e > 0) {
            var f = this.line.geometry.components[e];
            var g = this.line.geometry.components[e - 1];
            var a = Math.atan2(f.y - g.y, f.x - g.x);
            this.insertDirectionLength((a * 180 / Math.PI) + d, c)
        }
    },
    getCurrentPointIndex: function() {
        return this.line.geometry.components.length - 1
    },
    undo: function() {
        var f = this.line.geometry;
        var c = f.components;
        var a = this.getCurrentPointIndex() - 1;
        var e = c[a];
        var d = f.removeComponent(e);
        if (d) {
            if (!this.redoStack) {
                this.redoStack = []
            }
            this.redoStack.push(e);
            this.drawFeature()
        }
        return d
    },
    redo: function() {
        var a = this.redoStack && this.redoStack.pop();
        if (a) {
            this.line.geometry.addComponent(a, this.getCurrentPointIndex());
            this.drawFeature()
        }
        return !!a
    },
    freehandMode: function(a) {
        return (this.freehandToggle && a[this.freehandToggle]) ? !this.freehand : this.freehand
    },
    modifyFeature: function(c, a) {
        if (!this.line) {
            this.createFeature(c)
        }
        var d = this.layer.getLonLatFromViewPortPx(c);
        this.point.geometry.x = d.lon;
        this.point.geometry.y = d.lat;
        this.callback("modify", [this.point.geometry, this.getSketch(), a]);
        this.point.geometry.clearBounds();
        this.drawFeature()
    },
    drawFeature: function() {
        this.layer.drawFeature(this.line, this.style);
        this.layer.drawFeature(this.point, this.style)
    },
    getSketch: function() {
        return this.line
    },
    getGeometry: function() {
        var a = this.line && this.line.geometry;
        if (a && this.multi) {
            a = new SuperMap.Geometry.MultiLineString([a])
        }
        return a
    },
    touchstart: function(a) {
        if (this.timerId && this.passesTolerance(this.lastTouchPx, a.xy, this.doubleTouchTolerance)) {
            this.finishGeometry();
            window.clearTimeout(this.timerId);
            this.timerId = null;
            return false
        } else {
            if (this.timerId) {
                window.clearTimeout(this.timerId);
                this.timerId = null
            }
            this.timerId = window.setTimeout(SuperMap.Function.bind(function() {
                this.timerId = null
            }, this), 300);
            return SuperMap.Handler.Point.prototype.touchstart.call(this, a)
        }
    },
    down: function(a) {
        var c = this.stopDown;
        if (this.freehandMode(a)) {
            c = true;
            if (this.touch) {
                this.modifyFeature(a.xy, !!this.lastUp);
                SuperMap.Event.stop(a)
            }
        }
        if (!this.touch && (!this.lastDown || !this.passesTolerance(this.lastDown, a.xy, this.pixelTolerance))) {
            this.modifyFeature(a.xy, !!this.lastUp)
        }
        this.mouseDown = true;
        this.lastDown = a.xy;
        this.stoppedDown = c;
        return !c
    },
    move: function(a) {
        if (this.stoppedDown && this.freehandMode(a)) {
            if (this.persist) {
                this.destroyPersistedFeature()
            }
            if (this.maxVertices && this.line && this.line.geometry.components.length === this.maxVertices) {
                this.removePoint();
                this.finalize()
            } else {
                this.addPoint(a.xy)
            }
            return false
        }
        if (!this.touch && (!this.mouseDown || this.stoppedDown)) {
            this.modifyFeature(a.xy, !!this.lastUp)
        }
        return true
    },
    up: function(a) {
        if (this.mouseDown && (!this.lastUp || !this.lastUp.equals(a.xy))) {
            if (this.stoppedDown && this.freehandMode(a)) {
                if (this.persist) {
                    this.destroyPersistedFeature()
                }
                this.removePoint();
                this.finalize()
            } else {
                if (this.passesTolerance(this.lastDown, a.xy, this.pixelTolerance)) {
                    if (this.touch) {
                        this.modifyFeature(a.xy)
                    }
                    if (this.lastUp == null && this.persist) {
                        this.destroyPersistedFeature()
                    }
                    this.addPoint(a.xy);
                    this.lastUp = a.xy;
                    if (this.line.geometry.components.length === this.maxVertices + 1) {
                        this.finishGeometry()
                    }
                }
            }
        }
        this.stoppedDown = this.stopDown;
        this.mouseDown = false;
        return !this.stopUp
    },
    finishGeometry: function() {
        var a = this.line.geometry.components.length - 1;
        this.line.geometry.removeComponent(this.line.geometry.components[a]);
        this.removePoint();
        this.finalize()
    },
    dblclick: function(a) {
        if (!this.freehandMode(a)) {
            this.finishGeometry()
        }
        return false
    },
    CLASS_NAME: "SuperMap.Handler.Path"
});
SuperMap.Handler.Polygon = SuperMap.Class(SuperMap.Handler.Path, {
    holeModifier: null,
    drawingHole: false,
    polygon: null,
    initialize: function(d, c, a) {
        SuperMap.Handler.Path.prototype.initialize.apply(this, arguments)
    },
    createFeature: function(a) {
        var c = this.layer.getLonLatFromViewPortPx(a);
        var d = new SuperMap.Geometry.Point(c.lon,c.lat);
        this.point = new SuperMap.Feature.Vector(d);
        this.line = new SuperMap.Feature.Vector(new SuperMap.Geometry.LinearRing([this.point.geometry]));
        this.polygon = new SuperMap.Feature.Vector(new SuperMap.Geometry.Polygon([this.line.geometry]));
        this.callback("create", [this.point.geometry, this.getSketch()]);
        this.point.geometry.clearBounds();
        this.layer.addFeatures([this.polygon, this.point], {
            silent: true
        })
    },
    addPoint: function(a) {
        if (!this.drawingHole && this.holeModifier && this.evt && this.evt[this.holeModifier]) {
            var g = this.point.geometry;
            var f = this.control.layer.features;
            var e, d;
            for (var c = f.length - 1; c >= 0; --c) {
                e = f[c].geometry;
                if ((e instanceof SuperMap.Geometry.Polygon || e instanceof SuperMap.Geometry.MultiPolygon) && e.intersects(g)) {
                    d = f[c];
                    this.control.layer.removeFeatures([d], {
                        silent: true
                    });
                    this.control.layer.events.registerPriority("sketchcomplete", this, this.finalizeInteriorRing);
                    this.control.layer.events.registerPriority("sketchmodified", this, this.enforceTopology);
                    d.geometry.addComponent(this.line.geometry);
                    this.polygon = d;
                    this.drawingHole = true;
                    break
                }
            }
        }
        SuperMap.Handler.Path.prototype.addPoint.apply(this, arguments)
    },
    getCurrentPointIndex: function() {
        return this.line.geometry.components.length - 2
    },
    enforceTopology: function(e) {
        var a = e.vertex;
        var d = this.line.geometry.components;
        if (!this.polygon.geometry.intersects(a)) {
            var c = d[d.length - 3];
            a.x = c.x;
            a.y = c.y
        }
    },
    finishGeometry: function() {
        var a = this.line.geometry.components.length - 2;
        this.line.geometry.removeComponent(this.line.geometry.components[a]);
        this.removePoint();
        this.finalize()
    },
    finalizeInteriorRing: function() {
        var d = this.line.geometry;
        var c = (d.getArea() !== 0);
        if (c) {
            var k = this.polygon.geometry.components;
            for (var e = k.length - 2; e >= 0; --e) {
                if (d.intersects(k[e])) {
                    c = false;
                    break
                }
            }
            if (c) {
                var h;
                outer: for (var e = k.length - 2; e > 0; --e) {
                    var f = k[e].components;
                    for (var a = 0, g = f.length; a < g; ++a) {
                        if (d.containsPoint(f[a])) {
                            c = false;
                            break outer
                        }
                    }
                }
            }
        }
        if (c) {
            if (this.polygon.state !== SuperMap.State.INSERT) {
                this.polygon.state = SuperMap.State.UPDATE
            }
        } else {
            this.polygon.geometry.removeComponent(d)
        }
        this.restoreFeature();
        return false
    },
    cancel: function() {
        if (this.drawingHole) {
            this.polygon.geometry.removeComponent(this.line.geometry);
            this.restoreFeature(true)
        }
        return SuperMap.Handler.Path.prototype.cancel.apply(this, arguments)
    },
    restoreFeature: function(a) {
        this.control.layer.events.unregister("sketchcomplete", this, this.finalizeInteriorRing);
        this.control.layer.events.unregister("sketchmodified", this, this.enforceTopology);
        this.layer.removeFeatures([this.polygon], {
            silent: true
        });
        this.control.layer.addFeatures([this.polygon], {
            silent: true
        });
        this.drawingHole = false;
        if (!a) {
            this.control.layer.events.triggerEvent("sketchcomplete", {
                feature: this.polygon
            })
        }
    },
    destroyFeature: function(a) {
        SuperMap.Handler.Path.prototype.destroyFeature.call(this, a);
        this.polygon = null
    },
    drawFeature: function() {
        this.layer.drawFeature(this.polygon, this.style);
        this.layer.drawFeature(this.point, this.style)
    },
    getSketch: function() {
        return this.polygon
    },
    getGeometry: function() {
        var a = this.polygon && this.polygon.geometry;
        if (a && this.multi) {
            a = new SuperMap.Geometry.MultiPolygon([a])
        }
        return a
    },
    CLASS_NAME: "SuperMap.Handler.Polygon"
});
SuperMap.Handler.Feature = SuperMap.Class(SuperMap.Handler, {
    EVENTMAP: {
        click: {
            "in": "click",
            out: "clickout"
        },
        mousemove: {
            "in": "over",
            out: "out"
        },
        dblclick: {
            "in": "dblclick",
            out: null
        },
        mousedown: {
            "in": null,
            out: null
        },
        mouseup: {
            "in": null,
            out: null
        },
        touchstart: {
            "in": "click",
            out: "clickout"
        }
    },
    feature: null,
    lastFeature: null,
    down: null,
    up: null,
    touch: false,
    clickTolerance: 4,
    geometryTypes: null,
    stopClick: true,
    stopDown: false,
    stopUp: false,
    initialize: function(e, c, d, a) {
        SuperMap.Handler.prototype.initialize.apply(this, [e, d, a]);
        this.layer = c
    },
    touchstart: function(a) {
        if (!this.touch) {
            this.touch = true;
            this.map.events.un({
                mousedown: this.mousedown,
                mouseup: this.mouseup,
                mousemove: this.mousemove,
                click: this.click,
                dblclick: this.dblclick,
                scope: this
            })
        }
        return SuperMap.Event.isMultiTouch(a) ? true : this.mousedown(a)
    },
    touchmove: function(a) {
        SuperMap.Event.stop(a)
    },
    mousedown: function(a) {
        if (SuperMap.Event.isLeftClick(a) || SuperMap.Event.isSingleTouch(a)) {
            this.down = a.xy
        }
        return this.handle(a) ? !this.stopDown : true
    },
    mouseup: function(a) {
        this.up = a.xy;
        return this.handle(a) ? !this.stopUp : true
    },
    click: function(a) {
        return this.handle(a) ? !this.stopClick : true
    },
    mousemove: function(a) {
        if (!this.callbacks.over && !this.callbacks.out) {
            return true
        }
        this.handle(a);
        return true
    },
    dblclick: function(a) {
        return !this.handle(a)
    },
    geometryTypeMatches: function(a) {
        return this.geometryTypes == null || SuperMap.Util.indexOf(this.geometryTypes, a.geometry.CLASS_NAME) > -1
    },
    handle: function(a) {
        if (this.feature && !this.feature.layer) {
            this.feature = null
        }
        var d = a.type;
        var g = false;
        var f = !!(this.feature);
        var e = (d == "click" || d == "dblclick" || d == "touchstart");
        this.feature = this.layer.getFeatureFromEvent(a);
        if (this.feature && !this.feature.layer) {
            this.feature = null
        }
        if (this.lastFeature && !this.lastFeature.layer) {
            this.lastFeature = null
        }
        if (this.feature) {
            if (d === "touchstart") {
                SuperMap.Event.stop(a)
            }
            var c = (this.feature != this.lastFeature);
            if (this.geometryTypeMatches(this.feature)) {
                if (f && c) {
                    if (this.lastFeature) {
                        this.triggerCallback(d, "out", [this.lastFeature])
                    }
                    this.triggerCallback(d, "in", [this.feature])
                } else {
                    if (!f || e) {
                        this.triggerCallback(d, "in", [this.feature])
                    }
                }
                this.lastFeature = this.feature;
                g = true
            } else {
                if (this.lastFeature && (f && c || e)) {
                    this.triggerCallback(d, "out", [this.lastFeature])
                }
                this.feature = null
            }
        } else {
            if (this.lastFeature && (f || e)) {
                this.triggerCallback(d, "out", [this.lastFeature])
            }
        }
        return g
    },
    triggerCallback: function(e, f, c) {
        var d = this.EVENTMAP[e][f];
        if (d) {
            if (e == "click" && this.up && this.down) {
                var a = Math.sqrt(Math.pow(this.up.x - this.down.x, 2) + Math.pow(this.up.y - this.down.y, 2));
                if (a <= this.clickTolerance) {
                    this.callback(d, c)
                }
            } else {
                this.callback(d, c)
            }
        }
    },
    activate: function() {
        var a = false;
        if (SuperMap.Handler.prototype.activate.apply(this, arguments)) {
            this.moveLayerToTop();
            this.map.events.on({
                removelayer: this.handleMapEvents,
                changelayer: this.handleMapEvents,
                scope: this
            });
            a = true
        }
        return a
    },
    deactivate: function() {
        var a = false;
        if (SuperMap.Handler.prototype.deactivate.apply(this, arguments)) {
            this.moveLayerBack();
            this.feature = null;
            this.lastFeature = null;
            this.down = null;
            this.up = null;
            this.touch = false;
            this.map.events.un({
                removelayer: this.handleMapEvents,
                changelayer: this.handleMapEvents,
                scope: this
            });
            a = true
        }
        return a
    },
    handleMapEvents: function(a) {
        if (a.type == "removelayer" || a.property == "order") {
            this.moveLayerToTop()
        }
    },
    moveLayerToTop: function() {
        var a = Math.max(this.map.Z_INDEX_BASE.Feature - 1, this.layer.getZIndex()) + 1;
        this.layer.setZIndex(a)
    },
    moveLayerBack: function() {
        var a = this.layer.getZIndex() - 1;
        if (a >= this.map.Z_INDEX_BASE.Feature) {
            this.layer.setZIndex(a)
        } else {
            this.map.setLayerZIndex(this.layer, this.map.getLayerIndex(this.layer))
        }
    },
    CLASS_NAME: "SuperMap.Handler.Feature"
});
SuperMap.Handler.Drag = SuperMap.Class(SuperMap.Handler, {
    started: false,
    stopDown: true,
    dragging: false,
    touch: false,
    last: null,
    start: null,
    lastMoveEvt: null,
    oldOnselectstart: null,
    interval: 0,
    timeoutId: null,
    documentDrag: false,
    documentEvents: null,
    initialize: function(e, d, a) {
        SuperMap.Handler.prototype.initialize.apply(this, arguments);
        if (this.documentDrag === true) {
            var c = this;
            this._docMove = function(f) {
                c.mousemove({
                    xy: {
                        x: f.clientX,
                        y: f.clientY
                    },
                    element: document
                })
            }
            ;
            this._docUp = function(f) {
                c.mouseup({
                    xy: {
                        x: f.clientX,
                        y: f.clientY
                    }
                })
            }
        }
    },
    dragstart: function(c) {
        var a = true;
        this.dragging = false;
        if (this.checkModifiers(c) && (SuperMap.Event.isLeftClick(c) || SuperMap.Event.isSingleTouch(c)) && !SuperMap.isApp) {
            this.started = true;
            this.start = c.xy;
            this.last = c.xy;
            SuperMap.Element.addClass(this.map.viewPortDiv, "smDragDown");
            this.down(c);
            this.callback("down", [c.xy]);
            SuperMap.Event.stop(c);
            if (!this.oldOnselectstart) {
                this.oldOnselectstart = document.onselectstart ? document.onselectstart : SuperMap.Function.True
            }
            document.onselectstart = SuperMap.Function.False;
            a = !this.stopDown
        } else {
            this.started = false;
            this.start = null;
            this.last = null
        }
        return a
    },
    dragmove: function(a) {
        this.lastMoveEvt = a;
        if (this.started && !this.timeoutId && (a.xy.x != this.last.x || a.xy.y != this.last.y)) {
            if (this.documentDrag === true && this.documentEvents) {
                if (a.element === document) {
                    this.adjustXY(a);
                    this.setEvent(a)
                } else {
                    this.removeDocumentEvents()
                }
            }
            if (this.interval > 0) {
                this.timeoutId = setTimeout(SuperMap.Function.bind(this.removeTimeout, this), this.interval)
            }
            this.dragging = true;
            this.move(a);
            this.callback("move", [a.xy]);
            if (!this.oldOnselectstart) {
                this.oldOnselectstart = document.onselectstart;
                document.onselectstart = SuperMap.Function.False
            }
            this.last = a.xy
        }
        return true
    },
    dragend: function(c) {
        if (this.started) {
            if (this.documentDrag === true && this.documentEvents) {
                this.adjustXY(c);
                this.removeDocumentEvents()
            }
            var a = (this.start != this.last);
            this.started = false;
            this.dragging = false;
            SuperMap.Element.removeClass(this.map.viewPortDiv, "smDragDown");
            this.up(c);
            this.callback("up", [c.xy]);
            if (a) {
                this.callback("done", [c.xy])
            }
            document.onselectstart = this.oldOnselectstart
        }
        return true
    },
    down: function(a) {},
    move: function(a) {},
    up: function(a) {},
    out: function(a) {},
    mousedown: function(a) {
        return this.dragstart(a)
    },
    touchstart: function(a) {
        if (!this.touch) {
            this.touch = true;
            this.map.events.un({
                mousedown: this.mousedown,
                mouseup: this.mouseup,
                mousemove: this.mousemove,
                click: this.click,
                scope: this
            })
        }
        return this.dragstart(a)
    },
    mousemove: function(a) {
        return this.dragmove(a)
    },
    touchmove: function(a) {
        return this.dragmove(a)
    },
    removeTimeout: function() {
        this.timeoutId = null;
        if (this.dragging) {
            this.mousemove(this.lastMoveEvt)
        }
    },
    mouseup: function(a) {
        return this.dragend(a)
    },
    touchend: function(a) {
        a.xy = this.last;
        return this.dragend(a)
    },
    mouseout: function(c) {
        if (this.started && SuperMap.Util.mouseLeft(c, this.map.eventsDiv)) {
            if (this.documentDrag === true) {
                this.addDocumentEvents()
            } else {
                var a = (this.start != this.last);
                this.started = false;
                this.dragging = false;
                SuperMap.Element.removeClass(this.map.viewPortDiv, "smDragDown");
                this.out(c);
                this.callback("out", []);
                if (a) {
                    this.callback("done", [c.xy])
                }
                if (document.onselectstart) {
                    document.onselectstart = this.oldOnselectstart
                }
            }
        }
        return true
    },
    click: function(a) {
        return ( this.start == this.last)
    },
    activate: function() {
        var a = false;
        if (SuperMap.Handler.prototype.activate.apply(this, arguments)) {
            this.dragging = false;
            a = true
        }
        return a
    },
    deactivate: function() {
        var a = false;
        if (SuperMap.Handler.prototype.deactivate.apply(this, arguments)) {
            this.touch = false;
            this.started = false;
            this.dragging = false;
            this.start = null;
            this.last = null;
            a = true;
            SuperMap.Element.removeClass(this.map.viewPortDiv, "smDragDown")
        }
        return a
    },
    adjustXY: function(a) {
        var c = SuperMap.Util.pagePosition(this.map.viewPortDiv);
        a.xy.x -= c[0];
        a.xy.y -= c[1]
    },
    addDocumentEvents: function() {
        SuperMap.Element.addClass(document.body, "smDragDown");
        this.documentEvents = true;
        SuperMap.Event.observe(document, "mousemove", this._docMove);
        SuperMap.Event.observe(document, "mouseup", this._docUp)
    },
    removeDocumentEvents: function() {
        SuperMap.Element.removeClass(document.body, "smDragDown");
        this.documentEvents = false;
        SuperMap.Event.stopObserving(document, "mousemove", this._docMove);
        SuperMap.Event.stopObserving(document, "mouseup", this._docUp)
    },
    CLASS_NAME: "SuperMap.Handler.Drag"
});
SuperMap.Handler.Pinch = SuperMap.Class(SuperMap.Handler, {
    started: false,
    stopDown: false,
    pinching: false,
    last: null,
    start: null,
    msGesture: null,
    scale: null,
    initialize: function(e, d, a) {
        var c = this;
        SuperMap.Handler.prototype.initialize.apply(c, arguments)
    },
    MSPointerDown: function(a) {
        var c = typeof MSGesture;
        if (this.msGesture === null && (c !== "undefined")) {
            this.msGesture = new MSGesture();
            this.msGesture.target = a.target
        }
        if (a.pointerType !== 4 && (c !== "undefined")) {
            this.msGesture.addPointer(a.pointerId)
        }
    },
    MSPointerUp: function(a) {
        if (this.msGesture) {
            this.msGesture.stop()
        }
    },
    touchstart: function(c) {
        var a = true;
        this.pinching = false;
        if (SuperMap.Event.isMultiTouch(c) || SuperMap.isApp) {
            this.started = true;
            this.last = this.start = {
                distance: this.getDistance(c.touches),
                delta: 0,
                scale: 1
            };
            this.callback("start", [c, this.start]);
            a = !this.stopDown
        } else {
            this.started = false;
            this.start = null;
            this.last = null
        }
        SuperMap.Event.stop(c);
        return a
    },
    touchmove: function(a) {
        if (this.started && SuperMap.Event.isMultiTouch(a) || SuperMap.isApp) {
            this.pinching = true;
            var c = this.getPinchData(a);
            this.callback("move", [a, c]);
            this.last = c;
            SuperMap.Event.stop(a)
        }
        return true
    },
    touchend: function(a) {
        if (this.started) {
            try {
                if (SuperMap.isApp) {
                    this.map.baseLayer.zoomDuration = 0
                }
            } catch (c) {}
            this.started = false;
            this.pinching = false;
            this.callback("done", [a, this.start, this.last]);
            this.start = null;
            this.last = null
        }
        return true
    },
    MSGestureStart: function(c) {
        var a = true;
        this.pinching = false;
        this.started = true;
        this.scale = 1;
        this.last = this.start = {
            scale: 1
        };
        this.callback("MSstart", [c, this.start]);
        a = !this.stopDown;
        SuperMap.Event.stop(c);
        return a
    },
    MSGestureChange: function(a) {
        if (a.scale === 1) {
            return
        }
        this.map.isIESingleTouch = false;
        if (this.started) {
            this.pinching = true;
            this.scale = a.scale * this.scale;
            var c = {
                scale: this.scale
            };
            this.callback("MSmove", [a, c]);
            this.last = c;
            SuperMap.Event.stop(a)
        }
        return true
    },
    MSGestureEnd: function(a) {
        if (this.started) {
            this.started = false;
            this.pinching = false;
            this.callback("MSdone", [a, this.start, this.last]);
            this.start = null;
            this.last = null;
            this.scale = null
        }
        return true
    },
    activate: function() {
        var a = false;
        if (SuperMap.Handler.prototype.activate.apply(this, arguments)) {
            this.pinching = false;
            a = true
        }
        return a
    },
    deactivate: function() {
        var a = false;
        if (SuperMap.Handler.prototype.deactivate.apply(this, arguments)) {
            this.started = false;
            this.pinching = false;
            this.start = null;
            this.last = null;
            this.gesture = null,
            this.flag = 0,
            this.scale = 1,
            a = true
        }
        return a
    },
    getDistance: function(d) {
        var c = d[0];
        var a = d[1];
        if (!a) {
            return 0
        } else {
            return Math.sqrt(Math.pow(c.clientX - a.clientX, 2) + Math.pow(c.clientY - a.clientY, 2))
        }
    },
    getPinchData: function(a) {
        var d = this.getDistance(a.touches);
        var c = d / this.start.distance;
        if (d == 0 || this.start.distance == 0) {
            var c = 1
        } else {
            var c = d / this.start.distance
        }
        return {
            distance: d,
            delta: this.last.distance - d,
            scale: c
        }
    },
    CLASS_NAME: "SuperMap.Handler.Pinch"
});
SuperMap.Handler.RegularPolygon = SuperMap.Class(SuperMap.Handler.Drag, {
    sides: 4,
    radius: null,
    snapAngle: null,
    snapToggle: "shiftKey",
    layerOptions: null,
    persist: false,
    irregular: false,
    angle: null,
    fixedRadius: false,
    feature: null,
    layer: null,
    origin: null,
    initialize: function(d, c, a) {
        if (!(a && a.layerOptions && a.layerOptions.styleMap)) {
            this.style = SuperMap.Util.extend(SuperMap.Feature.Vector.style["default"], {})
        }
        SuperMap.Handler.Drag.prototype.initialize.apply(this, [d, c, a]);
        this.options = (a) ? a : {}
    },
    setOptions: function(a) {
        SuperMap.Util.extend(this.options, a);
        SuperMap.Util.extend(this, a)
    },
    activate: function() {
        var a = false;
        if (SuperMap.Handler.Drag.prototype.activate.apply(this, arguments)) {
            var c = SuperMap.Util.extend({
                displayInLayerSwitcher: false,
                calculateInRange: SuperMap.Function.True
            }, this.layerOptions);
            this.layer = new SuperMap.Layer.Vector(this.CLASS_NAME,c);
            this.map.addLayer(this.layer);
            a = true
        }
        return a
    },
    deactivate: function() {
        var a = false;
        if (SuperMap.Handler.Drag.prototype.deactivate.apply(this, arguments)) {
            if (this.dragging) {
                this.cancel()
            }
            if (this.layer.map != null) {
                this.layer.destroy(false);
                if (this.feature) {
                    this.feature.destroy()
                }
            }
            this.layer = null;
            this.feature = null;
            a = true
        }
        return a
    },
    down: function(a) {
        this.fixedRadius = !!(this.radius);
        var c = this.layer.getLonLatFromViewPortPx(a.xy);
        this.origin = new SuperMap.Geometry.Point(c.lon,c.lat);
        if (!this.fixedRadius || this.irregular) {
            this.radius = this.map.getResolution()
        }
        if (this.persist) {
            this.clear()
        }
        this.feature = new SuperMap.Feature.Vector();
        this.createGeometry();
        this.callback("create", [this.origin, this.feature]);
        this.layer.addFeatures([this.feature], {
            silent: true
        });
        this.layer.drawFeature(this.feature, this.style)
    },
    move: function(d) {
        var g = this.layer.getLonLatFromViewPortPx(d.xy);
        var a = new SuperMap.Geometry.Point(g.lon,g.lat);
        if (this.irregular) {
            var h = Math.sqrt(2) * Math.abs(a.y - this.origin.y) / 2;
            this.radius = Math.max(this.map.getResolution() / 2, h)
        } else {
            if (this.fixedRadius) {
                this.origin = a
            } else {
                this.calculateAngle(a, d);
                this.radius = Math.max(this.map.getResolution() / 2, a.distanceTo(this.origin))
            }
        }
        this.modifyGeometry();
        if (this.irregular) {
            var e = a.x - this.origin.x;
            var c = a.y - this.origin.y;
            var f;
            if (c == 0) {
                f = e / (this.radius * Math.sqrt(2))
            } else {
                f = e / c
            }
            this.feature.geometry.resize(1, this.origin, f);
            this.feature.geometry.move(e / 2, c / 2)
        }
        this.layer.drawFeature(this.feature, this.style)
    },
    up: function(a) {
        this.finalize();
        if (this.start == this.last) {
            this.callback("done", [a.xy])
        }
    },
    out: function(a) {
        this.finalize()
    },
    createGeometry: function() {
        this.angle = Math.PI * ((1 / this.sides) - (1 / 2));
        if (this.snapAngle) {
            this.angle += this.snapAngle * (Math.PI / 180)
        }
        this.feature.geometry = SuperMap.Geometry.Polygon.createRegularPolygon(this.origin, this.radius, this.sides, this.snapAngle)
    },
    modifyGeometry: function() {
        var e, a;
        var c = this.feature.geometry.components[0];
        if (c.components.length != (this.sides + 1)) {
            this.createGeometry();
            c = this.feature.geometry.components[0]
        }
        for (var d = 0; d < this.sides; ++d) {
            a = c.components[d];
            e = this.angle + (d * 2 * Math.PI / this.sides);
            a.x = this.origin.x + (this.radius * Math.cos(e));
            a.y = this.origin.y + (this.radius * Math.sin(e));
            a.clearBounds()
        }
    },
    calculateAngle: function(a, c) {
        var e = Math.atan2(a.y - this.origin.y, a.x - this.origin.x);
        if (this.snapAngle && (this.snapToggle && !c[this.snapToggle])) {
            var d = (Math.PI / 180) * this.snapAngle;
            this.angle = Math.round(e / d) * d
        } else {
            this.angle = e
        }
    },
    cancel: function() {
        this.callback("cancel", null);
        this.finalize()
    },
    finalize: function() {
        this.origin = null;
        this.radius = this.options.radius
    },
    clear: function() {
        if (this.layer) {
            this.layer.renderer.clear();
            this.layer.destroyFeatures()
        }
    },
    callback: function(c, a) {
        if (this.callbacks[c]) {
            this.callbacks[c].apply(this.control, [this.feature.geometry.clone()])
        }
        if (!this.persist && (c == "done" || c == "cancel")) {
            this.clear()
        }
    },
    CLASS_NAME: "SuperMap.Handler.RegularPolygon"
});
SuperMap.Handler.Box = SuperMap.Class(SuperMap.Handler, {
    dragHandler: null,
    boxDivClassName: "smHandlerBoxZoomBox",
    boxOffsets: null,
    cursorCSS: null,
    initialize: function(d, c, a) {
        SuperMap.Handler.prototype.initialize.apply(this, arguments);
        this.dragHandler = new SuperMap.Handler.Drag(this,{
            down: this.startBox,
            move: this.moveBox,
            out: this.removeBox,
            up: this.endBox
        },{
            keyMask: this.keyMask
        });
        if (a && a.cursorCSS) {
            this.cursorCSS = a.cursorCSS
        }
    },
    destroy: function() {
        SuperMap.Handler.prototype.destroy.apply(this, arguments);
        if (this.dragHandler) {
            this.dragHandler.destroy();
            this.dragHandler = null
        }
    },
    setMap: function(a) {
        SuperMap.Handler.prototype.setMap.apply(this, arguments);
        if (this.dragHandler) {
            this.dragHandler.setMap(a)
        }
    },
    startBox: function(a) {
        this.callback("start", []);
        this.zoomBox = SuperMap.Util.createDiv("zoomBox", {
            x: -9999,
            y: -9999
        });
        this.zoomBox.className = this.boxDivClassName;
        this.zoomBox.style.zIndex = this.map.Z_INDEX_BASE.Popup - 1;
        this.map.eventsDiv.appendChild(this.zoomBox);
        SuperMap.Element.addClass(this.map.eventsDiv, "smDrawBox");
        if (this.cursorCSS) {
            this.map.eventsDiv.style.cursor = this.cursorCSS
        }
    },
    moveBox: function(f) {
        var e = this.dragHandler.start.x;
        var c = this.dragHandler.start.y;
        var d = Math.abs(e - f.x);
        var a = Math.abs(c - f.y);
        var g = this.getBoxOffsets();
        this.zoomBox.style.width = (d + g.width + 1) + "px";
        this.zoomBox.style.height = (a + g.height + 1) + "px";
        this.zoomBox.style.left = (f.x < e ? e - d - g.left : e - g.left) + "px";
        this.zoomBox.style.top = (f.y < c ? c - a - g.top : c - g.top) + "px"
    },
    endBox: function(c) {
        var a;
        if (Math.abs(this.dragHandler.start.x - c.x) > 5 || Math.abs(this.dragHandler.start.y - c.y) > 5) {
            var h = this.dragHandler.start;
            var g = Math.min(h.y, c.y);
            var d = Math.max(h.y, c.y);
            var f = Math.min(h.x, c.x);
            var e = Math.max(h.x, c.x);
            a = new SuperMap.Bounds(f,d,e,g)
        } else {
            a = this.dragHandler.start.clone()
        }
        this.removeBox();
        if (this.cursorCSS) {
            this.map.eventsDiv.style.cursor = "default"
        }
        this.callback("done", [a])
    },
    removeBox: function() {
        this.map.eventsDiv.removeChild(this.zoomBox);
        this.zoomBox = null;
        this.boxOffsets = null;
        SuperMap.Element.removeClass(this.map.eventsDiv, "smDrawBox")
    },
    activate: function() {
        if (SuperMap.Handler.prototype.activate.apply(this, arguments)) {
            this.dragHandler.activate();
            return true
        } else {
            return false
        }
    },
    deactivate: function() {
        if (SuperMap.Handler.prototype.deactivate.apply(this, arguments)) {
            if (this.dragHandler.deactivate()) {
                if (this.zoomBox) {
                    this.removeBox()
                }
            }
            return true
        } else {
            return false
        }
    },
    getBoxOffsets: function() {
        if (!this.boxOffsets) {
            var e = document.createElement("div");
            e.style.position = "absolute";
            e.style.border = "1px solid black";
            e.style.width = "3px";
            document.body.appendChild(e);
            var a = e.clientWidth == 3;
            document.body.removeChild(e);
            var g = parseInt(SuperMap.Element.getStyle(this.zoomBox, "border-left-width"));
            var d = parseInt(SuperMap.Element.getStyle(this.zoomBox, "border-right-width"));
            var f = parseInt(SuperMap.Element.getStyle(this.zoomBox, "border-top-width"));
            var c = parseInt(SuperMap.Element.getStyle(this.zoomBox, "border-bottom-width"));
            this.boxOffsets = {
                left: g,
                right: d,
                top: f,
                bottom: c,
                width: a === false ? g + d : 0,
                height: a === false ? f + c : 0
            }
        }
        return this.boxOffsets
    },
    CLASS_NAME: "SuperMap.Handler.Box"
});
SuperMap.Handler.MouseWheel = SuperMap.Class(SuperMap.Handler, {
    wheelListener: null,
    mousePosition: null,
    interval: 0,
    delta: 0,
    cumulative: true,
    initialize: function(d, c, a) {
        SuperMap.Handler.prototype.initialize.apply(this, arguments);
        this.wheelListener = SuperMap.Function.bindAsEventListener(this.onWheelEvent, this)
    },
    destroy: function() {
        SuperMap.Handler.prototype.destroy.apply(this, arguments);
        this.wheelListener = null
    },
    onWheelEvent: function(l) {
        if (!this.map || !this.checkModifiers(l)) {
            return
        }
        var h = false;
        var n = false;
        var g = false;
        var c = SuperMap.Event.element(l);
        while ((c != null) && !g && !h) {
            if (!h) {
                try {
                    if (c.currentStyle) {
                        d = c.currentStyle.overflow
                    } else {
                        var a = document.defaultView.getComputedStyle(c, null);
                        var d = a.getPropertyValue("overflow")
                    }
                    h = (d && (d == "auto") || (d == "scroll"))
                } catch (f) {}
            }
            if (!n) {
                for (var j = 0, k = this.map.layers.length; j < k; j++) {
                    if (c == this.map.layers[j].div || c == this.map.layers[j].pane) {
                        n = true;
                        break
                    }
                }
            }
            g = (c == this.map.div);
            c = c.parentNode
        }
        if (!h && g) {
            if (n) {
                var m = 0;
                if (!l) {
                    l = window.event
                }
                if (l.wheelDelta) {
                    m = l.wheelDelta / 120;
                    if (window.opera && window.opera.version() < 9.2) {
                        m = -m
                    }
                } else {
                    if (l.detail) {
                        m = -l.detail / 3
                    }
                }
                this.delta = this.delta + m;
                if (this.interval) {
                    window.clearTimeout(this._timeoutId);
                    this._timeoutId = window.setTimeout(SuperMap.Function.bind(function() {
                        this.wheelZoom(l)
                    }, this), this.interval)
                } else {
                    this.wheelZoom(l)
                }
            }
            SuperMap.Event.stop(l)
        }
    },
    wheelZoom: function(a) {
        var c = this.delta;
        this.delta = 0;
        if (c) {
            if (this.mousePosition) {
                a.xy = this.mousePosition
            }
            if (!a.xy) {
                a.xy = this.map.getPixelFromLonLat(this.map.getCenter())
            }
            if (c < 0) {
                this.callback("down", [a, this.cumulative ? c : -1])
            } else {
                this.callback("up", [a, this.cumulative ? c : 1])
            }
        }
    },
    mousemove: function(a) {
        this.mousePosition = a.xy
    },
    activate: function(a) {
        if (SuperMap.Handler.prototype.activate.apply(this, arguments)) {
            var c = this.wheelListener;
            SuperMap.Event.observe(window, "DOMMouseScroll", c);
            SuperMap.Event.observe(window, "mousewheel", c);
            SuperMap.Event.observe(document, "mousewheel", c);
            return true
        } else {
            return false
        }
    },
    deactivate: function(a) {
        if (SuperMap.Handler.prototype.deactivate.apply(this, arguments)) {
            var c = this.wheelListener;
            SuperMap.Event.stopObserving(window, "DOMMouseScroll", c);
            SuperMap.Event.stopObserving(window, "mousewheel", c);
            SuperMap.Event.stopObserving(document, "mousewheel", c);
            return true
        } else {
            return false
        }
    },
    CLASS_NAME: "SuperMap.Handler.MouseWheel"
});
SuperMap.Handler.Keyboard = SuperMap.Class(SuperMap.Handler, {
    KEY_EVENTS: ["keydown", "keyup"],
    eventListener: null,
    initialize: function(d, c, a) {
        SuperMap.Handler.prototype.initialize.apply(this, arguments);
        this.eventListener = SuperMap.Function.bindAsEventListener(this.handleKeyEvent, this)
    },
    destroy: function() {
        this.deactivate();
        this.eventListener = null;
        SuperMap.Handler.prototype.destroy.apply(this, arguments)
    },
    activate: function() {
        if (SuperMap.Handler.prototype.activate.apply(this, arguments)) {
            for (var c = 0, a = this.KEY_EVENTS.length; c < a; c++) {
                SuperMap.Event.observe(document, this.KEY_EVENTS[c], this.eventListener)
            }
            return true
        } else {
            return false
        }
    },
    deactivate: function() {
        var d = false;
        if (SuperMap.Handler.prototype.deactivate.apply(this, arguments)) {
            for (var c = 0, a = this.KEY_EVENTS.length; c < a; c++) {
                SuperMap.Event.stopObserving(document, this.KEY_EVENTS[c], this.eventListener)
            }
            d = true
        }
        return d
    },
    handleKeyEvent: function(a) {
        if (this.checkModifiers(a)) {
            this.callback(a.type, [a])
        }
    },
    CLASS_NAME: "SuperMap.Handler.Keyboard"
});
SuperMap.Control = SuperMap.Class({
    id: null,
    map: null,
    div: null,
    type: null,
    allowSelection: false,
    displayClass: "",
    title: "",
    autoActivate: false,
    active: null,
    handler: null,
    eventListeners: null,
    events: null,
    EVENT_TYPES: ["activate", "deactivate"],
    initialize: function(a) {
        this.displayClass = this.CLASS_NAME.replace("SuperMap.", "sm").replace(/\./g, "");
        SuperMap.Util.extend(this, a);
        this.events = new SuperMap.Events(this,null,this.EVENT_TYPES);
        if (this.eventListeners instanceof Object) {
            this.events.on(this.eventListeners)
        }
        if (this.id == null) {
            this.id = SuperMap.Util.createUniqueID(this.CLASS_NAME + "_")
        }
    },
    destroy: function() {
        if (this.events) {
            if (this.eventListeners) {
                this.events.un(this.eventListeners)
            }
            this.events.destroy();
            this.events = null
        }
        this.eventListeners = null;
        if (this.handler) {
            this.handler.destroy();
            this.handler = null
        }
        if (this.handlers) {
            for (var a in this.handlers) {
                if (this.handlers.hasOwnProperty(a) && typeof this.handlers[a].destroy == "function") {
                    this.handlers[a].destroy()
                }
            }
            this.handlers = null
        }
        if (this.map) {
            this.map.removeControl(this);
            this.map = null
        }
        this.div = null
    },
    setMap: function(a) {
        this.map = a;
        if (this.handler) {
            this.handler.setMap(a)
        }
    },
    draw: function(a) {
        if (this.div == null) {
            this.div = SuperMap.Util.createDiv(this.id);
            this.div.className = this.displayClass;
            if (!this.allowSelection) {
                this.div.className += " smControlNoSelect";
                this.div.setAttribute("unselectable", "on", 0);
                this.div.onselectstart = SuperMap.Function.False
            }
            if (this.title != "") {
                this.div.title = this.title
            }
        }
        if (a != null) {
            this.position = a.clone()
        }
        this.moveTo(this.position);
        return this.div
    },
    moveTo: function(a) {
        if ((a != null) && (this.div != null)) {
            this.div.style.left = a.x + "px";
            this.div.style.top = a.y + "px"
        }
    },
    activate: function() {
        if (this.active) {
            return false
        }
        if (this.handler) {
            this.handler.activate()
        }
        this.active = true;
        if (this.map) {
            SuperMap.Element.addClass(this.map.viewPortDiv, this.displayClass.replace(/ /g, "") + "Active")
        }
        this.events.triggerEvent("activate");
        return true
    },
    deactivate: function() {
        if (this.active) {
            if (this.handler) {
                this.handler.deactivate()
            }
            this.active = false;
            if (this.map) {
                SuperMap.Element.removeClass(this.map.viewPortDiv, this.displayClass.replace(/ /g, "") + "Active")
            }
            this.events.triggerEvent("deactivate");
            return true
        }
        return false
    },
    CLASS_NAME: "SuperMap.Control"
});
SuperMap.Control.TYPE_BUTTON = 1;
SuperMap.Control.TYPE_TOGGLE = 2;
SuperMap.Control.TYPE_TOOL = 3;
SuperMap.Control.ZoomBox = SuperMap.Class(SuperMap.Control, {
    type: SuperMap.Control.TYPE_TOOL,
    out: false,
    keyMask: null,
    handlerOptions: null,
    alwaysZoom: false,
    initialize: function(c, a) {
        SuperMap.Control.prototype.initialize.apply(this, arguments);
        if (a) {
            this.handlerOptions = a
        }
    },
    draw: function() {
        var a = SuperMap.Util.extend({
            keyMask: this.keyMask
        }, this.handlerOptions);
        this.handler = new SuperMap.Handler.Box(this,{
            done: this.zoomBox
        },a)
    },
    zoomBox: function(i) {
        if (i instanceof SuperMap.Bounds) {
            var c;
            if (!this.out) {
                var j = this.map.getLonLatFromPixel({
                    x: i.left,
                    y: i.bottom
                });
                var n = this.map.getLonLatFromPixel({
                    x: i.right,
                    y: i.top
                });
                c = new SuperMap.Bounds(j.lon,j.lat,n.lon,n.lat)
            } else {
                var h = Math.abs(i.right - i.left);
                var k = Math.abs(i.top - i.bottom);
                var f = Math.min((this.map.size.h / k), (this.map.size.w / h));
                var o = this.map.getExtent();
                var a = this.map.getLonLatFromPixel(i.getCenterPixel());
                var d = a.lon - (o.getWidth() / 2) * f;
                var g = a.lon + (o.getWidth() / 2) * f;
                var m = a.lat - (o.getHeight() / 2) * f;
                var e = a.lat + (o.getHeight() / 2) * f;
                c = new SuperMap.Bounds(d,m,g,e)
            }
            var l = this.map.getZoom();
            this.map.zoomToExtent(c);
            if (l == this.map.getZoom() && this.alwaysZoom == true) {
                this.map.zoomTo(l + (this.out ? -1 : 1))
            }
        } else {
            if (!this.out) {
                this.map.setCenter(this.map.getLonLatFromPixel(i), this.map.getZoom() + 1)
            } else {
                this.map.setCenter(this.map.getLonLatFromPixel(i), this.map.getZoom() - 1)
            }
        }
    },
    CLASS_NAME: "SuperMap.Control.ZoomBox"
});
SuperMap.Control.DragPan = SuperMap.Class(SuperMap.Control, {
    type: SuperMap.Control.TYPE_TOOL,
    panned: false,
    interval: 1,
    documentDrag: false,
    kinetic: null,
    enableKinetic: false,
    kineticInterval: 10,
    draw: function() {
        if (this.enableKinetic) {
            var a = {
                interval: this.kineticInterval
            };
            if (typeof this.enableKinetic === "object") {
                a = SuperMap.Util.extend(a, this.enableKinetic)
            }
            this.kinetic = new SuperMap.Kinetic(a)
        }
        this.handler = new SuperMap.Handler.Drag(this,{
            move: this.panMap,
            done: this.panMapDone,
            down: this.panMapStart
        },{
            interval: this.interval,
            documentDrag: this.documentDrag
        })
    },
    panMapStart: function() {
        if (this.kinetic && this.map.isIESingleTouch) {
            this.kinetic.begin()
        }
    },
    panMap: function(a) {
        if (!this.map.isIESingleTouch) {
            return
        }
        if (this.kinetic) {
            this.kinetic.update(a)
        }
        this.panned = true;
        this.map.pan(this.handler.last.x - a.x, this.handler.last.y - a.y, {
            dragging: true,
            animate: false
        })
    },
    panMapDone: function(d) {
        if (!this.map.isIESingleTouch) {
            return
        }
        if (this.panned) {
            var c = null;
            if (this.kinetic) {
                c = this.kinetic.end(d)
            }
            this.map.pan(this.handler.last.x - d.x, this.handler.last.y - d.y, {
                dragging: !!c,
                animate: false
            });
            if (c) {
                var a = this;
                this.kinetic.move(c, function(e, g, f) {
                    a.map.pan(e, g, {
                        dragging: !f,
                        animate: false
                    })
                })
            }
            this.panned = false
        }
    },
    CLASS_NAME: "SuperMap.Control.DragPan"
});
SuperMap.Control.Navigation = SuperMap.Class(SuperMap.Control, {
    dragPan: null,
    dragPanOptions: null,
    pinchZoom: null,
    pinchZoomOptions: null,
    documentDrag: false,
    zoomBox: null,
    zoomBoxEnabled: true,
    zoomWheelEnabled: true,
    mouseWheelOptions: null,
    handleRightClicks: false,
    zoomBoxKeyMask: SuperMap.Handler.MOD_SHIFT,
    autoActivate: true,
    initialize: function(a) {
        this.handlers = {};
        SuperMap.Control.prototype.initialize.apply(this, arguments)
    },
    destroy: function() {
        this.deactivate();
        if (this.dragPan) {
            this.dragPan.destroy()
        }
        this.dragPan = null;
        if (this.zoomBox) {
            this.zoomBox.destroy()
        }
        this.zoomBox = null;
        if (this.pinchZoom) {
            this.pinchZoom.destroy()
        }
        this.pinchZoom = null;
        SuperMap.Control.prototype.destroy.apply(this, arguments)
    },
    activate: function() {
        this.dragPan.activate();
        if (this.zoomWheelEnabled) {
            this.handlers.wheel.activate()
        }
        this.handlers.click.activate();
        if (this.zoomBoxEnabled) {
            this.zoomBox.activate()
        }
        if (this.pinchZoom) {
            this.pinchZoom.activate()
        }
        return SuperMap.Control.prototype.activate.apply(this, arguments)
    },
    deactivate: function() {
        if (this.pinchZoom) {
            this.pinchZoom.deactivate()
        }
        this.zoomBox.deactivate();
        this.dragPan.deactivate();
        this.handlers.click.deactivate();
        this.handlers.wheel.deactivate();
        return SuperMap.Control.prototype.deactivate.apply(this, arguments)
    },
    draw: function() {
        if (this.handleRightClicks) {
            this.map.viewPortDiv.oncontextmenu = SuperMap.Function.False
        }
        var a = {
            click: this.defaultClick,
            dblclick: this.defaultDblClick,
            dblrightclick: this.defaultDblRightClick
        };
        var c = {
            "double": true,
            stopDouble: true
        };
        this.handlers.click = new SuperMap.Handler.Click(this,a,c);
        this.dragPan = new SuperMap.Control.DragPan(SuperMap.Util.extend({
            map: this.map,
            documentDrag: this.documentDrag
        }, this.dragPanOptions));
        this.zoomBox = new SuperMap.Control.ZoomBox({
            map: this.map,
            keyMask: this.zoomBoxKeyMask
        });
        this.dragPan.draw();
        this.zoomBox.draw();
        this.handlers.wheel = new SuperMap.Handler.MouseWheel(this,{
            up: this.wheelUp,
            down: this.wheelDown
        },this.mouseWheelOptions);
        if (SuperMap.Control.PinchZoom) {
            this.pinchZoom = new SuperMap.Control.PinchZoom(SuperMap.Util.extend({
                map: this.map
            }, this.pinchZoomOptions))
        }
    },
    defaultClick: function(a) {
        if (a.lastTouches && a.lastTouches.length == 2) {
            this.map.zoomOut()
        }
    },
    defaultDblClick: function(c) {
        var a = this.map.getLonLatFromViewPortPx(c.xy);
        this.map.setCenter(a, this.map.zoom + 1)
    },
    defaultDblRightClick: function(c) {
        var a = this.map.getLonLatFromViewPortPx(c.xy);
        this.map.setCenter(a, this.map.zoom - 1)
    },
    wheelChange: function(j, d) {
        var i = this.map.getZoom();
        var g = this.map.getZoom() + Math.round(d);
        g = Math.max(g, 0);
        g = Math.min(g, this.map.getNumZoomLevels());
        if (g === i) {
            return
        }
        var k = this.map.getSize();
        var f = k.w / 2 - j.xy.x;
        var e = j.xy.y - k.h / 2;
        var h = this.map.baseLayer.getResolutionForZoom(g);
        var a = this.map.getLonLatFromPixel(j.xy);
        var c = new SuperMap.LonLat(a.lon + f * h,a.lat + e * h);
        this.map.setCenter(c, g)
    },
    wheelUp: function(a, c) {
        this.wheelChange(a, c || 1)
    },
    wheelDown: function(a, c) {
        this.wheelChange(a, c || -1)
    },
    disableZoomBox: function() {
        this.zoomBoxEnabled = false;
        this.zoomBox.deactivate()
    },
    enableZoomBox: function() {
        this.zoomBoxEnabled = true;
        if (this.active) {
            this.zoomBox.activate()
        }
    },
    disableZoomWheel: function() {
        this.zoomWheelEnabled = false;
        this.handlers.wheel.deactivate()
    },
    enableZoomWheel: function() {
        this.zoomWheelEnabled = true;
        if (this.active) {
            this.handlers.wheel.activate()
        }
    },
    CLASS_NAME: "SuperMap.Control.Navigation"
});
SuperMap.Control.PinchZoom = SuperMap.Class(SuperMap.Control, {
    type: SuperMap.Control.TYPE_TOOL,
    containerOrigin: null,
    pinchOrigin: null,
    currentCenter: null,
    autoActivate: true,
    initialize: function(a) {
        SuperMap.Control.prototype.initialize.apply(this, arguments);
        this.handler = new SuperMap.Handler.Pinch(this,{
            start: this.pinchStart,
            move: this.pinchMove,
            done: this.pinchDone,
            MSstart: this.pinchStart,
            MSmove: this.pinchMove,
            MSdone: this.pinchDone
        },this.handlerOptions)
    },
    activate: function() {
        var a = SuperMap.Control.prototype.activate.apply(this, arguments);
        if (a) {
            this.map.events.on({
                moveend: this.updateContainerOrigin,
                scope: this
            });
            this.updateContainerOrigin()
        }
        return a
    },
    deactivate: function() {
        var a = SuperMap.Control.prototype.deactivate.apply(this, arguments);
        if (this.map && this.map.events) {
            this.map.events.un({
                moveend: this.updateContainerOrigin,
                scope: this
            })
        }
        return a
    },
    updateContainerOrigin: function() {
        var a = this.map.layerContainerDiv;
        this.containerOrigin = {
            x: parseInt(a.style.left, 10),
            y: parseInt(a.style.top, 10)
        };
        this.containerOriginCanvas = {
            x: parseInt(0, 10),
            y: parseInt(0, 10)
        }
    },
    pinchStart: function(a, c) {
        this.pinchOrigin = a.xy;
        this.currentCenter = a.xy
    },
    pinchMove: function(i, d) {
        var e = d.scale;
        var j = this.containerOrigin;
        var g = this.containerOriginCanvas;
        var a = this.pinchOrigin;
        var h = i.xy;
        var l = Math.round((h.x - a.x) + (e - 1) * (j.x - a.x));
        var k = Math.round((h.y - a.y) + (e - 1) * (j.y - a.y));
        var f = Math.round((h.x - a.x) + (e - 1) * (g.x - a.x));
        var c = Math.round((h.y - a.y) + (e - 1) * (g.y - a.y));
        this.applyTransform("translate(" + l + "px, " + k + "px) scale(" + e + ")");
        this.applyTransformCanvas("translate(" + f + "px, " + c + "px) scale(" + e + ")");
        this.currentCenter = h
    },
    applyTransform: function(a) {
        var c = this.map.layerContainerDiv.style;
        c["-webkit-transform"] = a;
        c["-moz-transform"] = a;
        c["-ms-transform"] = a;
        c.transform = a
    },
    applyTransformCanvas: function(c) {
        var a = this.map.layerContainerDivCanvas.style;
        a["-webkit-transform"] = c;
        a["-moz-transform"] = c;
        a["-ms-transform"] = c;
        a.transform = c
    },
    pinchDone: function(c, i, h) {
        this.applyTransform("");
        this.applyTransformCanvas("");
        if (c.type === "MSGestureEnd") {
            this.map.isIEMultipTouch = true;
            this.map.ratio = h.scale
        }
        var g = this.map.getZoomForResolution(this.map.getResolution() / h.scale, true);
        if (g !== this.map.getZoom() || !this.currentCenter.equals(this.pinchOrigin)) {
            var e = this.map.getResolutionForZoom(g);
            var a = this.map.getLonLatFromPixel(this.pinchOrigin);
            var d = this.currentCenter;
            var f = this.map.getSize();
            a.lon += e * ((f.w / 2) - d.x);
            a.lat -= e * ((f.h / 2) - d.y);
            this.map.setCenter(a, g);
            this.map.isIEMultipTouch = false;
            this.map.isIESingleTouch = true
        }
    },
    CLASS_NAME: "SuperMap.Control.PinchZoom"
});
SuperMap.Control.TouchNavigation = SuperMap.Class(SuperMap.Control, {
    dragPan: null,
    dragPanOptions: null,
    pinchZoom: null,
    pinchZoomOptions: null,
    clickHandlerOptions: null,
    documentDrag: false,
    autoActivate: true,
    initialize: function(a) {
        this.handlers = {};
        SuperMap.Control.prototype.initialize.apply(this, arguments)
    },
    destroy: function() {
        this.deactivate();
        if (this.dragPan) {
            this.dragPan.destroy()
        }
        this.dragPan = null;
        if (this.pinchZoom) {
            this.pinchZoom.destroy();
            delete this.pinchZoom
        }
        SuperMap.Control.prototype.destroy.apply(this, arguments)
    },
    activate: function() {
        if (SuperMap.Control.prototype.activate.apply(this, arguments)) {
            this.dragPan.activate();
            this.handlers.click.activate();
            this.pinchZoom.activate();
            return true
        }
        return false
    },
    deactivate: function() {
        if (SuperMap.Control.prototype.deactivate.apply(this, arguments)) {
            this.dragPan.deactivate();
            this.handlers.click.deactivate();
            this.pinchZoom.deactivate();
            return true
        }
        return false
    },
    draw: function() {
        var a = {
            click: this.defaultClick,
            dblclick: this.defaultDblClick
        };
        var c = SuperMap.Util.extend({
            "double": true,
            stopDouble: true,
            pixelTolerance: 2
        }, this.clickHandlerOptions);
        this.handlers.click = new SuperMap.Handler.Click(this,a,c);
        this.dragPan = new SuperMap.Control.DragPan(SuperMap.Util.extend({
            map: this.map,
            documentDrag: this.documentDrag
        }, this.dragPanOptions));
        this.dragPan.draw();
        this.pinchZoom = new SuperMap.Control.PinchZoom(SuperMap.Util.extend({
            map: this.map
        }, this.pinchZoomOptions))
    },
    defaultClick: function(a) {
        if (a.lastTouches && a.lastTouches.length == 2) {
            this.map.zoomOut()
        }
    },
    defaultDblClick: function(c) {
        var a = this.map.getLonLatFromViewPortPx(c.xy);
        this.map.setCenter(a, this.map.zoom + 1)
    },
    CLASS_NAME: "SuperMap.Control.TouchNavigation"
});
SuperMap.Control.MousePosition = SuperMap.Class(SuperMap.Control, {
    autoActivate: true,
    element: null,
    prefix: "",
    separator: ", ",
    suffix: "",
    numDigits: 5,
    granularity: 10,
    emptyString: null,
    lastXy: null,
    displayProjection: null,
    destroy: function() {
        this.deactivate();
        SuperMap.Control.prototype.destroy.apply(this, arguments)
    },
    activate: function() {
        if (SuperMap.Control.prototype.activate.apply(this, arguments)) {
            this.map.events.register("mousemove", this, this.redraw);
            this.map.events.register("mouseout", this, this.reset);
            this.redraw();
            return true
        } else {
            return false
        }
    },
    deactivate: function() {
        if (SuperMap.Control.prototype.deactivate.apply(this, arguments)) {
            this.map.events.unregister("mousemove", this, this.redraw);
            this.map.events.unregister("mouseout", this, this.reset);
            this.element.innerHTML = "";
            return true
        } else {
            return false
        }
    },
    draw: function() {
        SuperMap.Control.prototype.draw.apply(this, arguments);
        if (!this.element) {
            this.div.left = "";
            this.div.top = "";
            this.element = this.div
        }
        if (this.position) {
            SuperMap.Element.removeClass(this.div, this.displayClass);
            this.div.style.display = "block";
            this.div.style.position = "absolute";
            this.div.style["font-family"] = "Arial";
            this.div.style["font-size"] = "smaller"
        }
        return this.div
    },
    redraw: function(a) {
        var d;
        if (a == null) {
            this.reset();
            return
        } else {
            if (this.lastXy == null || Math.abs(a.xy.x - this.lastXy.x) > this.granularity || Math.abs(a.xy.y - this.lastXy.y) > this.granularity) {
                this.lastXy = a.xy;
                return
            }
            d = this.map.getLonLatFromPixel(a.xy);
            if (!d) {
                return
            }
            if (this.displayProjection) {
                d.transform(this.map.getProjectionObject(), this.displayProjection)
            }
            this.lastXy = a.xy
        }
        var c = this.formatOutput(d);
        if (c != this.element.innerHTML) {
            this.element.innerHTML = c
        }
    },
    reset: function(a) {
        if (this.emptyString != null) {
            this.element.innerHTML = this.emptyString
        }
    },
    formatOutput: function(c) {
        var d = parseInt(this.numDigits);
        var a = this.prefix + c.lon.toFixed(d) + this.separator + c.lat.toFixed(d) + this.suffix;
        return a
    },
    CLASS_NAME: "SuperMap.Control.MousePosition"
});
SuperMap.Control.OverviewMap = SuperMap.Class(SuperMap.Control, {
    element: null,
    ovmap: null,
    size: {
        w: 180,
        h: 180
    },
    layers: null,
    minRectSize: 8,
    minRectDisplayClass: "RectReplacement",
    minRatio: 24,
    maxRatio: 32,
    mapOptions: null,
    autoPan: true,
    handlers: null,
    resolutionFactor: 1,
    maximized: true,
    initialize: function(e) {
        var a = false, f, d, c;
        this.layers = [];
        this.handlers = {};
        SuperMap.Control.prototype.initialize.apply(this, [e])
    },
    setMap: function(a) {
        SuperMap.Control.prototype.setMap.apply(this, [a]);
        this.map.events.register("changebaselayer", this, this.baseLayerDraw)
    },
    updateLayers: function() {
        if (this.map.baseLayer) {
            var e = this.layers;
            for (var d = 0, a = e.length; d < a; d++) {
                this.ovmap.removeLayer(e[d]);
                this.layers.pop()
            }
            var c = this.map.baseLayer.clone();
            c.isBaseLayer = true;
            this.layers.push(c);
            this.ovmap.addLayers(this.layers);
            this.ovmap.zoomToMaxExtent()
        }
        return false
    },
    destroy: function() {
        if (!this.mapDiv) {
            return
        }
        if (this.handlers.click) {
            this.handlers.click.destroy()
        }
        if (this.handlers.drag) {
            this.handlers.drag.destroy()
        }
        this.ovmap && this.ovmap.eventsDiv.removeChild(this.extentRectangle);
        this.extentRectangle = null;
        if (this.rectEvents) {
            this.rectEvents.destroy();
            this.rectEvents = null
        }
        if (this.ovmap) {
            this.ovmap.destroy();
            this.ovmap = null
        }
        this.element.removeChild(this.mapDiv);
        this.mapDiv = null;
        this.div.removeChild(this.element);
        this.element = null;
        if (this.maximizeDiv) {
            SuperMap.Event.stopObservingElement(this.maximizeDiv);
            this.div.removeChild(this.maximizeDiv);
            this.maximizeDiv = null
        }
        if (this.minimizeDiv) {
            SuperMap.Event.stopObservingElement(this.minimizeDiv);
            this.div.removeChild(this.minimizeDiv);
            this.minimizeDiv = null
        }
        this.map.events.un({
            moveend: this.update,
            changebaselayer: this.baseLayerDraw,
            scope: this
        });
        SuperMap.Control.prototype.destroy.apply(this, arguments)
    },
    draw: function() {
        SuperMap.Control.prototype.draw.apply(this, arguments);
        if (this.ovmap !== null) {
            return this.updateLayers()
        }
        if (!(this.layers.length > 0)) {
            if (this.map.baseLayer) {
                var d = this.map.baseLayer.clone();
                d.isBaseLayer = true;
                this.layers = [d]
            } else {
                return this.div
            }
        }
        if (typeof this.element === "undefined" || this.element === null) {
            this.element = document.createElement("div");
            this.element.className = this.displayClass + "Element";
            this.element.style.display = "none";
            this.mapDiv = document.createElement("div");
            this.mapDiv.style.width = this.size.w + "px";
            this.mapDiv.style.height = this.size.h + "px";
            this.mapDiv.style.position = "relative";
            this.mapDiv.style.overflow = "hidden";
            this.mapDiv.id = SuperMap.Util.createUniqueID("overviewMap");
            this.extentRectangle = document.createElement("div");
            this.extentRectangle.style.position = "absolute";
            this.extentRectangle.style.zIndex = 1000;
            this.extentRectangle.className = this.displayClass + "ExtentRectangle";
            this.element.appendChild(this.mapDiv);
            this.div.appendChild(this.element);
            if (!this.outsideViewport) {
                this.div.className += " " + this.displayClass + "Container";
                imgLocation = SuperMap.Util.getImagesLocation();
                img = imgLocation + "overView.png";
                this.maximizeDiv = SuperMap.Util.createAlphaImageDiv(this.displayClass + "MaximizeButton", null, new SuperMap.Size(15,15), img, "absolute");
                this.maximizeDiv.style.display = "none";
                this.maximizeDiv.className = this.displayClass + "MaximizeButton";
                SuperMap.Event.observe(this.maximizeDiv, "click", SuperMap.Function.bindAsEventListener(this.maximizeControl, this));
                this.div.appendChild(this.maximizeDiv);
                img = SuperMap.Util.getImagesLocation() + "minimize.png";
                this.minimizeDiv = SuperMap.Util.createAlphaImageDiv("SuperMap_Control_minimizeDiv", null, new SuperMap.Size(15,15), img, "absolute");
                this.minimizeDiv.style.display = "none";
                this.minimizeDiv.className = this.displayClass + "MinimizeButton";
                SuperMap.Event.observe(this.minimizeDiv, "click", SuperMap.Function.bindAsEventListener(this.minimizeControl, this));
                this.div.appendChild(this.minimizeDiv);
                var e = ["dblclick", "mousedown"];
                for (var c = 0, a = e.length; c < a; c++) {
                    SuperMap.Event.observe(this.maximizeDiv, e[c], SuperMap.Event.stop);
                    SuperMap.Event.observe(this.minimizeDiv, e[c], SuperMap.Event.stop)
                }
                this.minimizeControl()
            } else {
                this.element.style.display = ""
            }
        }
        if (this.map.getExtent()) {
            this.update()
        }
        this.map.events.register("moveend", this, this.update);
        if (this.maximized) {
            this.maximizeControl()
        }
        return this.div
    },
    baseLayerDraw: function() {
        this.draw()
    },
    rectDrag: function(j) {
        var e = this.handlers.drag.last.x - j.x;
        var c = this.handlers.drag.last.y - j.y;
        if (e != 0 || c != 0) {
            var h = this.rectPxBounds.top;
            var a = this.rectPxBounds.left;
            var f = Math.abs(this.rectPxBounds.getHeight());
            var d = this.rectPxBounds.getWidth();
            var g = Math.max(0, (h - c));
            g = Math.min(g, this.ovmap.size.h - this.hComp - f);
            var i = Math.max(0, (a - e));
            i = Math.min(i, this.ovmap.size.w - this.wComp - d);
            this.setRectPxBounds(new SuperMap.Bounds(i,g + f,i + d,g))
        }
    },
    mapDivClick: function(j) {
        var c = this.rectPxBounds.getCenterPixel();
        var f = j.xy.x - c.x;
        var e = j.xy.y - c.y;
        var h = this.rectPxBounds.top;
        var d = this.rectPxBounds.left;
        var k = Math.abs(this.rectPxBounds.getHeight());
        var a = this.rectPxBounds.getWidth();
        var g = Math.max(0, (h + e));
        g = Math.min(g, this.ovmap.size.h - k);
        var i = Math.max(0, (d + f));
        i = Math.min(i, this.ovmap.size.w - a);
        this.setRectPxBounds(new SuperMap.Bounds(i,g + k,i + a,g));
        this.updateMapToRect()
    },
    maximizeControl: function(a) {
        this.element.style.display = "";
        this.showToggle(false);
        if (a != null) {
            SuperMap.Event.stop(a)
        }
    },
    minimizeControl: function(a) {
        this.element.style.display = "none";
        this.showToggle(true);
        if (a != null) {
            SuperMap.Event.stop(a)
        }
    },
    showToggle: function(a) {
        this.maximizeDiv.style.display = a ? "" : "none";
        this.minimizeDiv.style.display = a ? "none" : ""
    },
    update: function() {
        if (this.ovmap == null) {
            this.createMap()
        }
        if (this.autoPan || !this.isSuitableOverview()) {
            this.updateOverview()
        }
        this.updateRectToMap()
    },
    isSuitableOverview: function() {
        var c = this.map.getExtent();
        var a = this.map.maxExtent;
        var d = new SuperMap.Bounds(Math.max(c.left, a.left),Math.max(c.bottom, a.bottom),Math.min(c.right, a.right),Math.min(c.top, a.top));
        if (this.ovmap.getProjection() != this.map.getProjection()) {
            d = d.transform(this.map.getProjectionObject(), this.ovmap.getProjectionObject())
        }
        var e = this.ovmap.getResolution() / this.map.getResolution();
        return ( (e > this.minRatio) && (e <= this.maxRatio) && (this.ovmap.getExtent().containsBounds(d)))
    },
    updateOverview: function() {
        var d = this.map.getResolution();
        var c = this.ovmap.getResolution();
        var e = c / d;
        if (e > this.maxRatio) {
            c = this.minRatio * d
        } else {
            if (e <= this.minRatio) {
                c = this.maxRatio * d
            }
        }
        var a;
        if (this.ovmap.getProjection() != this.map.getProjection()) {
            a = this.map.center.clone();
            a.transform(this.map.getProjectionObject(), this.ovmap.getProjectionObject())
        } else {
            a = this.map.center
        }
        this.ovmap.setCenter(a, this.ovmap.getZoomForResolution(c * this.resolutionFactor));
        this.updateRectToMap()
    },
    createMap: function() {
        var c = SuperMap.Util.extend({
            controls: [],
            maxResolution: "auto",
            fallThrough: false
        }, this.mapOptions);
        this.ovmap = new SuperMap.Map(this.mapDiv,c);
        this.ovmap.eventsDiv.appendChild(this.extentRectangle);
        SuperMap.Event.stopObserving(window, "unload", this.ovmap.unloadDestroy);
        this.ovmap.addLayers(this.layers);
        this.ovmap.zoomToMaxExtent();
        this.wComp = parseInt(SuperMap.Element.getStyle(this.extentRectangle, "border-left-width")) + parseInt(SuperMap.Element.getStyle(this.extentRectangle, "border-right-width"));
        this.wComp = (this.wComp) ? this.wComp : 2;
        this.hComp = parseInt(SuperMap.Element.getStyle(this.extentRectangle, "border-top-width")) + parseInt(SuperMap.Element.getStyle(this.extentRectangle, "border-bottom-width"));
        this.hComp = (this.hComp) ? this.hComp : 2;
        this.handlers.drag = new SuperMap.Handler.Drag(this,{
            move: this.rectDrag,
            done: this.updateMapToRect
        },{
            map: this.ovmap
        });
        this.handlers.click = new SuperMap.Handler.Click(this,{
            click: this.mapDivClick
        },{
            single: true,
            "double": false,
            stopSingle: true,
            stopDouble: true,
            pixelTolerance: 1,
            map: this.ovmap
        });
        this.handlers.click.activate();
        this.rectEvents = new SuperMap.Events(this,this.extentRectangle,null,true);
        this.rectEvents.register("mouseover", this, function(f) {
            if (!this.handlers.drag.active && !this.map.dragging) {
                this.handlers.drag.activate()
            }
        });
        this.rectEvents.register("mouseout", this, function(f) {
            if (!this.handlers.drag.dragging) {
                this.handlers.drag.deactivate()
            }
        });
        if (this.ovmap.getProjection() != this.map.getProjection()) {
            var d = this.map.getProjectionObject().getUnits() || this.map.units || this.map.baseLayer.units;
            var a = this.ovmap.getProjectionObject().getUnits() || this.ovmap.units || this.ovmap.baseLayer.units;
            this.resolutionFactor = d && a ? SuperMap.INCHES_PER_UNIT[d] / SuperMap.INCHES_PER_UNIT[a] : 1
        }
    },
    updateRectToMap: function() {
        var c;
        if (this.ovmap.getProjection() != this.map.getProjection()) {
            c = this.map.getExtent().transform(this.map.getProjectionObject(), this.ovmap.getProjectionObject())
        } else {
            c = this.map.getExtent()
        }
        var a = this.getRectBoundsFromMapBounds(c);
        if (a) {
            this.setRectPxBounds(a)
        }
    },
    updateMapToRect: function() {
        var a = this.getMapBoundsFromRectBounds(this.rectPxBounds);
        if (this.ovmap.getProjection() != this.map.getProjection()) {
            a = a.transform(this.ovmap.getProjectionObject(), this.map.getProjectionObject())
        }
        this.map.panTo(a.getCenterLonLat())
    },
    setRectPxBounds: function(e) {
        var h = Math.max(e.top, 0);
        var f = Math.max(e.left, 0);
        var c = Math.min(e.top + Math.abs(e.getHeight()), this.ovmap.size.h - this.hComp);
        var i = Math.min(e.left + e.getWidth(), this.ovmap.size.w - this.wComp);
        var d = Math.max(i - f, 0);
        var j = Math.max(c - h, 0);
        if (d < this.minRectSize || j < this.minRectSize) {
            this.extentRectangle.className = this.displayClass + this.minRectDisplayClass;
            var g = f + (d / 2) - (this.minRectSize / 2);
            var a = h + (j / 2) - (this.minRectSize / 2);
            this.extentRectangle.style.top = Math.round(a) + "px";
            this.extentRectangle.style.left = Math.round(g) + "px";
            this.extentRectangle.style.height = this.minRectSize + "px";
            this.extentRectangle.style.width = this.minRectSize + "px"
        } else {
            this.extentRectangle.className = this.displayClass + "ExtentRectangle";
            this.extentRectangle.style.top = Math.round(h) + "px";
            this.extentRectangle.style.left = Math.round(f) + "px";
            this.extentRectangle.style.height = Math.round(j) + "px";
            this.extentRectangle.style.width = Math.round(d) + "px"
        }
        this.rectPxBounds = new SuperMap.Bounds(Math.round(f),Math.round(c),Math.round(i),Math.round(h))
    },
    getRectBoundsFromMapBounds: function(d) {
        var c = this.getOverviewPxFromLonLat({
            lon: d.left,
            lat: d.bottom
        });
        var a = this.getOverviewPxFromLonLat({
            lon: d.right,
            lat: d.top
        });
        var e = null;
        if (c && a) {
            e = new SuperMap.Bounds(c.x,c.y,a.x,a.y)
        }
        return e
    },
    getMapBoundsFromRectBounds: function(c) {
        var a = this.getLonLatFromOverviewPx({
            x: c.left,
            y: c.bottom
        });
        var d = this.getLonLatFromOverviewPx({
            x: c.right,
            y: c.top
        });
        return new SuperMap.Bounds(a.lon,a.lat,d.lon,d.lat)
    },
    getLonLatFromOverviewPx: function(g) {
        var f = this.ovmap.size;
        var e = this.ovmap.getResolution();
        var c = this.ovmap.getExtent().getCenterLonLat();
        var d = g.x - (f.w / 2);
        var a = g.y - (f.h / 2);
        return {
            lon: c.lon + d * e,
            lat: c.lat - a * e
        }
    },
    getOverviewPxFromLonLat: function(d) {
        var a = this.ovmap.getResolution();
        var c = this.ovmap.getExtent();
        if (c) {
            return {
                x: Math.round(1 / a * (d.lon - c.left)),
                y: Math.round(1 / a * (c.top - d.lat))
            }
        }
    },
    CLASS_NAME: "SuperMap.Control.OverviewMap"
});
SuperMap.Control.KeyboardDefaults = SuperMap.Class(SuperMap.Control, {
    autoActivate: true,
    slideFactor: 75,
    draw: function() {
        this.handler = new SuperMap.Handler.Keyboard(this,{
            keydown: this.defaultKeyPress
        })
    },
    defaultKeyPress: function(a) {
        var c, d = true;
        switch (a.keyCode) {
        case SuperMap.Event.KEY_LEFT:
            this.map.pan(-this.slideFactor, 0);
            break;
        case SuperMap.Event.KEY_RIGHT:
            this.map.pan(this.slideFactor, 0);
            break;
        case SuperMap.Event.KEY_UP:
            this.map.pan(0, -this.slideFactor);
            break;
        case SuperMap.Event.KEY_DOWN:
            this.map.pan(0, this.slideFactor);
            break;
        case 33:
            c = this.map.getSize();
            this.map.pan(0, -0.75 * c.h);
            break;
        case 34:
            c = this.map.getSize();
            this.map.pan(0, 0.75 * c.h);
            break;
        case 35:
            c = this.map.getSize();
            this.map.pan(0.75 * c.w, 0);
            break;
        case 36:
            c = this.map.getSize();
            this.map.pan(-0.75 * c.w, 0);
            break;
        case 43:
        case 61:
        case 187:
        case 107:
            this.map.zoomIn();
            break;
        case 45:
        case 109:
        case 189:
        case 95:
            this.map.zoomOut();
            break;
        default:
            d = false
        }
        if (d) {
            SuperMap.Event.stop(a)
        }
    },
    CLASS_NAME: "SuperMap.Control.KeyboardDefaults"
});
SuperMap.Control.PanZoomBar = SuperMap.Class(SuperMap.Control, {
    slideFactor: 50,
    slideRatio: null,
    buttons: null,
    zoomStopWidth: 13,
    zoomStopHeight: 11,
    slider: null,
    szTemp_zoombar: new SuperMap.Size(13,120),
    szTemp_zoombar_center: new SuperMap.Size(1,120),
    sliderEvents: null,
    divEvents: null,
    divEventLevel: null,
    forceFixedZoomLevel: false,
    mouseDragStart: null,
    deltaY: null,
    mapLevel: [],
    divLevel: null,
    zoomStart: null,
    showSlider: false,
    levelsDesc: null,
    initialize: function(l) {
        SuperMap.Control.prototype.initialize.apply(this, arguments);
        var d = false, k = false, j = new SuperMap.Size(17,17), g = new SuperMap.Size(27,27), c = new SuperMap.Size(11,11), a = new SuperMap.Size(63,62), h, f, i, e;
        if (l) {
            this.showSlider = typeof l.showSlider !== "undefined" ? l.showSlider : true
        }
        SuperMap.Control.PanZoomBar.prototype.draw = function(n) {
            SuperMap.Control.prototype.draw.apply(this, arguments);
            n = n || new SuperMap.Pixel(4,4);
            n.y += a.h / 2;
            this.buttons = [];
            i = this.centered;
            i = new SuperMap.Pixel(n.x + a.w / 2,n.y);
            this._addButton("pan", "zoom-maxextent-mini.png", i.add(-a.w / 2 + j.w / 2, -a.h / 2 + j.h / 2), a);
            this._addButton("panup", "", i.add(-a.w / 6 + j.w / 2, -a.h / 2 + j.h / 2), a);
            this._addButton("panleft", "", i.add(-a.w / 2 + j.w / 2, -a.h / 6 + j.h / 2), a);
            this._addButton("panright", "", i.add(a.w / 6 + j.w / 2, -a.h / 6 + j.h / 2), a);
            this._addButton("pandown", "", i.add(-a.w / 6 + j.w / 2, a.w / 6 + j.w / 2), a);
            this._addButton("zoomin", "zoom-plus-mini.png", i.add(-g.w / 2 + j.w / 2, a.h / 2 + j.h / 2 + 10), g);
            this._addButton("zoommaxextent", "zoom-maxextent-mini.png", i, j);
            if (this.showSlider) {
                var m = 120;
                this._addButton("zoomout", "zoom-minus-mini.png", i.add(-g.w / 2 + j.w / 2, a.h / 2 + j.h / 2 + 10 + g.h + m), g);
                this._addZoomBar(i.add(j.w / 2 - this.zoomStopWidth / 2, a.h / 2 + j.h / 2 + 10 + g.h))
            } else {
                this._addButton("zoomout", "zoom-minus-mini.png", i.add(-g.w / 2 + j.w / 2, a.h / 2 + j.h / 2 + 8 + g.h), g)
            }
            return this.div
        }
        ;
        SuperMap.Control.PanZoomBar.prototype._addButton = function(t, n, q, s) {
            h = SuperMap.Util.getImagesLocation() + n;
            if (t == "panup" || t == "panleft" || t == "pandown" || t == "panright") {
                var p = SuperMap.Util.createDiv(this.id + "_" + t, q, "", "", "absolute");
                p.style.width = s.w / 3 + "px";
                p.style.height = s.w / 3 + "px";
                p.style.cursor = "pointer";
                if (!!(window.attachEvent && navigator.userAgent.indexOf("Opera") === -1)) {
                    p.style.backgroundColor = "#4c4c4c";
                    p.style.filter = "alpha(opacity=0)";
                    p.style.opacity = 0
                }
            } else {
                if (t == "pan") {
                    var p = SuperMap.Util.createAlphaImageDiv(this.id + "_" + t, q, s, h, "absolute")
                } else {
                    var p = SuperMap.Util.createAlphaImageDiv(this.id + "_" + t, q, s, h, "absolute");
                    p.style.cursor = "pointer"
                }
            }
            this.div.appendChild(p);
            SuperMap.Event.observe(p, "mousedown", SuperMap.Function.bindAsEventListener(this.buttonDown, p));
            SuperMap.Event.observe(p, "dblclick", SuperMap.Function.bindAsEventListener(this.doubleClick, p));
            SuperMap.Event.observe(p, "click", SuperMap.Function.bindAsEventListener(this.doubleClick, p));
            SuperMap.Event.observe(p, "mouseover", SuperMap.Function.bindAsEventListener(this.btnMouseOver, p));
            SuperMap.Event.observe(p, "mouseout", SuperMap.Function.bindAsEventListener(this.btnMouseOut, p));
            SuperMap.Event.observe(p, "mouseup", SuperMap.Function.bindAsEventListener(this.passEventToSlider, this));
            p.action = t;
            p.id = this.id;
            p.map = this.map;
            if (!this.slideRatio) {
                var o = this.slideFactor;
                var m = function() {
                    return o
                }
            } else {
                var r = this.slideRatio;
                var m = function(u) {
                    return this.map.getSize()[u] * r
                }
            }
            p.getSlideFactor = m;
            this.buttons.push(p);
            return p
        }
        ;
        SuperMap.Control.PanZoomBar.prototype._addZoomBar = function(t) {
            if (this.map.getNumZoomLevels()) {
                this.zoomStopHeight = 109 / (this.map.getNumZoomLevels() - 1)
            }
            h = SuperMap.Util.getImagesLocation();
            var p = null;
            var o = this.id + "_" + this.map.id;
            var x = this.map.getNumZoomLevels() - 1 - this.map.getZoom();
            p = SuperMap.Util.createAlphaImageDiv(o, t.add(this.zoomStopWidth / 2 - 5.5, x * this.zoomStopHeight + 1), c, h + "slider.png", "absolute");
            p.style.cursor = "pointer";
            this.slider = p;
            this.sliderEvents = new SuperMap.Events(this,p,null,true,{
                includeXY: true
            });
            this.sliderEvents.on({
                touchstart: this.zoomBarDown,
                touchmove: this.zoomBarDrag,
                touchend: this.zoomBarUp,
                mousedown: this.zoomBarDown,
                mousemove: this.zoomBarDrag,
                mouseup: this.zoomBarUp,
                dblclick: this.doubleClick,
                click: this.doubleClick
            });
            var w = new SuperMap.Size(c.w,3);
            var y = null;
            if (SuperMap.Util.alphaHack()) {
                var o = this.id + "_" + this.map.id;
                y = SuperMap.Util.createAlphaImageDiv(o, t, new SuperMap.Size(w.w,this.zoomStopHeight), h + "zoombar_glide.png", "absolute", null, "crop");
                y.style.height = w.h + "px"
            } else {
                y = SuperMap.Util.createDiv("SuperMap_Control_PanZoomBar_Zoombar" + this.map.id, t.add(1, 117), w, h + "zoombar_glide.png")
            }
            y.style.cursor = "pointer";
            this.div_zoombar_three = y;
            this.divEvents = new SuperMap.Events(this,y,null,true,{
                includeXY: true
            });
            this.divEvents.on({
                touchmove: this.passEventToSlider,
                mousedown: this.divClick,
                mousemove: this.passEventToSlider,
                dblclick: this.doubleClick,
                click: this.doubleClick
            });
            this.div.appendChild(y);
            var r = null;
            if (SuperMap.Util.alphaHack()) {
                var o = this.id + "_" + this.map.id;
                r = SuperMap.Util.createAlphaImageDiv(o, t, new SuperMap.Size(this.szTemp_zoombar.w,this.zoomStopHeight), h + "zoombar_center.png", "absolute", null, "crop");
                r.style.height = this.szTemp_zoombar.h + "px"
            } else {
                r = SuperMap.Util.createDiv("SuperMap_Control_PanZoomBar_Zoombar" + this.map.id, t.add(this.szTemp_zoombar.w / 2 - this.szTemp_zoombar_center.w / 2, 0), this.szTemp_zoombar_center, h + "zoombar_center.png")
            }
            r.style.cursor = "pointer";
            this.div_zoombar_one = r;
            this.div.appendChild(r);
            var v = null;
            if (SuperMap.Util.alphaHack()) {
                var o = this.id + "_" + this.map.id;
                v = SuperMap.Util.createAlphaImageDiv(o, t, new SuperMap.Size(this.szTemp_zoombar.w,this.zoomStopHeight), h + "zoombar.png", "absolute", null, "crop");
                v.style.height = this.szTemp_zoombar.h + "px"
            } else {
                v = SuperMap.Util.createDiv("SuperMap_Control_PanZoomBar_Zoombar" + this.map.id, t, this.szTemp_zoombar, h + "zoombar.png")
            }
            v.style.cursor = "pointer";
            this.div_zoombar = v;
            this.divEvents = new SuperMap.Events(this,v,null,true,{
                includeXY: true
            });
            if (SuperMap.Browser.device == "pc") {
                this.divEvents.on({
                    touchmove: this.passEventToSlider,
                    mousedown: this.divClick,
                    mousemove: this.passEventToSlider,
                    mouseup: this.passEventToSlider,
                    dblclick: this.doubleClick,
                    click: this.doubleClick,
                    mouseover: this.mouseOverLevel
                })
            } else {
                this.divEvents.on({
                    touchmove: this.passEventToSlider,
                    mousedown: this.divClick,
                    mousemove: this.passEventToSlider,
                    mouseup: this.passEventToSlider,
                    dblclick: this.doubleClick,
                    click: this.doubleClick
                })
            }
            this.div.appendChild(v);
            if (this.map.getNumZoomLevels()) {
                var n = false;
                this.divLevel = SuperMap.Util.createDiv("", t.add(this.zoomStopWidth, 0), new SuperMap.Size(this.zoomStopWidth + 30,120));
                centered_roll_level = t.add(-t.x, -t.y);
                if (!!(window.attachEvent && navigator.userAgent.indexOf("Opera") === -1)) {
                    var m = "url('" + h + "blank.gif')";
                    this.divLevel.style.background = m
                }
                if (SuperMap.Browser.device == "pc") {
                    this.divEventLevel = new SuperMap.Events(this,this.divLevel,null,true,{
                        includeXY: true
                    });
                    this.divEventLevel.on({
                        mouseout: this.mouseOutLevel,
                        mouseover: this.mouseOverLevel,
                        mouseup: this.passEventToSlider
                    })
                }
                var u = new SuperMap.Size(29,21);
                if (l && l.levelsDesc) {
                    this.levelsDesc = l.levelsDesc;
                    var z = null;
                    for (var q = 0, s = this.levelsDesc.levels.length; q < s; q++) {
                        this._buttonLabel(this.divLevel, z, centered_roll_level, this.levelsDesc.imageSources[q], this.levelsDesc.levels[q], u)
                    }
                }
            }
            this.startTop = parseInt(v.style.top);
            this.div.appendChild(p);
            this.moveZoomBar();
            this.map.events.register("zoomend", this, this.moveZoomBar)
        }
    },
    destroy: function() {
        this._removeZoomBar();
        this.map.events.un({
            changebaselayer: this.redraw,
            scope: this
        });
        this.removeButtons();
        this.buttons = null;
        this.position = null;
        SuperMap.Control.prototype.destroy.apply(this, arguments);
        delete this.mouseDragStart;
        delete this.zoomStart
    },
    setMap: function(a) {
        SuperMap.Control.prototype.setMap.apply(this, arguments);
        this.map.events.register("changebaselayer", this, this.redraw)
    },
    redraw: function() {
        if (this.div != null) {
            this.removeButtons();
            this._removeZoomBar();
            if (this.divLevel && this.divLevel.parentNode) {
                this.divLevel.parentNode.removeChild(this.divLevel);
                this.divLevel = null
            }
            this.mapLevel = []
        }
        this.draw()
    },
    _removeZoomBar: function() {
        if (this.showSlider) {
            this.sliderEvents.un({
                touchmove: this.zoomBarDrag,
                mousedown: this.zoomBarDown,
                mousemove: this.zoomBarDrag,
                mouseup: this.zoomBarUp,
                dblclick: this.doubleClick,
                click: this.doubleClick
            });
            this.sliderEvents.destroy();
            this.divEvents.un({
                touchmove: this.passEventToSlider,
                mousedown: this.divClick,
                mousemove: this.passEventToSlider,
                dblclick: this.doubleClick,
                click: this.doubleClick,
                mouseover: this.mouseOverLevel,
                mouseup: this.passEventToSlider
            });
            this.divEvents.destroy();
            this.div.removeChild(this.slider);
            this.div.removeChild(this.div_zoombar_three);
            this.div.removeChild(this.div_zoombar_one);
            this.div.removeChild(this.div_zoombar);
            this.slider = null;
            this.div_zoombar_three = null;
            this.div_zoombar_one = null;
            this.div_zoombar = null
        }
        this.map.events.unregister("zoomend", this, this.moveZoomBar)
    },
    passEventToSlider: function(a) {
        if (this.showSlider) {
            this.sliderEvents.handleBrowserEvent(a)
        }
    },
    divClick: function(a) {
        if (!SuperMap.Event.isLeftClick(a)) {
            return
        }
        var d = a.xy.y / this.zoomStopHeight;
        if (this.forceFixedZoomLevel || !this.map.fractionalZoom) {
            d = Math.floor(d)
        }
        var c = (this.map.getNumZoomLevels() - 1) - d;
        c = Math.min(Math.max(c, 0), this.map.getNumZoomLevels() - 1);
        this.map.zoomTo(c);
        SuperMap.Event.stop(a)
    },
    zoomBarDown: function(a) {
        if (!SuperMap.Event.isLeftClick(a) && !SuperMap.Event.isSingleTouch(a)) {
            return
        }
        this.map.events.on({
            touchmove: this.passEventToSlider,
            mousemove: this.passEventToSlider,
            mouseup: this.passEventToSlider,
            scope: this
        });
        this.mouseDragStart = a.xy.clone();
        this.zoomStart = a.xy.clone();
        this.div_zoombar.offsets = null;
        SuperMap.Event.stop(a)
    },
    zoomBarDrag: function(d) {
        if (this.mouseDragStart != null) {
            var a = this.mouseDragStart.y - d.xy.y;
            var f = SuperMap.Util.pagePosition(this.div_zoombar);
            if ((d.clientY - f[1]) > 5.5 && (d.clientY - f[1]) < parseInt(this.div_zoombar.style.height) - 5.5) {
                var e = parseInt(this.slider.style.top) - a;
                this.slider.style.top = e + "px";
                this.div_zoombar_three.style.top = e + 6 + "px";
                var c = parseInt(this.div_zoombar_three.style.height) + a;
                this.div_zoombar_three.style.height = c + "px";
                this.mouseDragStart = d.xy.clone()
            }
            this.deltaY = this.zoomStart.y - d.xy.y;
            SuperMap.Event.stop(d)
        }
    },
    zoomBarUp: function(a) {
        if (!SuperMap.Event.isLeftClick(a) && a.type !== "touchend") {
            return
        }
        if (this.mouseDragStart) {
            this.div.style.cursor = "";
            this.map.events.un({
                touchmove: this.passEventToSlider,
                mouseup: this.passEventToSlider,
                mousemove: this.passEventToSlider,
                scope: this
            });
            var c = this.map.zoom;
            if (!this.forceFixedZoomLevel && this.map.fractionalZoom) {
                c += this.deltaY / this.zoomStopHeight;
                c = Math.min(Math.max(c, 0), this.map.getNumZoomLevels() - 1)
            } else {
                c += this.deltaY / this.zoomStopHeight;
                c = Math.max(Math.round(c), 0)
            }
            if (c > this.map.getNumZoomLevels() - 1) {
                c = this.map.getNumZoomLevels() - 1
            }
            this.map.zoomTo(c);
            this.mouseDragStart = null;
            this.zoomStart = null;
            this.deltaY = 0;
            SuperMap.Event.stop(a)
        }
    },
    moveZoomBar: function() {
        var a = (this.map.getNumZoomLevels() - 1 - this.map.getZoom()) * this.zoomStopHeight + this.startTop + 1;
        if (isNaN(a)) {
            a = 0
        }
        this.slider.style.top = a + "px";
        this.div_zoombar_three.style.top = a + 6 + "px";
        this.div_zoombar_three.style.height = this.map.getZoom() * this.zoomStopHeight + 4.5 + "px"
    },
    _buttonLabel: function(d, g, h, e, a, i, f) {
        var m = new Array();
        var l = e.lastIndexOf("/")
          , k = e.lastIndexOf(".");
        var j = e.substring(l + 1, k);
        if (SuperMap.Util.alphaHack()) {
            var c = this.id + "_" + this.map.id;
            g = SuperMap.Util.createAlphaImageDiv(c, h.add(0, this.zoomStopHeight * a - 10), i, e, "absolute", null, "crop")
        } else {
            g = SuperMap.Util.createDiv("SuperMap_Control_PanZoomBar_Zoombar" + j, h.add(0, this.zoomStopHeight * a - 3), i, e)
        }
        m[0] = "SuperMap_Control_PanZoomBar_Zoombar" + j;
        m[1] = a;
        this.mapLevel.push(m);
        g.style.cursor = "pointer";
        g.style.display = "none";
        g.className = "sm_" + j;
        this.div_zoom_name = g;
        this.divEvents = new SuperMap.Events(this,g,null,true,{
            includeXY: true
        });
        this.divEvents.on({
            dblclick: this.doubleClickLevel,
            click: this.doubleClickLevel
        });
        d.appendChild(g);
        this.div.appendChild(d)
    },
    doubleClickLevel: function(c) {
        var f, h, g;
        var e = c ? c : window.evt;
        if (e.srcElement) {
            h = e.srcElement
        } else {
            h = e.target
        }
        g = h.id;
        for (var d = 0, a = this.mapLevel.length; d < a; d++) {
            if (this.mapLevel[d][0] == g) {
                f = this.map.getNumZoomLevels() - 1 - this.mapLevel[d][1]
            }
        }
        this.map.zoomTo(f);
        SuperMap.Event.stop(c)
    },
    mouseOverLevel: function(c) {
        for (var d = 0, a = this.mapLevel.length; d < a; d++) {
            if (this.mapLevel[d]) {
                document.getElementById(this.mapLevel[d][0]).style.display = "block"
            }
        }
    },
    mouseOutLevel: function() {
        for (var c = 0, a = this.mapLevel.length; c < a; c++) {
            if (this.mapLevel[c]) {
                document.getElementById(this.mapLevel[c][0]).style.display = "none"
            }
        }
    },
    btnMouseOver: function() {
        var a = SuperMap.Util.getImagesLocation();
        switch (this.action) {
        case "panup":
            document.getElementById(this.id + "_pan_innerImage").src = a + "north-mini.png";
            break;
        case "pandown":
            document.getElementById(this.id + "_pan_innerImage").src = a + "south-mini.png";
            break;
        case "panleft":
            document.getElementById(this.id + "_pan_innerImage").src = a + "west-mini.png";
            break;
        case "panright":
            document.getElementById(this.id + "_pan_innerImage").src = a + "east-mini.png";
            break
        }
    },
    btnMouseOut: function() {
        var a = SuperMap.Util.getImagesLocation();
        switch (this.action) {
        case "panup":
        case "pandown":
        case "panleft":
        case "panright":
            document.getElementById(this.id + "_pan_innerImage").src = a + "zoom-maxextent-mini.png";
            break
        }
    },
    getLinkStyle: function(a, c) {
        if (a.currentStyle) {
            return a.currentStyle[c]
        } else {
            if (window.getComputedStyle) {
                props = c.replace(/([A-Z])/g, "-$1");
                props = c.toLowerCase();
                return document.defaultView.getComputedStyle(a, null)[props]
            }
        }
        return null
    },
    _removeButton: function(a) {
        SuperMap.Event.stopObservingElement(a);
        a.map = null;
        a.getSlideFactor = null;
        this.div.removeChild(a);
        SuperMap.Util.removeItem(this.buttons, a)
    },
    removeButtons: function() {
        for (var a = this.buttons.length - 1; a >= 0; --a) {
            this._removeButton(this.buttons[a])
        }
    },
    doubleClick: function(a) {
        SuperMap.Event.stop(a);
        return false
    },
    buttonDown: function(a) {
        if (!SuperMap.Event.isLeftClick(a)) {
            return
        }
        switch (this.action) {
        case "panup":
            this.map.pan(0, -this.getSlideFactor("h"));
            break;
        case "pandown":
            this.map.pan(0, this.getSlideFactor("h"));
            break;
        case "panleft":
            this.map.pan(-this.getSlideFactor("w"), 0);
            break;
        case "panright":
            this.map.pan(this.getSlideFactor("w"), 0);
            break;
        case "zoomin":
            this.map.zoomIn();
            break;
        case "zoomout":
            this.map.zoomOut();
            break;
        case "zoommaxextent":
            this.map.zoomToMaxExtent();
            break
        }
        SuperMap.Event.stop(a)
    },
    CLASS_NAME: "SuperMap.Control.PanZoomBar"
});
SuperMap.Control.Zoom = SuperMap.Class(SuperMap.Control, {
    zoomInId: "smZoomInLink",
    zoomOutId: "smZoomOutLink",
    body: null,
    draw: function() {
        var g = SuperMap.Control.prototype.draw.apply(this, arguments)
          , c = this.getOrCreateLinks(g)
          , f = c.zoomIn
          , a = c.zoomOut
          , e = this.map.events;
        var d = function(h) {
            return function(i) {
                h.buttonClick(i)
            }
        }(this);
        SuperMap.Event.observe(a.parentNode, "mousedown", SuperMap.Function.bindAsEventListener(d, a.parentNode));
        SuperMap.Event.observe(a.parentNode, "touchstart", SuperMap.Function.bindAsEventListener(d, a.parentNode));
        this.zoomInLink = f;
        this.zoomOutLink = a;
        return g
    },
    getOrCreateLinks: function(e) {
        var f = document.getElementById(this.zoomInId), c = document.getElementById(this.zoomOutId), a, d;
        a = this.body;
        if (!a) {
            a = document.createElement("div");
            e.appendChild(a);
            d = a.style;
            d.left = "10px";
            d.top = "10px";
            d.position = "absolute";
            this.body = a
        }
        if (!f) {
            f = this.createBtn(a, "zoom-plus-mini.png", "smControlZoomIn")
        }
        SuperMap.Element.addClass(f, "smButton");
        if (!c) {
            c = this.createBtn(a, "zoom-minus-mini.png", "smControlZoomOut")
        }
        SuperMap.Element.addClass(c, "smButton");
        return {
            zoomIn: f,
            zoomOut: c
        }
    },
    createBtn: function(h, e, j) {
        var f, i = document, g;
        f = i.createElement("div");
        f.className = j;
        g = f.style;
        g.width = "27px";
        g.height = "27px";
        g.cursor = "pointer";
        h.appendChild(f);
        b = i.createElement("img");
        g = b.style;
        g.width = "27px";
        g.height = "27px";
        b.src = SuperMap.Util.getImagesLocation() + e;
        f.appendChild(b);
        return f
    },
    onZoomClick: function(a) {
        var c = a.buttonElement;
        if (c === this.zoomInLink) {
            this.map.zoomIn()
        } else {
            if (c === this.zoomOutLink) {
                this.map.zoomOut()
            }
        }
    },
    buttonClick: function(a) {
        var e = SuperMap.Event.element(a);
        if (e && (SuperMap.Event.isLeftClick(a) || !~a.type.indexOf("mouse"))) {
            var d = this.getPressedButton(e);
            if (d) {
                var c = {
                    buttonElement: d
                };
                this.onZoomClick(c)
            }
        }
    },
    getPressedButton: function(c) {
        var d = 3, a;
        do {
            if (SuperMap.Element.hasClass(c, "smButton")) {
                a = c;
                break
            }
            c = c.parentNode
        } while (--d > 0 && c);return a
    },
    destroy: function() {
        SuperMap.Event.stopObservingElement(this.zoomInLink);
        SuperMap.Event.stopObservingElement(this.zoomOutLink);
        delete this.zoomInLink;
        delete this.zoomOutLink;
        delete this.body;
        SuperMap.Control.prototype.destroy.apply(this)
    },
    CLASS_NAME: "SuperMap.Control.Zoom"
});
SuperMap.Control.ScaleLine = SuperMap.Class(SuperMap.Control, {
    maxWidth: 100,
    topOutUnits: "km",
    topInUnits: "m",
    bottomOutUnits: "mi",
    bottomInUnits: "ft",
    eTop: null,
    eBottom: null,
    geodesic: false,
    draw: function() {
        SuperMap.Control.prototype.draw.apply(this, arguments);
        if (!this.eTop) {
            this.eTop = document.createElement("div");
            this.eTop.className = this.displayClass + "Top";
            var a = this.topInUnits.length;
            this.div.appendChild(this.eTop);
            if ((this.topOutUnits == "") || (this.topInUnits == "")) {
                this.eTop.style.visibility = "hidden"
            } else {
                this.eTop.style.visibility = "visible"
            }
            this.eBottom = document.createElement("div");
            this.eBottom.className = this.displayClass + "Bottom";
            this.div.appendChild(this.eBottom);
            if ((this.bottomOutUnits == "") || (this.bottomInUnits == "")) {
                this.eBottom.style.visibility = "hidden"
            } else {
                this.eBottom.style.visibility = "visible"
            }
        }
        this.map.events.register("moveend", this, this.update);
        this.update();
        return this.div
    },
    getBarLen: function(c) {
        var e = parseInt(Math.log(c) / Math.log(10));
        var a = Math.pow(10, e);
        var d = parseInt(c / a);
        var f;
        if (d > 5) {
            f = 5
        } else {
            if (d > 2) {
                f = 2
            } else {
                f = 1
            }
        }
        return f * a
    },
    update: function() {
        var k = this.map.getResolution();
        if (!k) {
            return
        }
        var p = this.map.getUnits();
        var f = SuperMap.INCHES_PER_UNIT;
        var m = this.maxWidth * k * f[p];
        var o = 1;
        if (this.geodesic === true) {
            var c = (this.map.getGeodesicPixelSize().w || 0.000001) * this.maxWidth;
            var g = m / f.km;
            o = c / g;
            m *= o
        }
        var a;
        var e;
        if (m > 100000) {
            a = this.topOutUnits;
            e = this.bottomOutUnits
        } else {
            a = this.topInUnits;
            e = this.bottomInUnits
        }
        var i = m / f[a];
        var l = m / f[e];
        var j = this.getBarLen(i);
        var h = this.getBarLen(l);
        i = j / f[p] * f[a];
        l = h / f[p] * f[e];
        var d = i / k / o;
        var n = l / k / o;
        if (this.eBottom.style.visibility == "visible") {
            this.eBottom.style.width = Math.round(n) + "px";
            this.eBottom.innerHTML = h + " " + SuperMap.i18n(e)
        }
        if (this.eTop.style.visibility == "visible") {
            this.eTop.style.width = Math.round(d) + "px";
            this.eTop.innerHTML = j + " " + SuperMap.i18n(a)
        }
    },
    CLASS_NAME: "SuperMap.Control.ScaleLine"
});
SuperMap.Control.LayerSwitcher = SuperMap.Class(SuperMap.Control, {
    layerStates: null,
    layersDiv: null,
    baseLayersDiv: null,
    baseLayers: null,
    dataLbl: null,
    dataLayersDiv: null,
    dataLayers: null,
    minimizeDiv: null,
    maximizeDiv: null,
    ascending: false,
    initialize: function(a) {
        SuperMap.Control.prototype.initialize.apply(this, arguments);
        this.layerStates = []
    },
    destroy: function() {
        this.clearLayersArray("base");
        this.clearLayersArray("data");
        this.map.events.un({
            addlayer: this.redraw,
            changelayer: this.redraw,
            removelayer: this.redraw,
            changebaselayer: this.redraw,
            scope: this
        });
        this.events.unregister("buttonclick", this, this.onButtonClick);
        SuperMap.Control.prototype.destroy.apply(this, arguments)
    },
    setMap: function(a) {
        SuperMap.Control.prototype.setMap.apply(this, arguments);
        this.map.events.on({
            addlayer: this.redraw,
            changelayer: this.redraw,
            removelayer: this.redraw,
            changebaselayer: this.redraw,
            scope: this
        })
    },
    draw: function() {
        SuperMap.Control.prototype.draw.apply(this);
        this.loadContents();
        if (!this.outsideViewport) {
            this.minimizeControl()
        }
        this.redraw();
        return this.div
    },
    clearLayersArray: function(a) {
        this[a + "LayersDiv"].innerHTML = "";
        this[a + "Layers"] = []
    },
    checkRedraw: function() {
        var f = false;
        if (!this.layerStates.length || (this.map.layers.length != this.layerStates.length)) {
            f = true
        } else {
            for (var d = 0, a = this.layerStates.length; d < a; d++) {
                var e = this.layerStates[d];
                var c = this.map.layers[d];
                if ((e.name != c.name) || (e.inRange != c.inRange) || (e.id != c.id) || (e.visibility != c.visibility)) {
                    f = true;
                    break
                }
            }
        }
        return f
    },
    redraw: function() {
        if (!this.checkRedraw()) {
            return this.div
        }
        this.clearLayersArray("base");
        this.clearLayersArray("data");
        var e = false;
        var n = false;
        var j = this.map.layers.length;
        this.layerStates = new Array(j);
        for (var g = 0; g < j; g++) {
            var h = this.map.layers[g];
            this.layerStates[g] = {
                name: h.name,
                visibility: h.visibility,
                inRange: h.inRange,
                id: h.id
            }
        }
        var f = this.map.layers.slice();
        if (!this.ascending) {
            f.reverse()
        }
        for (var g = 0, j = f.length; g < j; g++) {
            var h = f[g];
            var k = h.isBaseLayer;
            if (h.displayInLayerSwitcher) {
                if (k) {
                    n = true
                } else {
                    e = true
                }
                var m = (k) ? (h == this.map.baseLayer) : h.getVisibility();
                var l = document.createElement("input");
                l.id = this.id + "_input_" + h.name;
                l.name = (k) ? this.id + "_baseLayers" : h.name;
                l.type = (k) ? "radio" : "checkbox";
                l.value = h.name;
                l.checked = m;
                l.defaultChecked = m;
                if (!k && !h.inRange) {
                    l.disabled = true
                }
                var a = {
                    inputElem: l,
                    layer: h,
                    layerSwitcher: this
                };
                SuperMap.Event.observe(l, "mouseup", SuperMap.Function.bindAsEventListener(this.onInputClick, a));
                var c = document.createElement("span");
                SuperMap.Element.addClass(c, "labelSpan");
                if (!k && !h.inRange) {
                    c.style.color = "gray"
                }
                c.innerHTML = h.name;
                c.style.verticalAlign = (k) ? "bottom" : "baseline";
                SuperMap.Event.observe(c, "click", SuperMap.Function.bindAsEventListener(this.onInputClick, a));
                var p = document.createElement("br");
                var o = (k) ? this.baseLayers : this.dataLayers;
                o.push({
                    layer: h,
                    inputElem: l,
                    labelSpan: c
                });
                var d = (k) ? this.baseLayersDiv : this.dataLayersDiv;
                d.appendChild(l);
                d.appendChild(c);
                d.appendChild(p)
            }
        }
        this.dataLbl.style.display = (e) ? "" : "none";
        this.baseLbl.style.display = (n) ? "" : "none";
        return this.div
    },
    onInputClick: function(a) {
        if (!this.inputElem.disabled) {
            if (this.inputElem.type == "radio") {
                this.inputElem.checked = true;
                this.layer.map.setBaseLayer(this.layer)
            } else {
                this.inputElem.checked = !this.inputElem.checked;
                this.layerSwitcher.updateMap()
            }
        }
        SuperMap.Event.stop(a)
    },
    onLayerClick: function(a) {
        this.updateMap()
    },
    updateMap: function() {
        for (var c = 0, a = this.baseLayers.length; c < a; c++) {
            var d = this.baseLayers[c];
            if (d.inputElem.checked) {
                this.map.setBaseLayer(d.layer, false)
            }
        }
        for (var c = 0, a = this.dataLayers.length; c < a; c++) {
            var d = this.dataLayers[c];
            d.layer.setVisibility(d.inputElem.checked)
        }
    },
    maximizeControl: function(a) {
        this.div.style.width = "";
        this.div.style.height = "";
        this.div.style.borderWidth = "3px";
        this.showControls(false);
        if (a != null) {
            SuperMap.Event.stop(a)
        }
    },
    minimizeControl: function(a) {
        this.div.style.width = "0px";
        this.div.style.height = "0px";
        this.div.style.borderWidth = "0px";
        this.showControls(true);
        if (a != null) {
            SuperMap.Event.stop(a)
        }
    },
    showControls: function(a) {
        this.maximizeDiv.style.display = a ? "" : "none";
        this.minimizeDiv.style.display = a ? "none" : "";
        this.layersDiv.style.display = a ? "none" : ""
    },
    loadContents: function() {
        SuperMap.Event.observe(this.div, "mouseup", SuperMap.Function.bindAsEventListener(this.mouseUp, this));
        SuperMap.Event.observe(this.div, "click", this.ignoreEvent);
        SuperMap.Event.observe(this.div, "mousedown", SuperMap.Function.bindAsEventListener(this.mouseDown, this));
        SuperMap.Event.observe(this.div, "dblclick", this.ignoreEvent);
        this.layersDiv = document.createElement("div");
        this.layersDiv.id = this.id + "_layersDiv";
        SuperMap.Element.addClass(this.layersDiv, "layersDiv");
        this.baseLbl = document.createElement("div");
        this.baseLbl.innerHTML = SuperMap.i18n("Base Layer");
        SuperMap.Element.addClass(this.baseLbl, "baseLbl");
        this.baseLayersDiv = document.createElement("div");
        SuperMap.Element.addClass(this.baseLayersDiv, "baseLayersDiv");
        this.dataLbl = document.createElement("div");
        this.dataLbl.innerHTML = SuperMap.i18n("Overlays");
        SuperMap.Element.addClass(this.dataLbl, "dataLbl");
        this.dataLayersDiv = document.createElement("div");
        SuperMap.Element.addClass(this.dataLayersDiv, "dataLayersDiv");
        if (this.ascending) {
            this.layersDiv.appendChild(this.baseLbl);
            this.layersDiv.appendChild(this.baseLayersDiv);
            this.layersDiv.appendChild(this.dataLbl);
            this.layersDiv.appendChild(this.dataLayersDiv)
        } else {
            this.layersDiv.appendChild(this.dataLbl);
            this.layersDiv.appendChild(this.dataLayersDiv);
            this.layersDiv.appendChild(this.baseLbl);
            this.layersDiv.appendChild(this.baseLayersDiv)
        }
        this.div.appendChild(this.layersDiv);
        imgLocation = SuperMap.Util.getImagesLocation();
        var c = new SuperMap.Size(24,24);
        img = imgLocation + "layer-switcher-maximize.png";
        this.maximizeDiv = SuperMap.Util.createAlphaImageDiv("SuperMap_Control_MaximizeDiv", null, c, img, "absolute", "2px");
        SuperMap.Element.addClass(this.maximizeDiv, "maximizeDiv");
        this.maximizeDiv.style.display = "none";
        SuperMap.Event.observe(this.maximizeDiv, "click", SuperMap.Function.bindAsEventListener(this.maximizeControl, this));
        this.div.appendChild(this.maximizeDiv);
        img = imgLocation + "layer-switcher-minimize.png";
        var c = new SuperMap.Size(171,24);
        this.minimizeDiv = SuperMap.Util.createAlphaImageDiv("SuperMap_Control_MinimizeDiv", null, c, img, "absolute");
        var a = document.createElement("span");
        a.innerHTML = SuperMap.i18n("LayerSwitcher");
        a.className = "layerSwitcherContent";
        this.minimizeDiv.appendChild(a);
        SuperMap.Element.addClass(this.minimizeDiv, "minimizeDiv");
        this.minimizeDiv.style.display = "none";
        SuperMap.Event.observe(this.minimizeDiv, "click", SuperMap.Function.bindAsEventListener(this.minimizeControl, this));
        this.div.appendChild(this.minimizeDiv)
    },
    ignoreEvent: function(a) {
        SuperMap.Event.stop(a)
    },
    mouseDown: function(a) {
        this.isMouseDown = true;
        this.ignoreEvent(a)
    },
    mouseUp: function(a) {
        if (this.isMouseDown) {
            this.isMouseDown = false;
            this.ignoreEvent(a)
        }
    },
    CLASS_NAME: "SuperMap.Control.LayerSwitcher"
});
SuperMap.Control.DrawFeature = SuperMap.Class(SuperMap.Control, {
    layer: null,
    callbacks: null,
    EVENT_TYPES: ["featureadded"],
    multi: false,
    featureAdded: function() {},
    handlerOptions: null,
    initialize: function(c, d, a) {
        this.EVENT_TYPES = SuperMap.Control.DrawFeature.prototype.EVENT_TYPES.concat(SuperMap.Control.prototype.EVENT_TYPES);
        SuperMap.Control.prototype.initialize.apply(this, [a]);
        this.callbacks = SuperMap.Util.extend({
            done: this.drawFeature,
            modify: function(g, f) {
                this.layer.events.triggerEvent("sketchmodified", {
                    vertex: g,
                    feature: f
                })
            },
            create: function(g, f) {
                this.layer.events.triggerEvent("sketchstarted", {
                    vertex: g,
                    feature: f
                })
            }
        }, this.callbacks);
        this.layer = c;
        this.handlerOptions = this.handlerOptions || {};
        if (!("multi"in this.handlerOptions)) {
            this.handlerOptions.multi = this.multi
        }
        var e = this.layer.styleMap && this.layer.styleMap.styles.temporary;
        if (e) {
            this.handlerOptions.layerOptions = SuperMap.Util.applyDefaults(this.handlerOptions.layerOptions, {
                styleMap: new SuperMap.StyleMap({
                    "default": e
                })
            })
        }
        this.handler = new d(this,this.callbacks,this.handlerOptions)
    },
    drawFeature: function(d) {
        var a = new SuperMap.Feature.Vector(d);
        var c = this.layer.events.triggerEvent("sketchcomplete", {
            feature: a
        });
        if (c !== false) {
            a.state = SuperMap.State.INSERT;
            this.layer.addFeatures([a]);
            this.featureAdded(a);
            this.events.triggerEvent("featureadded", {
                feature: a
            })
        }
    },
    insertXY: function(a, c) {
        if (this.handler && this.handler.line) {
            this.handler.insertXY(a, c)
        }
    },
    insertDeltaXY: function(c, a) {
        if (this.handler && this.handler.line) {
            this.handler.insertDeltaXY(c, a)
        }
    },
    insertDirectionLength: function(c, a) {
        if (this.handler && this.handler.line) {
            this.handler.insertDirectionLength(c, a)
        }
    },
    insertDeflectionLength: function(c, a) {
        if (this.handler && this.handler.line) {
            this.handler.insertDeflectionLength(c, a)
        }
    },
    undo: function() {
        return this.handler.undo && this.handler.undo()
    },
    redo: function() {
        return this.handler.redo && this.handler.redo()
    },
    finishSketch: function() {
        this.handler.finishGeometry()
    },
    cancel: function() {
        this.handler.cancel()
    },
    CLASS_NAME: "SuperMap.Control.DrawFeature"
});
SuperMap.Control.DragFeature = SuperMap.Class(SuperMap.Control, {
    geometryTypes: null,
    onStart: function(c, a) {},
    onDrag: function(c, a) {},
    onComplete: function(c, a) {},
    onEnter: function(a) {},
    onLeave: function(a) {},
    documentDrag: false,
    layer: null,
    feature: null,
    dragCallbacks: {},
    featureCallbacks: {},
    lastPixel: null,
    initialize: function(c, a) {
        SuperMap.Control.prototype.initialize.apply(this, [a]);
        this.layer = c;
        this.handlers = {
            drag: new SuperMap.Handler.Drag(this,SuperMap.Util.extend({
                down: this.downFeature,
                move: this.moveFeature,
                up: this.upFeature,
                out: this.cancel,
                done: this.doneDragging
            }, this.dragCallbacks),{
                documentDrag: this.documentDrag
            }),
            feature: new SuperMap.Handler.Feature(this,this.layer,SuperMap.Util.extend({
                click: this.clickFeature,
                clickout: this.clickoutFeature,
                over: this.overFeature,
                out: this.outFeature
            }, this.featureCallbacks),{
                geometryTypes: this.geometryTypes
            })
        }
    },
    clickFeature: function(a) {
        if (this.handlers.feature.touch && !this.over && this.overFeature(a)) {
            this.handlers.drag.dragstart(this.handlers.feature.evt);
            this.handlers.drag.stopDown = false
        }
    },
    clickoutFeature: function(a) {
        if (this.handlers.feature.touch && this.over) {
            this.outFeature(a);
            this.handlers.drag.stopDown = true
        }
    },
    destroy: function() {
        this.layer = null;
        SuperMap.Control.prototype.destroy.apply(this, [])
    },
    activate: function() {
        return ( this.handlers.feature.activate() && SuperMap.Control.prototype.activate.apply(this, arguments))
    },
    deactivate: function() {
        this.handlers.drag.deactivate();
        this.handlers.feature.deactivate();
        this.feature = null;
        this.dragging = false;
        this.lastPixel = null;
        SuperMap.Element.removeClass(this.map.viewPortDiv, this.displayClass + "Over");
        return SuperMap.Control.prototype.deactivate.apply(this, arguments)
    },
    overFeature: function(c) {
        var a = false;
        if (!this.handlers.drag.dragging) {
            this.feature = c;
            this.handlers.drag.activate();
            a = true;
            this.over = true;
            SuperMap.Element.addClass(this.map.viewPortDiv, this.displayClass + "Over");
            this.onEnter(c)
        } else {
            if (this.feature.id == c.id) {
                this.over = true
            } else {
                this.over = false
            }
        }
        return a
    },
    downFeature: function(a) {
        this.lastPixel = a;
        this.onStart(this.feature, a)
    },
    moveFeature: function(a) {
        var c = this.map.getResolution();
        this.feature.geometry.move(c * (a.x - this.lastPixel.x), c * (this.lastPixel.y - a.y));
        this.layer.drawFeature(this.feature);
        this.lastPixel = a;
        this.onDrag(this.feature, a)
    },
    upFeature: function(a) {
        if (!this.over) {
            this.handlers.drag.deactivate()
        }
    },
    doneDragging: function(a) {
        this.onComplete(this.feature, a)
    },
    outFeature: function(a) {
        if (!this.handlers.drag.dragging) {
            this.over = false;
            this.handlers.drag.deactivate();
            SuperMap.Element.removeClass(this.map.viewPortDiv, this.displayClass + "Over");
            this.onLeave(a);
            this.feature = null
        } else {
            if (this.feature.id == a.id) {
                this.over = false
            }
        }
    },
    cancel: function() {
        this.handlers.drag.deactivate();
        this.over = false
    },
    setMap: function(a) {
        this.handlers.drag.setMap(a);
        this.handlers.feature.setMap(a);
        SuperMap.Control.prototype.setMap.apply(this, arguments)
    },
    CLASS_NAME: "SuperMap.Control.DragFeature"
});
SuperMap.Control.ModifyFeature = SuperMap.Class(SuperMap.Control, {
    EVENT_TYPES: ["beforefeaturemodified", "featuremodified", "afterfeaturemodified"],
    geometryTypes: null,
    clickout: true,
    toggle: true,
    standalone: false,
    layer: null,
    feature: null,
    vertices: null,
    virtualVertices: null,
    selectControl: null,
    dragControl: null,
    handlers: null,
    deleteCodes: null,
    virtualStyle: null,
    vertexRenderIntent: null,
    mode: null,
    modified: false,
    radiusHandle: null,
    dragHandle: null,
    initialize: function(e, d) {
        d = d || {};
        this.layer = e;
        this.vertices = [];
        this.virtualVertices = [];
        this.virtualStyle = SuperMap.Util.extend({}, this.layer.style || this.layer.styleMap.createSymbolizer(null, d.vertexRenderIntent));
        this.virtualStyle.fillOpacity = 0.3;
        this.virtualStyle.strokeOpacity = 0.3;
        this.deleteCodes = [46, 68];
        this.mode = SuperMap.Control.ModifyFeature.RESHAPE;
        SuperMap.Control.prototype.initialize.apply(this, [d]);
        if (!(SuperMap.Util.isArray(this.deleteCodes))) {
            this.deleteCodes = [this.deleteCodes]
        }
        var g = this;
        var a = {
            geometryTypes: this.geometryTypes,
            clickout: this.clickout,
            toggle: this.toggle,
            onBeforeSelect: this.beforeSelectFeature,
            onSelect: this.selectFeature,
            onUnselect: this.unselectFeature,
            scope: this
        };
        if (this.standalone === false) {
            this.selectControl = new SuperMap.Control.SelectFeature(e,a)
        }
        var c = {
            geometryTypes: ["SuperMap.Geometry.Point"],
            snappingOptions: this.snappingOptions,
            onStart: function(i, h) {
                g.dragStart.apply(g, [i, h])
            },
            onDrag: function(i, h) {
                g.dragVertex.apply(g, [i, h])
            },
            onComplete: function(h) {
                g.dragComplete.apply(g, [h])
            },
            featureCallbacks: {
                over: function(h) {
                    if (g.standalone !== true || h._sketch || g.feature === h) {
                        g.dragControl.overFeature.apply(g.dragControl, [h])
                    }
                }
            }
        };
        this.dragControl = new SuperMap.Control.DragFeature(e,c);
        var f = {
            keydown: this.handleKeypress
        };
        this.handlers = {
            keyboard: new SuperMap.Handler.Keyboard(this,f)
        }
    },
    destroy: function() {
        this.layer = null;
        this.standalone || this.selectControl.destroy();
        this.dragControl.destroy();
        SuperMap.Control.prototype.destroy.apply(this, [])
    },
    activate: function() {
        return ( (this.standalone || this.selectControl.activate()) && this.handlers.keyboard.activate() && SuperMap.Control.prototype.activate.apply(this, arguments))
    },
    deactivate: function() {
        var d = false;
        if (SuperMap.Control.prototype.deactivate.apply(this, arguments)) {
            this.layer.removeFeatures(this.vertices, {
                silent: true
            });
            this.layer.removeFeatures(this.virtualVertices, {
                silent: true
            });
            this.vertices = [];
            this.dragControl.deactivate();
            var a = this.feature;
            var c = a && a.geometry && a.layer;
            if (this.standalone === false) {
                if (c) {
                    this.selectControl.unselect.apply(this.selectControl, [a])
                }
                this.selectControl.deactivate()
            } else {
                if (c) {
                    this.unselectFeature(a)
                }
            }
            this.handlers.keyboard.deactivate();
            d = true
        }
        return d
    },
    beforeSelectFeature: function(a) {
        return this.layer.events.triggerEvent("beforefeaturemodified", {
            feature: a
        })
    },
    selectFeature: function(c) {
        if (!this.standalone || this.beforeSelectFeature(c) !== false) {
            this.feature = c;
            this.modified = false;
            this.resetVertices();
            this.dragControl.activate()
        }
        var a = c.modified;
        if (c.geometry && !(a && a.geometry)) {
            this._originalGeometry = c.geometry.clone()
        }
    },
    unselectFeature: function(a) {
        this.layer.removeFeatures(this.vertices, {
            silent: true
        });
        this.vertices = [];
        this.layer.destroyFeatures(this.virtualVertices, {
            silent: true
        });
        this.virtualVertices = [];
        if (this.dragHandle) {
            this.layer.destroyFeatures([this.dragHandle], {
                silent: true
            });
            delete this.dragHandle
        }
        if (this.radiusHandle) {
            this.layer.destroyFeatures([this.radiusHandle], {
                silent: true
            });
            delete this.radiusHandle
        }
        this.feature = null;
        this.dragControl.deactivate();
        this.layer.events.triggerEvent("afterfeaturemodified", {
            feature: a,
            modified: this.modified
        });
        this.modified = false
    },
    dragStart: function(c, a) {
        if (c != this.feature && !c.geometry.parent && c != this.dragHandle && c != this.radiusHandle) {
            if (this.standalone === false && this.feature) {
                this.selectControl.clickFeature.apply(this.selectControl, [this.feature])
            }
            if (this.geometryTypes == null || SuperMap.Util.indexOf(this.geometryTypes, c.geometry.CLASS_NAME) != -1) {
                this.standalone || this.selectControl.clickFeature.apply(this.selectControl, [c]);
                this.dragControl.overFeature.apply(this.dragControl, [c]);
                this.dragControl.lastPixel = a;
                this.dragControl.handlers.drag.started = true;
                this.dragControl.handlers.drag.start = a;
                this.dragControl.handlers.drag.last = a
            }
        }
    },
    dragVertex: function(c, a) {
        this.modified = true;
        if (this.feature.geometry.CLASS_NAME == "SuperMap.Geometry.Point") {
            if (this.feature != c) {
                this.feature = c
            }
            this.layer.events.triggerEvent("vertexmodified", {
                vertex: c.geometry,
                feature: this.feature,
                pixel: a
            })
        } else {
            if (c._index) {
                c.geometry.parent.addComponent(c.geometry, c._index);
                delete c._index;
                SuperMap.Util.removeItem(this.virtualVertices, c);
                this.vertices.push(c)
            } else {
                if (c == this.dragHandle) {
                    this.layer.removeFeatures(this.vertices, {
                        silent: true
                    });
                    this.vertices = [];
                    if (this.radiusHandle) {
                        this.layer.destroyFeatures([this.radiusHandle], {
                            silent: true
                        });
                        this.radiusHandle = null
                    }
                } else {
                    if (c !== this.radiusHandle) {
                        this.layer.events.triggerEvent("vertexmodified", {
                            vertex: c.geometry,
                            feature: this.feature,
                            pixel: a
                        })
                    }
                }
            }
            if (this.virtualVertices.length > 0) {
                this.layer.destroyFeatures(this.virtualVertices, {
                    silent: true
                });
                this.virtualVertices = []
            }
            this.layer.drawFeature(this.feature, this.standalone ? undefined : this.selectControl.renderIntent)
        }
        this.layer.drawFeature(c)
    },
    dragComplete: function(a) {
        this.resetVertices();
        this.setFeatureState();
        this.layer.events.triggerEvent("featuremodified", {
            feature: this.feature
        })
    },
    setFeatureState: function() {
        if (this.feature.state != SuperMap.State.INSERT && this.feature.state != SuperMap.State.DELETE) {
            this.feature.state = SuperMap.State.UPDATE;
            if (this.modified && this._originalGeometry) {
                var a = this.feature;
                a.modified = SuperMap.Util.extend(a.modified, {
                    geometry: this._originalGeometry
                });
                delete this._originalGeometry
            }
        }
    },
    resetVertices: function() {
        if (this.dragControl.feature) {
            this.dragControl.outFeature(this.dragControl.feature)
        }
        if (this.vertices.length > 0) {
            this.layer.removeFeatures(this.vertices, {
                silent: true
            });
            this.vertices = []
        }
        if (this.virtualVertices.length > 0) {
            this.layer.removeFeatures(this.virtualVertices, {
                silent: true
            });
            this.virtualVertices = []
        }
        if (this.dragHandle) {
            this.layer.destroyFeatures([this.dragHandle], {
                silent: true
            });
            this.dragHandle = null
        }
        if (this.radiusHandle) {
            this.layer.destroyFeatures([this.radiusHandle], {
                silent: true
            });
            this.radiusHandle = null
        }
        if (this.feature && this.feature.geometry.CLASS_NAME != "SuperMap.Geometry.Point") {
            if ((this.mode & SuperMap.Control.ModifyFeature.DRAG) ) {
                this.collectDragHandle()
            }
            if ((this.mode & (SuperMap.Control.ModifyFeature.ROTATE | SuperMap.Control.ModifyFeature.RESIZE)) ) {
                this.collectRadiusHandle()
            }
            if (this.mode & SuperMap.Control.ModifyFeature.RESHAPE) {
                if (!(this.mode & SuperMap.Control.ModifyFeature.RESIZE)) {
                    this.collectVertices()
                }
            }
        }
    },
    handleKeypress: function(a) {
        var c = a.keyCode;
        if (this.feature && SuperMap.Util.indexOf(this.deleteCodes, c) != -1) {
            var d = this.dragControl.feature;
            if (d && SuperMap.Util.indexOf(this.vertices, d) != -1 && !this.dragControl.handlers.drag.dragging && d.geometry.parent) {
                d.geometry.parent.removeComponent(d.geometry);
                this.layer.events.triggerEvent("vertexremoved", {
                    vertex: d.geometry,
                    feature: this.feature,
                    pixel: a.xy
                });
                this.layer.drawFeature(this.feature, this.standalone ? undefined : this.selectControl.renderIntent);
                this.modified = true;
                this.resetVertices();
                this.setFeatureState();
                this.layer.events.triggerEvent("featuremodified", {
                    feature: this.feature
                })
            }
        }
    },
    collectVertices: function() {
        this.vertices = [];
        this.virtualVertices = [];
        var a = this;
        function c(j) {
            var e, f, k, g;
            if (j.CLASS_NAME == "SuperMap.Geometry.Point") {
                f = new SuperMap.Feature.Vector(j);
                f._sketch = true;
                f.renderIntent = a.vertexRenderIntent;
                a.vertices.push(f)
            } else {
                var d = j.components.length;
                if (j.CLASS_NAME == "SuperMap.Geometry.LinearRing") {
                    d -= 1
                }
                for (e = 0; e < d; ++e) {
                    k = j.components[e];
                    if (k.CLASS_NAME == "SuperMap.Geometry.Point") {
                        f = new SuperMap.Feature.Vector(k);
                        f._sketch = true;
                        f.renderIntent = a.vertexRenderIntent;
                        a.vertices.push(f)
                    } else {
                        c(k)
                    }
                }
                if (j.CLASS_NAME != "SuperMap.Geometry.MultiPoint") {
                    for (e = 0,
                    g = j.components.length; e < g - 1; ++e) {
                        var n = j.components[e];
                        var o = j.components[e + 1];
                        if (n.CLASS_NAME == "SuperMap.Geometry.Point" && o.CLASS_NAME == "SuperMap.Geometry.Point") {
                            var l = (n.x + o.x) / 2;
                            var h = (n.y + o.y) / 2;
                            var m = new SuperMap.Feature.Vector(new SuperMap.Geometry.Point(l,h),null,a.virtualStyle);
                            m.geometry.parent = j;
                            m._index = e + 1;
                            m._sketch = true;
                            a.virtualVertices.push(m)
                        }
                    }
                }
            }
        }
        c.call(this, this.feature.geometry);
        this.layer.addFeatures(this.virtualVertices, {
            silent: true
        });
        this.layer.addFeatures(this.vertices, {
            silent: true
        })
    },
    collectDragHandle: function() {
        var e = this.feature.geometry;
        var a = e.getBounds().getCenterLonLat();
        var d = new SuperMap.Geometry.Point(a.lon,a.lat);
        var c = new SuperMap.Feature.Vector(d);
        d.move = function(f, g) {
            SuperMap.Geometry.Point.prototype.move.call(this, f, g);
            e.move(f, g)
        }
        ;
        c._sketch = true;
        this.dragHandle = c;
        this.layer.addFeatures([this.dragHandle], {
            silent: true
        })
    },
    collectRadiusHandle: function() {
        var i = this.feature.geometry;
        var a = i.getBounds();
        var c = a.getCenterLonLat();
        var j = new SuperMap.Geometry.Point(c.lon,c.lat);
        var h = new SuperMap.Geometry.Point(a.right,a.bottom);
        var g = new SuperMap.Feature.Vector(h);
        var d = (this.mode & SuperMap.Control.ModifyFeature.RESIZE);
        var f = (this.mode & SuperMap.Control.ModifyFeature.RESHAPE);
        var e = (this.mode & SuperMap.Control.ModifyFeature.ROTATE);
        h.move = function(u, t) {
            SuperMap.Geometry.Point.prototype.move.call(this, u, t);
            var v = this.x - j.x;
            var q = this.y - j.y;
            var w = v - u;
            var r = q - t;
            if (e) {
                var l = Math.atan2(r, w);
                var k = Math.atan2(q, v);
                var o = k - l;
                o *= 180 / Math.PI;
                i.rotate(o, j)
            }
            if (d) {
                var n, s;
                if (f) {
                    n = q / r;
                    s = (v / w) / n
                } else {
                    var p = Math.sqrt((w * w) + (r * r));
                    var m = Math.sqrt((v * v) + (q * q));
                    n = m / p
                }
                i.resize(n, j, s)
            }
        }
        ;
        g._sketch = true;
        this.radiusHandle = g;
        this.layer.addFeatures([this.radiusHandle], {
            silent: true
        })
    },
    setMap: function(a) {
        this.standalone || this.selectControl.setMap(a);
        this.dragControl.setMap(a);
        SuperMap.Control.prototype.setMap.apply(this, arguments)
    },
    CLASS_NAME: "SuperMap.Control.ModifyFeature"
});
SuperMap.Control.ModifyFeature.RESHAPE = 1;
SuperMap.Control.ModifyFeature.RESIZE = 2;
SuperMap.Control.ModifyFeature.ROTATE = 4;
SuperMap.Control.ModifyFeature.DRAG = 8;
SuperMap.Control.ArgParser = SuperMap.Class(SuperMap.Control, {
    center: null,
    zoom: null,
    layers: null,
    displayProjection: null,
    getParameters: function(c) {
        c = c || window.location.href;
        var d = SuperMap.Util.getParameters(c);
        var a = c.indexOf("#");
        if (a > 0) {
            c = "?" + c.substring(a + 1, c.length);
            SuperMap.Util.extend(d, SuperMap.Util.getParameters(c))
        }
        return d
    },
    setMap: function(f) {
        SuperMap.Control.prototype.setMap.apply(this, arguments);
        for (var d = 0, a = this.map.controls.length; d < a; d++) {
            var e = this.map.controls[d];
            if ((e != this) && (e.CLASS_NAME == "SuperMap.Control.ArgParser")) {
                if (e.displayProjection != this.displayProjection) {
                    this.displayProjection = e.displayProjection
                }
                break
            }
        }
        if (d == this.map.controls.length) {
            var c = this.getParameters();
            if (c.layers) {
                this.layers = c.layers;
                this.map.events.register("addlayer", this, this.configureLayers);
                this.configureLayers()
            }
            if (c.lat && c.lon) {
                this.center = new SuperMap.LonLat(parseFloat(c.lon),parseFloat(c.lat));
                if (c.zoom) {
                    this.zoom = parseFloat(c.zoom)
                }
                this.map.events.register("changebaselayer", this, this.setCenter);
                this.setCenter()
            }
        }
    },
    setCenter: function() {
        if (this.map.baseLayer) {
            this.map.events.unregister("changebaselayer", this, this.setCenter);
            if (this.displayProjection) {
                this.center.transform(this.displayProjection, this.map.getProjectionObject())
            }
            this.map.setCenter(this.center, this.zoom)
        }
    },
    configureLayers: function() {
        if (this.layers.length == this.map.layers.length) {
            this.map.events.unregister("addlayer", this, this.configureLayers);
            for (var e = 0, a = this.layers.length; e < a; e++) {
                var d = this.map.layers[e];
                var f = this.layers.charAt(e);
                if (f == "B") {
                    this.map.setBaseLayer(d)
                } else {
                    if ((f == "T") || (f == "F")) {
                        d.setVisibility(f == "T")
                    }
                }
            }
        }
    },
    CLASS_NAME: "SuperMap.Control.ArgParser"
});
SuperMap.Control.Permalink = SuperMap.Class(SuperMap.Control, {
    argParserClass: SuperMap.Control.ArgParser,
    element: null,
    anchor: false,
    base: "",
    displayProjection: null,
    initialize: function(c, d, a) {
        if (c !== null && typeof c == "object" && !SuperMap.Util.isElement(c)) {
            a = c;
            this.base = document.location.href;
            SuperMap.Control.prototype.initialize.apply(this, [a]);
            if (this.element != null) {
                this.element = SuperMap.Util.getElement(this.element)
            }
        } else {
            SuperMap.Control.prototype.initialize.apply(this, [a]);
            this.element = SuperMap.Util.getElement(c);
            this.base = d || document.location.href
        }
    },
    destroy: function() {
        if (this.element && this.element.parentNode == this.div) {
            this.div.removeChild(this.element);
            this.element = null
        }
        if (this.map) {
            this.map.events.unregister("moveend", this, this.updateLink)
        }
        SuperMap.Control.prototype.destroy.apply(this, arguments)
    },
    setMap: function(e) {
        SuperMap.Control.prototype.setMap.apply(this, arguments);
        for (var c = 0, a = this.map.controls.length; c < a; c++) {
            var d = this.map.controls[c];
            if (d.CLASS_NAME == this.argParserClass.CLASS_NAME) {
                if (d.displayProjection != this.displayProjection) {
                    this.displayProjection = d.displayProjection
                }
                break
            }
        }
        if (c == this.map.controls.length) {
            this.map.addControl(new this.argParserClass({
                displayProjection: this.displayProjection
            }))
        }
    },
    draw: function() {
        SuperMap.Control.prototype.draw.apply(this, arguments);
        if (!this.element && !this.anchor) {
            this.element = document.createElement("a");
            this.element.innerHTML = SuperMap.i18n("Permalink");
            this.element.href = "";
            this.div.appendChild(this.element)
        }
        this.map.events.on({
            moveend: this.updateLink,
            changelayer: this.updateLink,
            changebaselayer: this.updateLink,
            scope: this
        });
        this.updateLink();
        return this.div
    },
    updateLink: function() {
        var c = this.anchor ? "#" : "?";
        var a = this.base;
        if (a.indexOf(c) != -1) {
            a = a.substring(0, a.indexOf(c))
        }
        a += c + SuperMap.Util.getParameterString(this.createParams());
        if (this.anchor && !this.element) {
            window.location.href = a
        } else {
            this.element.href = a
        }
    },
    createParams: function(a, l, f) {
        a = a || this.map.getCenter();
        var e = SuperMap.Util.getParameters(this.base);
        if (a) {
            e.zoom = l || this.map.getZoom();
            var k = a.lat;
            var c = a.lon;
            if (this.displayProjection) {
                var d = SuperMap.Projection.transform({
                    x: c,
                    y: k
                }, this.map.getProjectionObject(), this.displayProjection);
                c = d.x;
                k = d.y
            }
            e.lat = Math.round(k * 100000) / 100000;
            e.lon = Math.round(c * 100000) / 100000;
            f = f || this.map.layers;
            e.layers = "";
            for (var g = 0, j = f.length; g < j; g++) {
                var h = f[g];
                if (h.isBaseLayer) {
                    e.layers += (h == this.map.baseLayer) ? "B" : "0"
                } else {
                    e.layers += (h.getVisibility()) ? "T" : "F"
                }
            }
        }
        return e
    },
    CLASS_NAME: "SuperMap.Control.Permalink"
});
SuperMap.Control.Attribution = SuperMap.Class(SuperMap.Control, {
    separator: ", ",
    template: "${layers}",
    destroy: function() {
        this.map.events.un({
            removelayer: this.updateAttribution,
            addlayer: this.updateAttribution,
            changelayer: this.updateAttribution,
            changebaselayer: this.updateAttribution,
            scope: this
        });
        SuperMap.Control.prototype.destroy.apply(this, arguments)
    },
    draw: function() {
        SuperMap.Control.prototype.draw.apply(this, arguments);
        this.map.events.on({
            changebaselayer: this.updateAttribution,
            changelayer: this.updateAttribution,
            addlayer: this.updateAttribution,
            removelayer: this.updateAttribution,
            scope: this
        });
        this.updateAttribution();
        return this.div
    },
    updateAttribution: function() {
        var e = [];
        if (this.map && this.map.layers) {
            for (var d = 0, a = this.map.layers.length; d < a; d++) {
                var c = this.map.layers[d];
                if (c.attribution && c.getVisibility()) {
                    if (SuperMap.Util.indexOf(e, c.attribution) === -1) {
                        e.push(c.attribution)
                    }
                }
            }
            this.div.innerHTML = SuperMap.String.format(this.template, {
                layers: e.join(this.separator)
            })
        }
    },
    CLASS_NAME: "SuperMap.Control.Attribution"
});
SuperMap.Geometry = SuperMap.Class({
    id: null,
    parent: null,
    bounds: null,
    initialize: function() {
        this.id = SuperMap.Util.createUniqueID(this.CLASS_NAME + "_")
    },
    destroy: function() {
        this.id = null;
        this.bounds = null
    },
    clone: function() {
        return new SuperMap.Geometry()
    },
    setBounds: function(a) {
        if (a) {
            this.bounds = a.clone()
        }
    },
    clearBounds: function() {
        this.bounds = null;
        if (this.parent) {
            this.parent.clearBounds()
        }
    },
    extendBounds: function(c) {
        var a = this.getBounds();
        if (!a) {
            this.setBounds(c)
        } else {
            this.bounds.extend(c)
        }
    },
    getBounds: function() {
        if (this.bounds == null) {
            this.calculateBounds()
        }
        return this.bounds
    },
    calculateBounds: function() {},
    distanceTo: function(c, a) {},
    getVertices: function(a) {},
    atPoint: function(f, i, g) {
        var d = false;
        var e = this.getBounds();
        if ((e != null) && (f != null)) {
            var c = (i != null) ? i : 0;
            var a = (g != null) ? g : 0;
            var h = new SuperMap.Bounds(this.bounds.left - c,this.bounds.bottom - a,this.bounds.right + c,this.bounds.top + a);
            d = h.containsLonLat(f)
        }
        return d
    },
    getLength: function() {
        return 0
    },
    getArea: function() {
        return 0
    },
    getCentroid: function() {
        return null
    },
    toString: function() {
        var a;
        if (SuperMap.Format && SuperMap.Format.WKT) {
            a = SuperMap.Format.WKT.prototype.write(new SuperMap.Feature.Vector(this))
        } else {
            a = Object.prototype.toString.call(this)
        }
        return a
    },
    CLASS_NAME: "SuperMap.Geometry"
});
SuperMap.Geometry.fromWKT = function(g) {
    var e;
    if (SuperMap.Format && SuperMap.Format.WKT) {
        var h = SuperMap.Geometry.fromWKT.format;
        if (!h) {
            h = new SuperMap.Format.WKT();
            SuperMap.Geometry.fromWKT.format = h
        }
        var c = h.read(g);
        if (c instanceof SuperMap.Feature.Vector) {
            e = c.geometry
        } else {
            if (SuperMap.Util.isArray(c)) {
                var a = c.length;
                var f = new Array(a);
                for (var d = 0; d < a; ++d) {
                    f[d] = c[d].geometry
                }
                e = new SuperMap.Geometry.Collection(f)
            }
        }
    }
    return e
}
;
SuperMap.Geometry.segmentsIntersect = function(a, I, c) {
    var t = c && c.point;
    var A = c && c.tolerance;
    var g = false;
    var C = a.x1 - I.x1;
    var G = a.y1 - I.y1;
    var q = a.x2 - a.x1;
    var z = a.y2 - a.y1;
    var u = I.y2 - I.y1;
    var m = I.x2 - I.x1;
    var E = (u * q) - (m * z);
    var f = (m * G) - (u * C);
    var e = (q * G) - (z * C);
    if (E == 0) {
        if (f == 0 && e == 0) {
            g = true
        }
    } else {
        var F = f / E;
        var D = e / E;
        if (F >= 0 && F <= 1 && D >= 0 && D <= 1) {
            if (!t) {
                g = true
            } else {
                var k = a.x1 + (F * q);
                var h = a.y1 + (F * z);
                g = new SuperMap.Geometry.Point(k,h)
            }
        }
    }
    if (A) {
        var s;
        if (g) {
            if (t) {
                var o = [a, I];
                var B, k, h;
                outer: for (var w = 0; w < 2; ++w) {
                    B = o[w];
                    for (var v = 1; v < 3; ++v) {
                        k = B["x" + v];
                        h = B["y" + v];
                        s = Math.sqrt(Math.pow(k - g.x, 2) + Math.pow(h - g.y, 2));
                        if (s < A) {
                            g.x = k;
                            g.y = h;
                            break outer
                        }
                    }
                }
            }
        } else {
            var o = [a, I];
            var r, H, k, h, n, l;
            outer: for (var w = 0; w < 2; ++w) {
                r = o[w];
                H = o[(w + 1) % 2];
                for (var v = 1; v < 3; ++v) {
                    n = {
                        x: r["x" + v],
                        y: r["y" + v]
                    };
                    l = SuperMap.Geometry.distanceToSegment(n, H);
                    if (l.distance < A) {
                        if (t) {
                            g = new SuperMap.Geometry.Point(n.x,n.y)
                        } else {
                            g = true
                        }
                        break outer
                    }
                }
            }
        }
    }
    return g
}
;
SuperMap.Geometry.distanceToSegment = function(l, e) {
    var d = l.x;
    var k = l.y;
    var c = e.x1;
    var j = e.y1;
    var a = e.x2;
    var g = e.y2;
    var n = a - c;
    var m = g - j;
    var i = ((n * (d - c)) + (m * (k - j))) / (Math.pow(n, 2) + Math.pow(m, 2));
    var h, f;
    if (i <= 0) {
        h = c;
        f = j
    } else {
        if (i >= 1) {
            h = a;
            f = g
        } else {
            h = c + i * n;
            f = j + i * m
        }
    }
    return {
        distance: Math.sqrt(Math.pow(h - d, 2) + Math.pow(f - k, 2)),
        x: h,
        y: f
    }
}
;
SuperMap.Geometry.Collection = SuperMap.Class(SuperMap.Geometry, {
    components: null,
    componentTypes: null,
    initialize: function(a) {
        SuperMap.Geometry.prototype.initialize.apply(this, arguments);
        this.components = [];
        if (a != null) {
            this.addComponents(a)
        }
    },
    destroy: function() {
        this.components.length = 0;
        this.components = null;
        SuperMap.Geometry.prototype.destroy.apply(this, arguments)
    },
    clone: function() {
        var geometry = eval("new " + this.CLASS_NAME + "()");
        for (var i = 0, len = this.components.length; i < len; i++) {
            geometry.addComponent(this.components[i].clone())
        }
        SuperMap.Util.applyDefaults(geometry, this);
        return geometry
    },
    getComponentsString: function() {
        var c = [];
        for (var d = 0, a = this.components.length; d < a; d++) {
            c.push(this.components[d].toShortString())
        }
        return c.join(",")
    },
    calculateBounds: function() {
        this.bounds = null;
        var e = new SuperMap.Bounds();
        var d = this.components;
        if (d) {
            for (var c = 0, a = d.length; c < a; c++) {
                e.extend(d[c].getBounds())
            }
        }
        if (e.left != null && e.bottom != null && e.right != null && e.top != null) {
            this.setBounds(e)
        }
    },
    addComponents: function(d) {
        if (!(SuperMap.Util.isArray(d))) {
            d = [d]
        }
        for (var c = 0, a = d.length; c < a; c++) {
            this.addComponent(d[c])
        }
    },
    addComponent: function(c, a) {
        var e = false;
        if (c) {
            if (this.componentTypes == null || (SuperMap.Util.indexOf(this.componentTypes, c.CLASS_NAME) > -1)) {
                if (a != null && (a < this.components.length)) {
                    var f = this.components.slice(0, a);
                    var d = this.components.slice(a, this.components.length);
                    f.push(c);
                    this.components = f.concat(d)
                } else {
                    this.components.push(c)
                }
                c.parent = this;
                this.clearBounds();
                e = true
            }
        }
        return e
    },
    removeComponents: function(c) {
        var d = false;
        if (!(SuperMap.Util.isArray(c))) {
            c = [c]
        }
        for (var a = c.length - 1; a >= 0; --a) {
            d = this.removeComponent(c[a]) || d
        }
        return d
    },
    removeComponent: function(a) {
        SuperMap.Util.removeItem(this.components, a);
        this.clearBounds();
        return true
    },
    getLength: function() {
        var d = 0;
        for (var c = 0, a = this.components.length; c < a; c++) {
            d += this.components[c].getLength()
        }
        return d
    },
    getArea: function() {
        var d = 0;
        for (var c = 0, a = this.components.length; c < a; c++) {
            d += this.components[c].getArea()
        }
        return d
    },
    getGeodesicArea: function(c) {
        var e = 0;
        for (var d = 0, a = this.components.length; d < a; d++) {
            e += this.components[d].getGeodesicArea(c)
        }
        return e
    },
    getCentroid: function(h) {
        if (!h) {
            return this.components.length && this.components[0].getCentroid()
        }
        var m = this.components.length;
        if (!m) {
            return false
        }
        var c = [];
        var d = [];
        var e = 0;
        var j = Number.MAX_VALUE;
        var n;
        for (var l = 0; l < m; ++l) {
            n = this.components[l];
            var f = n.getArea();
            var g = n.getCentroid(true);
            if (isNaN(f) || isNaN(g.x) || isNaN(g.y)) {
                continue
            }
            c.push(f);
            e += f;
            j = (f < j && f > 0) ? f : j;
            d.push(g)
        }
        m = c.length;
        if (e === 0) {
            for (var l = 0; l < m; ++l) {
                c[l] = 1
            }
            e = c.length
        } else {
            for (var l = 0; l < m; ++l) {
                c[l] /= j
            }
            e /= j
        }
        var k = 0, a = 0, g, f;
        for (var l = 0; l < m; ++l) {
            g = d[l];
            f = c[l];
            k += g.x * f;
            a += g.y * f
        }
        return new SuperMap.Geometry.Point(k / e,a / e)
    },
    getGeodesicLength: function(c) {
        var e = 0;
        for (var d = 0, a = this.components.length; d < a; d++) {
            e += this.components[d].getGeodesicLength(c)
        }
        return e
    },
    move: function(c, e) {
        for (var d = 0, a = this.components.length; d < a; d++) {
            this.components[d].move(c, e)
        }
    },
    rotate: function(e, c) {
        for (var d = 0, a = this.components.length; d < a; ++d) {
            this.components[d].rotate(e, c)
        }
    },
    resize: function(e, a, d) {
        for (var c = 0; c < this.components.length; ++c) {
            this.components[c].resize(e, a, d)
        }
        return this
    },
    distanceTo: function(j, k) {
        var d = !(k && k.edge === false);
        var a = d && k && k.details;
        var l, e, c;
        var f = Number.POSITIVE_INFINITY;
        for (var g = 0, h = this.components.length; g < h; ++g) {
            l = this.components[g].distanceTo(j, k);
            c = a ? l.distance : l;
            if (c < f) {
                f = c;
                e = l;
                if (f == 0) {
                    break
                }
            }
        }
        return e
    },
    equals: function(e) {
        var c = true;
        if (!e || !e.CLASS_NAME || (this.CLASS_NAME != e.CLASS_NAME)) {
            c = false
        } else {
            if (!(SuperMap.Util.isArray(e.components)) || (e.components.length != this.components.length)) {
                c = false
            } else {
                for (var d = 0, a = this.components.length; d < a; ++d) {
                    if (!this.components[d].equals(e.components[d])) {
                        c = false;
                        break
                    }
                }
            }
        }
        return c
    },
    transform: function(f, d) {
        if (f && d) {
            for (var e = 0, a = this.components.length; e < a; e++) {
                var c = this.components[e];
                c.transform(f, d)
            }
            this.bounds = null
        }
        return this
    },
    intersects: function(e) {
        var c = false;
        for (var d = 0, a = this.components.length; d < a; ++d) {
            c = e.intersects(this.components[d]);
            if (c) {
                break
            }
        }
        return c
    },
    getVertices: function(c) {
        var d = [];
        for (var e = 0, a = this.components.length; e < a; ++e) {
            Array.prototype.push.apply(d, this.components[e].getVertices(c))
        }
        return d
    },
    CLASS_NAME: "SuperMap.Geometry.Collection"
});
SuperMap.Geometry.Point = SuperMap.Class(SuperMap.Geometry, {
    x: null,
    y: null,
    tag: null,
    initialize: function(c, d, a) {
        SuperMap.Geometry.prototype.initialize.apply(this, arguments);
        this.x = parseFloat(c);
        this.y = parseFloat(d);
        if (a || a == 0) {
            this.tag = parseFloat(a)
        }
    },
    clone: function(a) {
        if (a == null) {
            a = new SuperMap.Geometry.Point(this.x,this.y)
        }
        SuperMap.Util.applyDefaults(a, this);
        return a
    },
    calculateBounds: function() {
        this.bounds = new SuperMap.Bounds(this.x,this.y,this.x,this.y)
    },
    distanceTo: function(g, k) {
        var e = !(k && k.edge === false);
        var a = e && k && k.details;
        var c, f, i, d, h, j;
        if (g instanceof SuperMap.Geometry.Point) {
            f = this.x;
            i = this.y;
            d = g.x;
            h = g.y;
            c = Math.sqrt(Math.pow(f - d, 2) + Math.pow(i - h, 2));
            j = !a ? c : {
                x0: f,
                y0: i,
                x1: d,
                y1: h,
                distance: c
            }
        } else {
            j = g.distanceTo(this, k);
            if (a) {
                j = {
                    x0: j.x1,
                    y0: j.y1,
                    x1: j.x0,
                    y1: j.y0,
                    distance: j.distance
                }
            }
        }
        return j
    },
    equals: function(a) {
        var c = false;
        if (a != null) {
            c = ((this.x == a.x && this.y == a.y) || (isNaN(this.x) && isNaN(this.y) && isNaN(a.x) && isNaN(a.y)))
        }
        return c
    },
    toShortString: function() {
        return ( this.x + ", " + this.y)
    },
    move: function(a, c) {
        this.x = this.x + a;
        this.y = this.y + c;
        this.clearBounds()
    },
    rotate: function(e, c) {
        e *= Math.PI / 180;
        var a = this.distanceTo(c);
        var d = e + Math.atan2(this.y - c.y, this.x - c.x);
        this.x = c.x + (a * Math.cos(d));
        this.y = c.y + (a * Math.sin(d));
        this.clearBounds()
    },
    getCentroid: function() {
        return new SuperMap.Geometry.Point(this.x,this.y)
    },
    resize: function(d, a, c) {
        c = (c == undefined) ? 1 : c;
        this.x = a.x + (d * c * (this.x - a.x));
        this.y = a.y + (d * (this.y - a.y));
        this.clearBounds();
        return this
    },
    intersects: function(c) {
        var a = false;
        if (c.CLASS_NAME == "SuperMap.Geometry.Point") {
            a = this.equals(c)
        } else {
            a = c.intersects(this)
        }
        return a
    },
    transform: function(c, a) {
        if ((c && a) ) {
            SuperMap.Projection.transform(this, c, a);
            this.bounds = null
        }
        return this
    },
    getVertices: function(a) {
        return [this]
    },
    CLASS_NAME: "SuperMap.Geometry.Point"
});
SuperMap.Geometry.MultiPoint = SuperMap.Class(SuperMap.Geometry.Collection, {
    componentTypes: ["SuperMap.Geometry.Point"],
    initialize: function(a) {
        SuperMap.Geometry.Collection.prototype.initialize.apply(this, arguments)
    },
    addPoint: function(a, c) {
        this.addComponent(a, c)
    },
    removePoint: function(a) {
        this.removeComponent(a)
    },
    CLASS_NAME: "SuperMap.Geometry.MultiPoint"
});
SuperMap.Geometry.Curve = SuperMap.Class(SuperMap.Geometry.MultiPoint, {
    componentTypes: ["SuperMap.Geometry.Point", "SuperMap.REST.PointWithMeasure"],
    initialize: function(a) {
        SuperMap.Geometry.MultiPoint.prototype.initialize.apply(this, arguments)
    },
    getLength: function() {
        var d = 0;
        if (this.components && (this.components.length > 1)) {
            for (var c = 1, a = this.components.length; c < a; c++) {
                d += this.components[c - 1].distanceTo(this.components[c])
            }
        }
        return d
    },
    getGeodesicLength: function(c) {
        var f = this;
        if (c) {
            var d = new SuperMap.Projection("EPSG:4326");
            if (!d.equals(c)) {
                f = this.clone().transform(c, d)
            }
        }
        var g = 0;
        if (f.components && (f.components.length > 1)) {
            var j, h;
            for (var e = 1, a = f.components.length; e < a; e++) {
                j = f.components[e - 1];
                h = f.components[e];
                g += SuperMap.Util.distVincenty({
                    lon: j.x,
                    lat: j.y
                }, {
                    lon: h.x,
                    lat: h.y
                })
            }
        }
        return g * 1000
    },
    CLASS_NAME: "SuperMap.Geometry.Curve"
});
SuperMap.Geometry.LineString = SuperMap.Class(SuperMap.Geometry.Curve, {
    initialize: function(a) {
        SuperMap.Geometry.Curve.prototype.initialize.apply(this, arguments)
    },
    removeComponent: function(a) {
        var c = this.components && (this.components.length > 2);
        if (c) {
            SuperMap.Geometry.Collection.prototype.removeComponent.apply(this, arguments)
        }
        return c
    },
    intersects: function(n) {
        var d = false;
        var m = n.CLASS_NAME;
        if (m == "SuperMap.Geometry.LineString" || m == "SuperMap.Geometry.LinearRing" || m == "SuperMap.Geometry.Point") {
            var q = this.getSortedSegments();
            var o;
            if (m == "SuperMap.Geometry.Point") {
                o = [{
                    x1: n.x,
                    y1: n.y,
                    x2: n.x,
                    y2: n.y
                }]
            } else {
                o = n.getSortedSegments()
            }
            var t, h, f, a, s, r, e, c;
            outer: for (var k = 0, l = q.length; k < l; ++k) {
                t = q[k];
                h = t.x1;
                f = t.x2;
                a = t.y1;
                s = t.y2;
                inner: for (var g = 0, p = o.length; g < p; ++g) {
                    r = o[g];
                    if (r.x1 > f) {
                        break
                    }
                    if (r.x2 < h) {
                        continue
                    }
                    e = r.y1;
                    c = r.y2;
                    if (Math.min(e, c) > Math.max(a, s)) {
                        continue
                    }
                    if (Math.max(e, c) < Math.min(a, s)) {
                        continue
                    }
                    if (SuperMap.Geometry.segmentsIntersect(t, r)) {
                        d = true;
                        break outer
                    }
                }
            }
        } else {
            d = n.intersects(this)
        }
        return d
    },
    getSortedSegments: function() {
        var a = this.components.length - 1;
        var c = new Array(a), f, e;
        for (var d = 0; d < a; ++d) {
            f = this.components[d];
            e = this.components[d + 1];
            if (f.x < e.x) {
                c[d] = {
                    x1: f.x,
                    y1: f.y,
                    x2: e.x,
                    y2: e.y
                }
            } else {
                c[d] = {
                    x1: e.x,
                    y1: e.y,
                    x2: f.x,
                    y2: f.y
                }
            }
        }
        function g(i, h) {
            return i.x1 - h.x1
        }
        return c.sort(g)
    },
    splitWithSegment: function(s, c) {
        var d = !(c && c.edge === false);
        var p = c && c.tolerance;
        var a = [];
        var u = this.getVertices();
        var o = [];
        var w = [];
        var j = false;
        var f, e, m;
        var k, r, v;
        var g = {
            point: true,
            tolerance: p
        };
        var h = null;
        for (var n = 0, l = u.length - 2; n <= l; ++n) {
            f = u[n];
            o.push(f.clone());
            e = u[n + 1];
            v = {
                x1: f.x,
                y1: f.y,
                x2: e.x,
                y2: e.y
            };
            m = SuperMap.Geometry.segmentsIntersect(s, v, g);
            if (m instanceof SuperMap.Geometry.Point) {
                if ((m.x === s.x1 && m.y === s.y1) || (m.x === s.x2 && m.y === s.y2) || m.equals(f) || m.equals(e)) {
                    r = true
                } else {
                    r = false
                }
                if (r || d) {
                    if (!m.equals(w[w.length - 1])) {
                        w.push(m.clone())
                    }
                    if (n === 0) {
                        if (m.equals(f)) {
                            continue
                        }
                    }
                    if (m.equals(e)) {
                        continue
                    }
                    j = true;
                    if (!m.equals(f)) {
                        o.push(m)
                    }
                    a.push(new SuperMap.Geometry.LineString(o));
                    o = [m.clone()]
                }
            }
        }
        if (j) {
            o.push(e.clone());
            a.push(new SuperMap.Geometry.LineString(o))
        }
        if (w.length > 0) {
            var q = s.x1 < s.x2 ? 1 : -1;
            var t = s.y1 < s.y2 ? 1 : -1;
            h = {
                lines: a,
                points: w.sort(function(x, i) {
                    return (q * x.x - q * i.x) || (t * x.y - t * i.y)
                })
            }
        }
        return h
    },
    split: function(y, c) {
        var o = null;
        var e = c && c.mutual;
        var m, f, n, d;
        if (y instanceof SuperMap.Geometry.LineString) {
            var x = this.getVertices();
            var h, g, w, l, a, q;
            var t = [];
            n = [];
            for (var u = 0, p = x.length - 2; u <= p; ++u) {
                h = x[u];
                g = x[u + 1];
                w = {
                    x1: h.x,
                    y1: h.y,
                    x2: g.x,
                    y2: g.y
                };
                d = d || [y];
                if (e) {
                    t.push(h.clone())
                }
                for (var s = 0; s < d.length; ++s) {
                    l = d[s].splitWithSegment(w, c);
                    if (l) {
                        a = l.lines;
                        if (a.length > 0) {
                            a.unshift(s, 1);
                            Array.prototype.splice.apply(d, a);
                            s += a.length - 2
                        }
                        if (e) {
                            for (var r = 0, v = l.points.length; r < v; ++r) {
                                q = l.points[r];
                                if (!q.equals(h)) {
                                    t.push(q);
                                    n.push(new SuperMap.Geometry.LineString(t));
                                    if (q.equals(g)) {
                                        t = []
                                    } else {
                                        t = [q.clone()]
                                    }
                                }
                            }
                        }
                    }
                }
            }
            if (e && n.length > 0 && t.length > 0) {
                t.push(g.clone());
                n.push(new SuperMap.Geometry.LineString(t))
            }
        } else {
            o = y.splitWith(this, c)
        }
        if (d && d.length > 1) {
            f = true
        } else {
            d = []
        }
        if (n && n.length > 1) {
            m = true
        } else {
            n = []
        }
        if (f || m) {
            if (e) {
                o = [n, d]
            } else {
                o = d
            }
        }
        return o
    },
    splitWith: function(c, a) {
        return c.split(this, a)
    },
    getVertices: function(a) {
        var c;
        if (a === true) {
            c = [this.components[0], this.components[this.components.length - 1]]
        } else {
            if (a === false) {
                c = this.components.slice(1, this.components.length - 1)
            } else {
                c = this.components.slice()
            }
        }
        return c
    },
    distanceTo: function(k, h) {
        var l = !(h && h.edge === false);
        var C = l && h && h.details;
        var r, f = {};
        var u = Number.POSITIVE_INFINITY;
        if (k instanceof SuperMap.Geometry.Point) {
            var s = this.getSortedSegments();
            var q = k.x;
            var p = k.y;
            var A;
            for (var w = 0, z = s.length; w < z; ++w) {
                A = s[w];
                r = SuperMap.Geometry.distanceToSegment(k, A);
                if (r.distance < u) {
                    u = r.distance;
                    f = r;
                    if (u === 0) {
                        break
                    }
                } else {
                    if (A.x2 > q && ((p > A.y1 && p < A.y2) || (p < A.y1 && p > A.y2))) {
                        break
                    }
                }
            }
            if (C) {
                f = {
                    distance: f.distance,
                    x0: f.x,
                    y0: f.y,
                    x1: q,
                    y1: p
                }
            } else {
                f = f.distance
            }
        } else {
            if (k instanceof SuperMap.Geometry.LineString) {
                var e = this.getSortedSegments();
                var d = k.getSortedSegments();
                var c, a, o, B, g;
                var n = d.length;
                var m = {
                    point: true
                };
                outer: for (var w = 0, z = e.length; w < z; ++w) {
                    c = e[w];
                    B = c.x1;
                    g = c.y1;
                    for (var v = 0; v < n; ++v) {
                        a = d[v];
                        o = SuperMap.Geometry.segmentsIntersect(c, a, m);
                        if (o) {
                            u = 0;
                            f = {
                                distance: 0,
                                x0: o.x,
                                y0: o.y,
                                x1: o.x,
                                y1: o.y
                            };
                            break outer
                        } else {
                            r = SuperMap.Geometry.distanceToSegment({
                                x: B,
                                y: g
                            }, a);
                            if (r.distance < u) {
                                u = r.distance;
                                f = {
                                    distance: u,
                                    x0: B,
                                    y0: g,
                                    x1: r.x,
                                    y1: r.y
                                }
                            }
                        }
                    }
                }
                if (!C) {
                    f = f.distance
                }
                if (u !== 0) {
                    if (c) {
                        r = k.distanceTo(new SuperMap.Geometry.Point(c.x2,c.y2), h);
                        var t = C ? r.distance : r;
                        if (t < u) {
                            if (C) {
                                f = {
                                    distance: u,
                                    x0: r.x1,
                                    y0: r.y1,
                                    x1: r.x0,
                                    y1: r.y0
                                }
                            } else {
                                f = t
                            }
                        }
                    }
                }
            } else {
                f = k.distanceTo(this, h);
                if (C) {
                    f = {
                        distance: f.distance,
                        x0: f.x1,
                        y0: f.y1,
                        x1: f.x0,
                        y1: f.y0
                    }
                }
            }
        }
        return f
    },
    simplify: function(i) {
        if (this && this !== null) {
            var k = this.getVertices();
            if (k.length < 3) {
                return this
            }
            var e = function(m, l) {
                return ( m - l)
            };
            var d = function(o, r, p, l) {
                var q = 0;
                var n = 0;
                for (var m = r, s; m < p; m++) {
                    s = c(o[r], o[p], o[m]);
                    if (s > q) {
                        q = s;
                        n = m
                    }
                }
                if (q > l && n != r) {
                    f.push(n);
                    d(o, r, n, l);
                    d(o, n, p, l)
                }
            };
            var c = function(p, o, m) {
                var q = Math.abs(0.5 * (p.x * o.y + o.x * m.y + m.x * p.y - o.x * p.y - m.x * o.y - p.x * m.y));
                var n = Math.sqrt(Math.pow(p.x - o.x, 2) + Math.pow(p.y - o.y, 2));
                var l = q / n * 2;
                return l
            };
            var g = 0;
            var j = k.length - 1;
            var f = [];
            f.push(g);
            f.push(j);
            while (k[g].equals(k[j])) {
                j--;
                f.push(j)
            }
            d(k, g, j, i);
            var a = [];
            f.sort(e);
            for (var h = 0; h < f.length; h++) {
                a.push(k[f[h]])
            }
            return new SuperMap.Geometry.LineString(a)
        } else {
            return this
        }
    },
    CLASS_NAME: "SuperMap.Geometry.LineString"
});
SuperMap.Geometry.LineString.createCurve = function(C, d, y, B) {
    var j = "lanczos";
    if (d != undefined) {
        j = d
    }
    var l = 10;
    if (y != undefined) {
        l = y
    }
    var o = {
        method: j,
        clip: "mirror",
        lanczosFilterSize: l,
        cubicTension: 0
    };
    var A = [];
    for (var D = 0; D < C.length; D++) {
        A.push([C[D].x, C[D].y])
    }
    r = Smooth(A, o);
    var f = function(p, i) {
        return Math.sqrt(Math.pow(p[0] - i[0], 2) + Math.pow(p[1] - i[1], 2))
    };
    var E = 80;
    if (B != undefined) {
        E = B
    }
    var z = [];
    var m, v, e, h, w, r, g, q, n, k, c, a;
    m = f(A[0], A[A.length - 1]) / E;
    h = 2;
    for (q = 0,
    k = 1 / h; q < 1; q += k) {
        c = [r(D + q), r(D + q + 1 / h)],
        g = c[0],
        e = c[1];
        w = f(g, e);
        v = m / w;
        for (n = 0,
        a = 1 / h; 0 <= a ? n < a : n > a; n += v) {
            var x = r(D + q + n);
            z.push(new SuperMap.Geometry.Point(x[0],x[1]))
        }
    }
    var x = r(D + 1);
    z.push(new SuperMap.Geometry.Point(x[0],x[1]));
    return new SuperMap.Geometry.LineString(z)
}
;
SuperMap.Geometry.LineString.createBspline = function(n, g) {
    if (n.length < 2) {
        return null
    }
    var t = [];
    var l = 10;
    if (g != undefined) {
        l = g
    }
    var o, m, w, v, u, d, c, a;
    var r, q;
    d = 1 / l;
    var f = Math.sqrt((Math.pow(n[1].x - n[0].x, 2) + Math.pow(n[1].y - n[0].y, 2)) / 2);
    var p = new SuperMap.Geometry.Point(n[0].x - f,n[0].y - f);
    var s = [];
    s[0] = p;
    for (o = 0; o < n.length - 1; o++) {
        var e = [];
        e[0] = n[o];
        var h = new SuperMap.Geometry.Point(n[o].x * 2 - s[o].x,n[o].y * 2 - s[o].y);
        e[1] = h;
        s[o + 1] = h;
        e[2] = n[o + 1];
        t.push(e[0]);
        for (m = 0; m <= l; m++) {
            c = m * d;
            a = c * c;
            w = (a - 2 * c + 1) / 2;
            v = (2 * c - 2 * a + 1) / 2;
            u = a / 2;
            r = w * e[0].x + v * e[1].x + u * e[2].x;
            q = w * e[0].y + v * e[1].y + u * e[2].y;
            t.push(new SuperMap.Geometry.Point(r,q))
        }
    }
    t.push(n[n.length - 1]);
    return new SuperMap.Geometry.LineString(t)
}
;
SuperMap.Geometry.LineString.createBezier = function(n, h) {
    var a = [];
    for (var d = 0; d < n.length; d++) {
        a[d] = n[d]
    }
    var g, e, f = 0, o, l = a.length;
    var c = [];
    while (true) {
        o = true;
        for (g = 0; g < l - 3; g += 3) {
            if (GetBezierGap(a, g) > h) {
                o = false;
                InciseBezier(a, g, c);
                a.splice(g + 1, 2);
                for (e = 0; e < 5; e++) {
                    a.splice(g + 1 + e, 0, c[e + 1])
                }
                g -= 3;
                l = a.length
            }
            if (o) {
                break
            }
        }
        while (f < l - 1) {
            if (a[f] == a[f + 1]) {
                a.splice(f + 1, 1);
                l--
            }
            f++
        }
        return new SuperMap.Geometry.LineString(a)
    }
}
;
InciseBezier = function(c, d, f) {
    var a = [];
    a[0] = [];
    a[1] = [];
    a[2] = [];
    var e;
    for (e = 0; e < 3; e++) {
        a[0][e] = new SuperMap.Geometry.Point;
        a[0][e].x = (c[d + e].x + c[d + e + 1].x) / 2;
        a[0][e].y = (c[d + e].y + c[d + e + 1].y) / 2
    }
    for (e = 0; e < 2; e++) {
        a[1][e] = new SuperMap.Geometry.Point;
        a[1][e].x = (a[0][e].x + a[0][e + 1].x) / 2;
        a[1][e].y = (a[0][e].y + a[0][e + 1].y) / 2
    }
    a[2][0] = new SuperMap.Geometry.Point;
    a[2][0].x = (a[1][0].x + a[1][1].x) / 2;
    a[2][0].y = (a[1][0].y + a[1][1].y) / 2;
    f[0] = c[d];
    f[1] = a[0][0];
    f[2] = a[1][0];
    f[3] = a[2][0];
    f[4] = a[1][1];
    f[5] = a[0][2];
    f[6] = c[d + 3];
    return true
}
;
GetBezierGap = function(a, c) {
    var e = 0;
    for (var d = 1; d < 4; d++) {
        if (Math.abs(a[c + d].x - a[c + d - 1].x) > e) {
            e = Math.abs(a[c + d].x - a[c + d - 1].x)
        }
        if (Math.abs(a[c + d].y - a[c + d - 1].y) > e) {
            e = Math.abs(a[c + d].y - a[c + d - 1].y)
        }
    }
    return e
}
;
SuperMap.Geometry.LinearRing = SuperMap.Class(SuperMap.Geometry.LineString, {
    componentTypes: ["SuperMap.Geometry.Point"],
    initialize: function(a) {
        SuperMap.Geometry.LineString.prototype.initialize.apply(this, arguments)
    },
    addComponent: function(a, c) {
        var d = false;
        var e = this.components.pop();
        if (c != null || !a.equals(e)) {
            d = SuperMap.Geometry.Collection.prototype.addComponent.apply(this, arguments)
        }
        var f = this.components[0];
        SuperMap.Geometry.Collection.prototype.addComponent.apply(this, [f]);
        return d
    },
    removeComponent: function(a) {
        var c = this.components && (this.components.length > 3);
        if (c) {
            this.components.pop();
            SuperMap.Geometry.Collection.prototype.removeComponent.apply(this, arguments);
            var d = this.components[0];
            SuperMap.Geometry.Collection.prototype.addComponent.apply(this, [d])
        }
        return c
    },
    move: function(c, e) {
        for (var d = 0, a = this.components.length; d < a - 1; d++) {
            this.components[d].move(c, e)
        }
    },
    rotate: function(e, c) {
        for (var d = 0, a = this.components.length; d < a - 1; ++d) {
            this.components[d].rotate(e, c)
        }
    },
    resize: function(f, c, e) {
        for (var d = 0, a = this.components.length; d < a - 1; ++d) {
            this.components[d].resize(f, c, e)
        }
        return this
    },
    transform: function(f, d) {
        if (f && d) {
            for (var e = 0, a = this.components.length; e < a - 1; e++) {
                var c = this.components[e];
                c.transform(f, d)
            }
            this.bounds = null
        }
        return this
    },
    getCentroid: function() {
        if (this.components && (this.components.length > 2)) {
            var h = 0;
            var g = 0;
            for (var e = 0; e < this.components.length - 1; e++) {
                var d = this.components[e];
                var k = this.components[e + 1];
                h += (d.x + k.x) * (d.x * k.y - k.x * d.y);
                g += (d.y + k.y) * (d.x * k.y - k.x * d.y)
            }
            var f = -1 * this.getArea();
            var a = h / (6 * f);
            var j = g / (6 * f);
            return new SuperMap.Geometry.Point(a,j)
        } else {
            return null
        }
    },
    getArea: function() {
        var g = 0;
        if (this.components && (this.components.length > 2)) {
            var f = 0;
            for (var e = 0, d = this.components.length; e < d - 1; e++) {
                var a = this.components[e];
                var h = this.components[e + 1];
                f += (a.x + h.x) * (h.y - a.y)
            }
            g = -f / 2
        }
        return g
    },
    getGeodesicArea: function(c) {
        var e = this;
        if (c) {
            var d = new SuperMap.Projection("EPSG:4326");
            if (!d.equals(c)) {
                e = this.clone().transform(c, d)
            }
        }
        var g = 0;
        var a = e.components && e.components.length;
        if (a > 2) {
            var j, h;
            for (var f = 0; f < a - 1; f++) {
                j = e.components[f];
                h = e.components[f + 1];
                g += SuperMap.Util.rad(h.x - j.x) * (2 + Math.sin(SuperMap.Util.rad(j.y)) + Math.sin(SuperMap.Util.rad(h.y)))
            }
            g = g * 6378137 * 6378137 / 2
        }
        return g
    },
    containsPoint: function(n) {
        var t = SuperMap.Number.limitSigDigs;
        var m = 14;
        var l = t(n.x, m);
        var k = t(n.y, m);
        function s(x, u, w, i, v) {
            return (x - v) * ((i - u) / (v - w)) + i
        }
        var a = this.components.length - 1;
        var h, g, r, e, p, c, f, d;
        var j = 0;
        for (var o = 0; o < a; ++o) {
            h = this.components[o];
            r = t(h.x, m);
            e = t(h.y, m);
            g = this.components[o + 1];
            p = t(g.x, m);
            c = t(g.y, m);
            if (e == c) {
                if (k == e) {
                    if (r <= p && (l >= r && l <= p) || r >= p && (l <= r && l >= p)) {
                        j = -1;
                        break
                    }
                }
                continue
            }
            f = t(s(k, r, e, p, c), m);
            if (f == l) {
                if (e < c && (k >= e && k <= c) || e > c && (k <= e && k >= c)) {
                    j = -1;
                    break
                }
            }
            if (f <= l) {
                continue
            }
            if (r != p && (f < Math.min(r, p) || f > Math.max(r, p))) {
                continue
            }
            if (e < c && (k >= e && k < c) || e > c && (k < e && k >= c)) {
                ++j
            }
        }
        var q = (j == -1) ? 1 : !!(j & 1);
        return q
    },
    intersects: function(e) {
        var c = false;
        if (e.CLASS_NAME == "SuperMap.Geometry.Point") {
            c = this.containsPoint(e)
        } else {
            if (e.CLASS_NAME == "SuperMap.Geometry.LineString") {
                c = e.intersects(this)
            } else {
                if (e.CLASS_NAME == "SuperMap.Geometry.LinearRing") {
                    c = SuperMap.Geometry.LineString.prototype.intersects.apply(this, [e])
                } else {
                    for (var d = 0, a = e.components.length; d < a; ++d) {
                        c = e.components[d].intersects(this);
                        if (c) {
                            break
                        }
                    }
                }
            }
        }
        return c
    },
    getVertices: function(a) {
        return (a === true) ? [] : this.components.slice(0, this.components.length - 1)
    },
    CLASS_NAME: "SuperMap.Geometry.LinearRing"
});
SuperMap.Geometry.MultiLineString = SuperMap.Class(SuperMap.Geometry.Collection, {
    componentTypes: ["SuperMap.Geometry.LineString"],
    initialize: function(a) {
        SuperMap.Geometry.Collection.prototype.initialize.apply(this, arguments)
    },
    split: function(o, t) {
        var h = null;
        var s = t && t.mutual;
        var p, a, r, n, c;
        var f = [];
        var q = [o];
        for (var g = 0, l = this.components.length; g < l; ++g) {
            a = this.components[g];
            n = false;
            for (var e = 0; e < q.length; ++e) {
                p = a.split(q[e], t);
                if (p) {
                    if (s) {
                        r = p[0];
                        for (var d = 0, m = r.length; d < m; ++d) {
                            if (d === 0 && f.length) {
                                f[f.length - 1].addComponent(r[d])
                            } else {
                                f.push(new SuperMap.Geometry.MultiLineString([r[d]]))
                            }
                        }
                        n = true;
                        p = p[1]
                    }
                    if (p.length) {
                        p.unshift(e, 1);
                        Array.prototype.splice.apply(q, p);
                        break
                    }
                }
            }
            if (!n) {
                if (f.length) {
                    f[f.length - 1].addComponent(a.clone())
                } else {
                    f = [new SuperMap.Geometry.MultiLineString(a.clone())]
                }
            }
        }
        if (f && f.length > 1) {
            n = true
        } else {
            f = []
        }
        if (q && q.length > 1) {
            c = true
        } else {
            q = []
        }
        if (n || c) {
            if (s) {
                h = [f, q]
            } else {
                h = q
            }
        }
        return h
    },
    splitWith: function(o, t) {
        var h = null;
        var s = t && t.mutual;
        var p, d, r, n, a, f, q;
        if (o instanceof SuperMap.Geometry.LineString) {
            q = [];
            f = [o];
            for (var g = 0, l = this.components.length; g < l; ++g) {
                a = false;
                d = this.components[g];
                for (var e = 0; e < f.length; ++e) {
                    p = f[e].split(d, t);
                    if (p) {
                        if (s) {
                            r = p[0];
                            if (r.length) {
                                r.unshift(e, 1);
                                Array.prototype.splice.apply(f, r);
                                e += r.length - 2
                            }
                            p = p[1];
                            if (p.length === 0) {
                                p = [d.clone()]
                            }
                        }
                        for (var c = 0, m = p.length; c < m; ++c) {
                            if (c === 0 && q.length) {
                                q[q.length - 1].addComponent(p[c])
                            } else {
                                q.push(new SuperMap.Geometry.MultiLineString([p[c]]))
                            }
                        }
                        a = true
                    }
                }
                if (!a) {
                    if (q.length) {
                        q[q.length - 1].addComponent(d.clone())
                    } else {
                        q = [new SuperMap.Geometry.MultiLineString([d.clone()])]
                    }
                }
            }
        } else {
            h = o.split(this)
        }
        if (f && f.length > 1) {
            n = true
        } else {
            f = []
        }
        if (q && q.length > 1) {
            a = true
        } else {
            q = []
        }
        if (n || a) {
            if (s) {
                h = [f, q]
            } else {
                h = q
            }
        }
        return h
    },
    CLASS_NAME: "SuperMap.Geometry.MultiLineString"
});
SuperMap.Geometry.Polygon = SuperMap.Class(SuperMap.Geometry.Collection, {
    componentTypes: ["SuperMap.Geometry.LinearRing"],
    initialize: function(a) {
        SuperMap.Geometry.Collection.prototype.initialize.apply(this, arguments)
    },
    getArea: function() {
        var d = 0;
        if (this.components && (this.components.length > 0)) {
            d += Math.abs(this.components[0].getArea());
            for (var c = 1, a = this.components.length; c < a; c++) {
                d -= Math.abs(this.components[c].getArea())
            }
        }
        return d
    },
    getGeodesicArea: function(c) {
        var e = 0;
        if (this.components && (this.components.length > 0)) {
            e += Math.abs(this.components[0].getGeodesicArea(c));
            for (var d = 1, a = this.components.length; d < a; d++) {
                e -= Math.abs(this.components[d].getGeodesicArea(c))
            }
        }
        return e
    },
    containsPoint: function(a) {
        var f = this.components.length;
        var d = false;
        if (f > 0) {
            d = this.components[0].containsPoint(a);
            if (d !== 1) {
                if (d && f > 1) {
                    var e;
                    for (var c = 1; c < f; ++c) {
                        e = this.components[c].containsPoint(a);
                        if (e) {
                            if (e === 1) {
                                d = 1
                            } else {
                                d = false
                            }
                            break
                        }
                    }
                }
            }
        }
        return d
    },
    intersects: function(f) {
        var c = false;
        var e, a;
        if (f.CLASS_NAME == "SuperMap.Geometry.Point") {
            c = this.containsPoint(f)
        } else {
            if (f.CLASS_NAME == "SuperMap.Geometry.LineString" || f.CLASS_NAME == "SuperMap.Geometry.LinearRing") {
                for (e = 0,
                a = this.components.length; e < a; ++e) {
                    c = f.intersects(this.components[e]);
                    if (c) {
                        break
                    }
                }
                if (!c) {
                    for (e = 0,
                    a = f.components.length; e < a; ++e) {
                        c = this.containsPoint(f.components[e]);
                        if (c) {
                            break
                        }
                    }
                }
            } else {
                for (e = 0,
                a = f.components.length; e < a; ++e) {
                    c = this.intersects(f.components[e]);
                    if (c) {
                        break
                    }
                }
            }
        }
        if (!c && f.CLASS_NAME == "SuperMap.Geometry.Polygon") {
            var d = this.components[0];
            for (e = 0,
            a = d.components.length; e < a; ++e) {
                c = f.containsPoint(d.components[e]);
                if (c) {
                    break
                }
            }
        }
        return c
    },
    distanceTo: function(e, c) {
        var d = !(c && c.edge === false);
        var a;
        if (!d && this.intersects(e)) {
            a = 0
        } else {
            a = SuperMap.Geometry.Collection.prototype.distanceTo.apply(this, [e, c])
        }
        return a
    },
    CLASS_NAME: "SuperMap.Geometry.Polygon"
});
SuperMap.Geometry.Polygon.createRegularPolygon = function(k, g, c, m) {
    var d = Math.PI * ((1 / c) - (1 / 2));
    if (m) {
        d += (m / 180) * Math.PI
    }
    var a, j, h;
    var l = [];
    for (var f = 0; f < c; ++f) {
        a = d + (f * 2 * Math.PI / c);
        j = k.x + (g * Math.cos(a));
        h = k.y + (g * Math.sin(a));
        l.push(new SuperMap.Geometry.Point(j,h))
    }
    var e = new SuperMap.Geometry.LinearRing(l);
    return new SuperMap.Geometry.Polygon([e])
}
;
SuperMap.Geometry.Polygon.createRegularPolygonCurve = function(o, k, d, a, j, e) {
    if (e == undefined) {
        e = 1
    }
    var n = a * Math.PI / (180 * d);
    var c, m, l;
    var p = [];
    for (var h = 0; h < d; ++h) {
        c = n * h;
        m = o.x + (k * e * Math.cos(c));
        l = o.y + (k * e * Math.sin(c));
        p.push(new SuperMap.Geometry.Point(m,l))
    }
    c = a * Math.PI / 180;
    m = o.x + (k * e * Math.cos(c));
    l = o.y + (k * e * Math.sin(c));
    p.push(new SuperMap.Geometry.Point(m,l));
    p.push(o);
    var f = new SuperMap.Geometry.LinearRing(p);
    f.rotate(parseFloat(j), o);
    var g = new SuperMap.Geometry.Collection([f]);
    g.origin = o;
    g.radius = k;
    g.r = a;
    g.angel = j;
    g.sides = d;
    g.polygonType = "Curve";
    return g
}
;
SuperMap.Geometry.Polygon.createRegularPolygonTriangle = function(k, l, d, a, h, e) {
    if (e == undefined) {
        e = 1
    }
    var i = [];
    i.push(k);
    i.push(new SuperMap.Geometry.Point(k.x + a * e,k.y));
    var c = new SuperMap.Geometry.LineString(i);
    c.rotate(parseFloat(h), k);
    var f = [];
    f.push(new SuperMap.Geometry.Point(k.x + l * e,k.y));
    f.push(new SuperMap.Geometry.Point(k.x + a * e,k.y + d * e / 2));
    f.push(new SuperMap.Geometry.Point(k.x + a * e,k.y - d * e / 2));
    var j = new SuperMap.Geometry.LinearRing(f);
    j.rotate(parseFloat(h), k);
    var g = new SuperMap.Geometry.Collection([c, j]);
    g.origin = k;
    g.height = l;
    g.width = d;
    g.lineLength = a;
    g.angel = h;
    g.polygonType = "Triangle";
    return g
}
;
SuperMap.Geometry.Polygon.createBsplinesurface = function(w, g, l, a, o, p) {
    if (o == undefined) {
        o = 1
    }
    if (p == undefined) {
        p = 10
    }
    var m = [];
    m.push(w);
    m.push(w);
    m.push(new SuperMap.Geometry.Point(w.x + g * o * 2 / 3,w.y + l * o / 2));
    m.push(new SuperMap.Geometry.Point(w.x + g * o,w.y + l * o / 2));
    m.push(new SuperMap.Geometry.Point(w.x + g * o,w.y - l * o / 2));
    m.push(new SuperMap.Geometry.Point(w.x + g * o * 2 / 3,w.y - l * o / 2));
    m.push(w);
    m.push(w);
    var s = [];
    var r, q, z, x, v, f, e, d;
    var u, t;
    var h = m.length;
    f = 1 / p;
    s.push(new SuperMap.Geometry.Point((m[0].x + m[1].x) / 2,(m[0].y + m[1].y) / 2));
    for (r = 1; r < h - 1; r++) {
        for (q = 0; q <= p; q++) {
            e = q * f;
            d = e * e;
            z = (d - 2 * e + 1) / 2;
            x = (2 * e - 2 * d + 1) / 2;
            v = d / 2;
            u = z * m[r - 1].x + x * m[r].x + v * m[r + 1].x;
            t = z * m[r - 1].y + x * m[r].y + v * m[r + 1].y;
            s.push(new SuperMap.Geometry.Point(u,t))
        }
    }
    var c = new SuperMap.Geometry.LinearRing(s);
    c.rotate(parseFloat(a), w);
    var y = new SuperMap.Geometry.Collection([c]);
    y.origin = w;
    y.height = g;
    y.width = l;
    y.angel = a;
    y.polygonType = "Bspline";
    return y
}
;
SuperMap.Geometry.MultiPolygon = SuperMap.Class(SuperMap.Geometry.Collection, {
    componentTypes: ["SuperMap.Geometry.Polygon"],
    initialize: function(a) {
        SuperMap.Geometry.Collection.prototype.initialize.apply(this, arguments)
    },
    CLASS_NAME: "SuperMap.Geometry.MultiPolygon"
});
SuperMap.Geometry.Rectangle = SuperMap.Class(SuperMap.Geometry, {
    x: null,
    y: null,
    width: null,
    height: null,
    initialize: function(c, e, d, a) {
        SuperMap.Geometry.prototype.initialize.apply(this, arguments);
        this.x = c;
        this.y = e;
        this.width = d;
        this.height = a
    },
    calculateBounds: function() {
        this.bounds = new SuperMap.Bounds(this.x,this.y,this.x + this.width,this.y + this.height)
    },
    getLength: function() {
        var a = (2 * this.width) + (2 * this.height);
        return a
    },
    getArea: function() {
        var a = this.width * this.height;
        return a
    },
    CLASS_NAME: "SuperMap.Geometry.Rectangle"
});
SuperMap.Renderer = SuperMap.Class({
    container: null,
    root: null,
    extent: null,
    locked: false,
    size: null,
    resolution: null,
    map: null,
    featureDx: 0,
    initialize: function(a, c) {
        this.container = SuperMap.Util.getElement(a);
        SuperMap.Util.extend(this, c)
    },
    destroy: function() {
        this.container = null;
        this.extent = null;
        this.size = null;
        this.resolution = null;
        this.map = null
    },
    supported: function() {
        return false
    },
    setExtent: function(a, c) {
        this.extent = a.clone();
        if (this.map.baseLayer && this.map.baseLayer.wrapDateLine) {
            this.extent = a.wrapDateLine(this.map.getMaxExtent())
        }
        if (c) {
            this.resolution = null
        }
        return true
    },
    setSize: function(a) {
        this.size = a.clone();
        this.resolution = null
    },
    getResolution: function() {
        this.resolution = this.resolution || this.map.getResolution();
        return this.resolution
    },
    drawFeature: function(j, c) {
        if (c == null) {
            c = j.style
        }
        if (j.geometry) {
            var a = j.geometry.getBounds();
            if (a) {
                var i;
                if (this.map.baseLayer && this.map.baseLayer.wrapDateLine) {
                    i = this.map.getMaxExtent()
                }
                if (!a.intersectsBounds(this.extent, {
                    worldBounds: i
                })) {
                    c = {
                        display: "none"
                    }
                } else {
                    this.calculateFeatureDx(a, i)
                }
                var d = this.drawGeometry(j.geometry, c, j.id);
                if (c.display != "none" && c.label && d !== false) {
                    var h = j.geometry.getCentroid();
                    if (c.labelXOffset || c.labelYOffset) {
                        var f = isNaN(c.labelXOffset) ? 0 : c.labelXOffset;
                        var e = isNaN(c.labelYOffset) ? 0 : c.labelYOffset;
                        var g = this.getResolution();
                        h.move(f * g, e * g)
                    }
                    this.drawText(j.id, c, h)
                } else {
                    this.removeText(j.id)
                }
                return d
            }
        }
    },
    calculateFeatureDx: function(f, e) {
        this.featureDx = 0;
        if (e) {
            var g = e.getWidth()
              , c = (this.extent.left + this.extent.right) / 2
              , d = (f.left + f.right) / 2
              , a = Math.round((d - c) / g);
            this.featureDx = a * g
        }
    },
    drawGeometry: function(d, a, c) {},
    drawText: function(d, c, a) {},
    removeText: function(a) {},
    clear: function() {},
    getFeatureIdFromEvent: function(a) {},
    eraseFeatures: function(e) {
        if (!(SuperMap.Util.isArray(e))) {
            e = [e]
        }
        for (var d = 0, a = e.length; d < a; ++d) {
            var c = e[d];
            this.eraseGeometry(c.geometry, c.id);
            this.removeText(c.id)
        }
    },
    eraseGeometry: function(c, a) {},
    moveRoot: function(a) {},
    getRenderLayerId: function() {
        return this.container.id
    },
    applyDefaultSymbolizer: function(c) {
        var a = SuperMap.Util.extend({}, SuperMap.Renderer.defaultSymbolizer);
        if (c.stroke === false) {
            delete a.strokeWidth;
            delete a.strokeColor
        }
        if (c.fill === false) {
            delete a.fillColor
        }
        SuperMap.Util.extend(a, c);
        return a
    },
    CLASS_NAME: "SuperMap.Renderer"
});
SuperMap.Renderer.defaultSymbolizer = {
    fillColor: "#000000",
    strokeColor: "#000000",
    strokeWidth: 2,
    fillOpacity: 1,
    strokeOpacity: 1,
    pointRadius: 0
};
SuperMap.ElementsIndexer = SuperMap.Class({
    maxZIndex: null,
    order: null,
    indices: null,
    compare: null,
    initialize: function(a) {
        this.compare = a ? SuperMap.ElementsIndexer.IndexingMethods.Z_ORDER_Y_ORDER : SuperMap.ElementsIndexer.IndexingMethods.Z_ORDER_DRAWING_ORDER;
        this.clear()
    },
    insert: function(d) {
        if (this.exists(d)) {
            this.remove(d)
        }
        var g = d.id;
        this.determineZIndex(d);
        var e = -1;
        var f = this.order.length;
        var a;
        while (f - e > 1) {
            a = parseInt((e + f) / 2);
            var c = this.compare(this, d, SuperMap.Util.getElement(this.order[a]));
            if (c > 0) {
                e = a
            } else {
                f = a
            }
        }
        this.order.splice(f, 0, g);
        this.indices[g] = this.getZIndex(d);
        return this.getNextElement(f)
    },
    remove: function(c) {
        var e = c.id;
        var a = SuperMap.Util.indexOf(this.order, e);
        if (a >= 0) {
            this.order.splice(a, 1);
            delete this.indices[e];
            if (this.order.length > 0) {
                var d = this.order[this.order.length - 1];
                this.maxZIndex = this.indices[d]
            } else {
                this.maxZIndex = 0
            }
        }
    },
    clear: function() {
        this.order = [];
        this.indices = {};
        this.maxZIndex = 0
    },
    exists: function(a) {
        return ( this.indices[a.id] != null)
    },
    getZIndex: function(a) {
        return a._style.graphicZIndex
    },
    determineZIndex: function(a) {
        var c = a._style.graphicZIndex;
        if (c == null) {
            c = this.maxZIndex;
            a._style.graphicZIndex = c
        } else {
            if (c > this.maxZIndex) {
                this.maxZIndex = c
            }
        }
    },
    getNextElement: function(c) {
        var a = c + 1;
        if (a < this.order.length) {
            var d = SuperMap.Util.getElement(this.order[a]);
            if (d == undefined) {
                d = this.getNextElement(a)
            }
            return d
        } else {
            return null
        }
    },
    CLASS_NAME: "SuperMap.ElementsIndexer"
});
SuperMap.ElementsIndexer.IndexingMethods = {
    Z_ORDER: function(f, e, c) {
        var a = f.getZIndex(e);
        var g = 0;
        if (c) {
            var d = f.getZIndex(c);
            g = a - d
        }
        return g
    },
    Z_ORDER_DRAWING_ORDER: function(d, c, a) {
        var e = SuperMap.ElementsIndexer.IndexingMethods.Z_ORDER(d, c, a);
        if (a && e == 0) {
            e = 1
        }
        return e
    },
    Z_ORDER_Y_ORDER: function(e, d, c) {
        var f = SuperMap.ElementsIndexer.IndexingMethods.Z_ORDER(e, d, c);
        if (c && f === 0) {
            var a = c._boundsBottom - d._boundsBottom;
            f = (a === 0) ? 1 : a
        }
        return f
    }
};
SuperMap.Renderer.Elements = SuperMap.Class(SuperMap.Renderer, {
    rendererRoot: null,
    root: null,
    vectorRoot: null,
    textRoot: null,
    xmlns: null,
    indexer: null,
    BACKGROUND_ID_SUFFIX: "_background",
    LABEL_ID_SUFFIX: "_label",
    initialize: function(a, c) {
        SuperMap.Renderer.prototype.initialize.apply(this, arguments);
        this.rendererRoot = this.createRenderRoot();
        this.root = this.createRoot("_root");
        this.vectorRoot = this.createRoot("_vroot");
        this.textRoot = this.createRoot("_troot");
        this.root.appendChild(this.vectorRoot);
        this.root.appendChild(this.textRoot);
        this.rendererRoot.appendChild(this.root);
        this.container.appendChild(this.rendererRoot);
        if (c && (c.zIndexing || c.yOrdering)) {
            this.indexer = new SuperMap.ElementsIndexer(c.yOrdering)
        }
    },
    destroy: function() {
        this.clear();
        this.rendererRoot = null;
        this.root = null;
        this.xmlns = null;
        SuperMap.Renderer.prototype.destroy.apply(this, arguments)
    },
    clear: function() {
        var c;
        var a = this.vectorRoot;
        if (a) {
            while (c = a.firstChild) {
                a.removeChild(c)
            }
        }
        a = this.textRoot;
        if (a) {
            while (c = a.firstChild) {
                a.removeChild(c)
            }
        }
        if (this.indexer) {
            this.indexer.clear()
        }
    },
    getNodeType: function(c, a) {},
    drawGeometry: function(k, a, e) {
        var j = k.CLASS_NAME;
        var d = true;
        if ((j == "SuperMap.Geometry.Collection") || (j == "SuperMap.Geometry.MultiPoint") || (j == "SuperMap.Geometry.MultiLineString") || (j == "SuperMap.Geometry.MultiPolygon")) {
            for (var g = 0, h = k.components.length; g < h; g++) {
                d = this.drawGeometry(k.components[g], a, e) && d
            }
            return d
        }
        d = false;
        var f = false;
        if (a.display != "none") {
            if (a.backgroundGraphic) {
                this.redrawBackgroundNode(k.id, k, a, e)
            } else {
                f = true
            }
            d = this.redrawNode(k.id, k, a, e)
        }
        if (d == false) {
            var c = document.getElementById(k.id);
            if (c) {
                if (c._style.backgroundGraphic) {
                    f = true
                }
                c.parentNode.removeChild(c)
            }
        }
        if (f) {
            var c = document.getElementById(k.id + this.BACKGROUND_ID_SUFFIX);
            if (c) {
                c.parentNode.removeChild(c)
            }
        }
        return d
    },
    redrawNode: function(h, g, c, f) {
        c = this.applyDefaultSymbolizer(c);
        var d = this.nodeFactory(h, this.getNodeType(g, c));
        d._featureId = f;
        d._boundsBottom = g.getBounds().bottom;
        d._geometryClass = g.CLASS_NAME;
        d._style = c;
        var a = this.drawGeometryNode(d, g, c);
        if (a === false) {
            return false
        }
        d = a.node;
        if (this.indexer) {
            var e = this.indexer.insert(d);
            if (e) {
                this.vectorRoot.insertBefore(d, e)
            } else {
                this.vectorRoot.appendChild(d)
            }
        } else {
            if (d.parentNode !== this.vectorRoot) {
                this.vectorRoot.appendChild(d)
            }
        }
        this.postDraw(d);
        return a.complete
    },
    redrawBackgroundNode: function(f, e, c, d) {
        var a = SuperMap.Util.extend({}, c);
        a.externalGraphic = a.backgroundGraphic;
        a.graphicXOffset = a.backgroundXOffset;
        a.graphicYOffset = a.backgroundYOffset;
        a.graphicZIndex = a.backgroundGraphicZIndex;
        a.graphicWidth = a.backgroundWidth || a.graphicWidth;
        a.graphicHeight = a.backgroundHeight || a.graphicHeight;
        a.backgroundGraphic = null;
        a.backgroundXOffset = null;
        a.backgroundYOffset = null;
        a.backgroundGraphicZIndex = null;
        return this.redrawNode(f + this.BACKGROUND_ID_SUFFIX, e, a, null)
    },
    drawGeometryNode: function(d, f, c) {
        c = c || d._style;
        var a = {
            isFilled: c.fill === undefined ? true : c.fill,
            isStroked: c.stroke === undefined ? !!c.strokeWidth : c.stroke
        };
        var e;
        switch (f.CLASS_NAME) {
        case "SuperMap.Geometry.Point":
            if (c.graphic === false) {
                a.isFilled = false;
                a.isStroked = false
            }
            e = this.drawPoint(d, f);
            break;
        case "SuperMap.Geometry.LineString":
        case "SuperMap.REST.Route":
            a.isFilled = false;
            e = this.drawLineString(d, f);
            break;
        case "SuperMap.Geometry.LinearRing":
            e = this.drawLinearRing(d, f);
            break;
        case "SuperMap.Geometry.Polygon":
            e = this.drawPolygon(d, f);
            break;
        case "SuperMap.Geometry.Surface":
            e = this.drawSurface(d, f);
            break;
        case "SuperMap.Geometry.Rectangle":
            e = this.drawRectangle(d, f);
            break;
        default:
            break
        }
        d._options = a;
        if (e != false) {
            return {
                node: this.setStyle(d, c, a, f),
                complete: e
            }
        } else {
            return false
        }
    },
    postDraw: function(a) {},
    drawPoint: function(a, c) {},
    drawLineString: function(a, c) {},
    drawLinearRing: function(a, c) {},
    drawPolygon: function(a, c) {},
    drawRectangle: function(a, c) {},
    drawCircle: function(a, c) {},
    drawSurface: function(a, c) {},
    removeText: function(c) {
        var a = document.getElementById(c + this.LABEL_ID_SUFFIX);
        if (a) {
            this.textRoot.removeChild(a)
        }
    },
    getFeatureIdFromEvent: function(a) {
        var e = a.target;
        var c = e && e.correspondingUseElement;
        var d = c ? c : (e || a.srcElement);
        var f = d._featureId;
        return f
    },
    eraseGeometry: function(h, g) {
        if ((h.CLASS_NAME == "SuperMap.Geometry.MultiPoint") || (h.CLASS_NAME == "SuperMap.Geometry.MultiLineString") || (h.CLASS_NAME == "SuperMap.Geometry.MultiPolygon") || (h.CLASS_NAME == "SuperMap.Geometry.Collection")) {
            for (var e = 0, a = h.components.length; e < a; e++) {
                this.eraseGeometry(h.components[e], g)
            }
        } else {
            var d = SuperMap.Util.getElement(h.id);
            if (d && d.parentNode) {
                if (d.geometry) {
                    d.geometry.destroy();
                    d.geometry = null
                }
                d.parentNode.removeChild(d);
                if (this.indexer) {
                    this.indexer.remove(d)
                }
                if (d._style.backgroundGraphic) {
                    var c = h.id + this.BACKGROUND_ID_SUFFIX;
                    var f = SuperMap.Util.getElement(c);
                    if (f && f.parentNode) {
                        f.parentNode.removeChild(f)
                    }
                }
            }
        }
    },
    nodeFactory: function(d, a) {
        var c = SuperMap.Util.getElement(d);
        if (c) {
            if (!this.nodeTypeCompare(c, a)) {
                c.parentNode.removeChild(c);
                c = this.nodeFactory(d, a)
            }
        } else {
            c = this.createNode(a, d)
        }
        return c
    },
    nodeTypeCompare: function(c, a) {},
    createNode: function(a, c) {},
    moveRoot: function(c) {
        var a = this.root;
        if (c.root.parentNode == this.rendererRoot) {
            a = c.root
        }
        a.parentNode.removeChild(a);
        c.rendererRoot.appendChild(a)
    },
    getRenderLayerId: function() {
        return this.root.parentNode.parentNode.id
    },
    isComplexSymbol: function(a) {
        return (a != "circle") && !!a
    },
    CLASS_NAME: "SuperMap.Renderer.Elements"
});
SuperMap.Renderer.symbol = {
    star: [350, 75, 379, 161, 469, 161, 397, 215, 423, 301, 350, 250, 277, 301, 303, 215, 231, 161, 321, 161, 350, 75],
    cross: [4, 0, 6, 0, 6, 4, 10, 4, 10, 6, 6, 6, 6, 10, 4, 10, 4, 6, 0, 6, 0, 4, 4, 4, 4, 0],
    x: [0, 0, 25, 0, 50, 35, 75, 0, 100, 0, 65, 50, 100, 100, 75, 100, 50, 65, 25, 100, 0, 100, 35, 50, 0, 0],
    square: [0, 0, 0, 1, 1, 1, 1, 0, 0, 0],
    triangle: [0, 10, 10, 10, 5, 0, 0, 10]
};
SuperMap.Renderer.SVG = SuperMap.Class(SuperMap.Renderer.Elements, {
    xmlns: "http://www.w3.org/2000/svg",
    xlinkns: "http://www.w3.org/1999/xlink",
    MAX_PIXEL: 15000,
    translationParameters: null,
    symbolMetrics: null,
    initialize: function(a) {
        if (!this.supported()) {
            return
        }
        SuperMap.Renderer.Elements.prototype.initialize.apply(this, arguments);
        this.translationParameters = {
            x: 0,
            y: 0
        };
        this.symbolMetrics = {}
    },
    supported: function() {
        var a = "http://www.w3.org/TR/SVG11/feature#";
        return ( document.implementation && (document.implementation.hasFeature("org.w3c.svg", "1.0") || document.implementation.hasFeature(a + "SVG", "1.1") || document.implementation.hasFeature(a + "BasicStructure", "1.1")))
    },
    inValidRange: function(a, f, c) {
        var e = a + (c ? 0 : this.translationParameters.x);
        var d = f + (c ? 0 : this.translationParameters.y);
        return ( e >= -this.MAX_PIXEL && e <= this.MAX_PIXEL && d >= -this.MAX_PIXEL && d <= this.MAX_PIXEL)
    },
    setExtent: function(c, e) {
        SuperMap.Renderer.Elements.prototype.setExtent.apply(this, arguments);
        var a = this.getResolution();
        var g = -c.left / a;
        var f = c.top / a;
        if (e) {
            this.left = g;
            this.top = f;
            var d = "0 0 " + this.size.w + " " + this.size.h;
            this.rendererRoot.setAttributeNS(null, "viewBox", d);
            this.translate(0, 0);
            return true
        } else {
            var h = this.translate(g - this.left, f - this.top);
            if (!h) {
                this.setExtent(c, true)
            }
            return h
        }
    },
    translate: function(a, d) {
        if (!this.inValidRange(a, d, true)) {
            return false
        } else {
            var c = "";
            if (a || d) {
                c = "translate(" + a + "," + d + ")"
            }
            this.root.setAttributeNS(null, "transform", c);
            this.translationParameters = {
                x: a,
                y: d
            };
            return true
        }
    },
    setSize: function(a) {
        SuperMap.Renderer.prototype.setSize.apply(this, arguments);
        this.rendererRoot.setAttributeNS(null, "width", this.size.w);
        this.rendererRoot.setAttributeNS(null, "height", this.size.h)
    },
    getNodeType: function(d, c) {
        var a = null;
        switch (d.CLASS_NAME) {
        case "SuperMap.Geometry.Point":
            if (c.externalGraphic) {
                a = "image"
            } else {
                if (this.isComplexSymbol(c.graphicName)) {
                    a = "svg"
                } else {
                    a = "circle"
                }
            }
            break;
        case "SuperMap.Geometry.Rectangle":
            a = "rect";
            break;
        case "SuperMap.Geometry.LineString":
        case "SuperMap.REST.Route":
            a = "polyline";
            break;
        case "SuperMap.Geometry.LinearRing":
            a = "polygon";
            break;
        case "SuperMap.Geometry.Polygon":
        case "SuperMap.Geometry.Curve":
        case "SuperMap.Geometry.Surface":
            a = "path";
            break;
        default:
            break
        }
        return a
    },
    setStyle: function(p, t, c) {
        t = t || p._style;
        c = c || p._options;
        var l = parseFloat(p.getAttributeNS(null, "r"));
        var k = 1;
        var e;
        if (p._geometryClass == "SuperMap.Geometry.Point" && l) {
            p.style.visibility = "";
            if (t.graphic === false) {
                p.style.visibility = "hidden"
            } else {
                if (t.externalGraphic) {
                    e = this.getPosition(p);
                    if (t.graphicTitle) {
                        p.setAttributeNS(null, "title", t.graphicTitle);
                        var g = this.nodeFactory(null, "title");
                        g.textContent = t.graphicTitle;
                        p.appendChild(g)
                    }
                    if (t.graphicWidth && t.graphicHeight) {
                        p.setAttributeNS(null, "preserveAspectRatio", "none")
                    }
                    var o = t.graphicWidth || t.graphicHeight;
                    var n = t.graphicHeight || t.graphicWidth;
                    o = o ? o : t.pointRadius * 2;
                    n = n ? n : t.pointRadius * 2;
                    var u = (t.graphicXOffset != undefined) ? t.graphicXOffset : -(0.5 * o);
                    var h = (t.graphicYOffset != undefined) ? t.graphicYOffset : -(0.5 * n);
                    var a = t.graphicOpacity || t.fillOpacity;
                    p.setAttributeNS(null, "x", (e.x + u).toFixed());
                    p.setAttributeNS(null, "y", (e.y + h).toFixed());
                    p.setAttributeNS(null, "width", o);
                    p.setAttributeNS(null, "height", n);
                    p.setAttributeNS(this.xlinkns, "href", t.externalGraphic);
                    p.setAttributeNS(null, "style", "opacity: " + a);
                    p.onclick = SuperMap.Renderer.SVG.preventDefault
                } else {
                    if (this.isComplexSymbol(t.graphicName)) {
                        var d = t.pointRadius * 3;
                        var m = d * 2;
                        var f = this.importSymbol(t.graphicName);
                        e = this.getPosition(p);
                        k = this.symbolMetrics[f.id][0] * 3 / m;
                        var i = p.parentNode;
                        var j = p.nextSibling;
                        if (i) {
                            i.removeChild(p)
                        }
                        p.firstChild && p.removeChild(p.firstChild);
                        p.appendChild(f.firstChild.cloneNode(true));
                        p.setAttributeNS(null, "viewBox", f.getAttributeNS(null, "viewBox"));
                        p.setAttributeNS(null, "width", m);
                        p.setAttributeNS(null, "height", m);
                        p.setAttributeNS(null, "x", e.x - d);
                        p.setAttributeNS(null, "y", e.y - d);
                        if (j) {
                            i.insertBefore(p, j)
                        } else {
                            if (i) {
                                i.appendChild(p)
                            }
                        }
                    } else {
                        p.setAttributeNS(null, "r", t.pointRadius)
                    }
                }
            }
            var s = t.rotation;
            if ((s !== undefined || p._rotation !== undefined) && e) {
                p._rotation = s;
                s |= 0;
                if (p.nodeName !== "svg") {
                    p.setAttributeNS(null, "transform", "rotate(" + s + " " + e.x + " " + e.y + ")")
                } else {
                    var q = this.symbolMetrics[f.id];
                    p.firstChild.setAttributeNS(null, "transform", "rotate(" + s + " " + q[1] + " " + q[2] + ")")
                }
            }
        }
        if (c.isFilled) {
            p.setAttributeNS(null, "fill", t.fillColor);
            p.setAttributeNS(null, "fill-opacity", t.fillOpacity)
        } else {
            p.setAttributeNS(null, "fill", "none")
        }
        if (c.isStroked) {
            p.setAttributeNS(null, "stroke", t.strokeColor);
            p.setAttributeNS(null, "stroke-opacity", t.strokeOpacity);
            p.setAttributeNS(null, "stroke-width", t.strokeWidth * k);
            p.setAttributeNS(null, "stroke-linecap", t.strokeLinecap || "round");
            p.setAttributeNS(null, "stroke-linejoin", "round");
            t.strokeDashstyle && p.setAttributeNS(null, "stroke-dasharray", this.dashStyle(t, k))
        } else {
            p.setAttributeNS(null, "stroke", "none")
        }
        if (t.pointerEvents) {
            p.setAttributeNS(null, "pointer-events", t.pointerEvents)
        }
        if (t.cursor != null) {
            p.setAttributeNS(null, "cursor", t.cursor)
        }
        return p
    },
    dashStyle: function(d, c) {
        var a = d.strokeWidth * c;
        var e = d.strokeDashstyle;
        switch (e) {
        case "solid":
            return "none";
        case "dot":
            return [1, 4 * a].join();
        case "dash":
            return [4 * a, 4 * a].join();
        case "dashdot":
            return [4 * a, 4 * a, 1, 4 * a].join();
        case "longdash":
            return [8 * a, 4 * a].join();
        case "longdashdot":
            return [8 * a, 4 * a, 1, 4 * a].join();
        default:
            return SuperMap.String.trim(e).replace(/\s+/g, ",")
        }
    },
    createNode: function(a, d) {
        var c = document.createElementNS(this.xmlns, a);
        if (d) {
            c.setAttributeNS(null, "id", d)
        }
        return c
    },
    nodeTypeCompare: function(c, a) {
        return ( a == c.nodeName)
    },
    createRenderRoot: function() {
        var a = this.nodeFactory(this.container.id + "_svgRoot", "svg");
        a.style.display = "block";
        return a
    },
    createRoot: function(a) {
        return this.nodeFactory(this.container.id + a, "g")
    },
    createDefs: function() {
        var a = this.nodeFactory(this.container.id + "_defs", "defs");
        this.rendererRoot.appendChild(a);
        return a
    },
    drawPoint: function(a, c) {
        return this.drawCircle(a, c, 1)
    },
    drawCircle: function(e, f, c) {
        var d = this.getResolution();
        var a = (f.x / d + this.left);
        var g = (this.top - f.y / d);
        if (this.inValidRange(a, g)) {
            e.setAttributeNS(null, "cx", a);
            e.setAttributeNS(null, "cy", g);
            e.setAttributeNS(null, "r", c);
            return e
        } else {
            return false
        }
    },
    drawLineString: function(c, d) {
        var a = this.getComponentsString(d.components);
        if (a.path) {
            c.setAttributeNS(null, "points", a.path);
            return ( a.complete ? c : null)
        } else {
            return false
        }
    },
    drawLinearRing: function(c, d) {
        var a = this.getComponentsString(d.components);
        if (a.path) {
            c.setAttributeNS(null, "points", a.path);
            return ( a.complete ? c : null)
        } else {
            return false
        }
    },
    drawPolygon: function(c, i) {
        var h = "";
        var k = true;
        var a = true;
        var e, l;
        for (var f = 0, g = i.components.length; f < g; f++) {
            h += " M";
            e = this.getComponentsString(i.components[f].components, " ");
            l = e.path;
            if (l) {
                h += " " + l;
                a = e.complete && a
            } else {
                k = false
            }
        }
        h += " z";
        if (k) {
            c.setAttributeNS(null, "d", h);
            c.setAttributeNS(null, "fill-rule", "evenodd");
            return a ? c : null
        } else {
            return false
        }
    },
    drawRectangle: function(d, e) {
        var c = this.getResolution();
        var a = (e.x / c + this.left);
        var f = (this.top - e.y / c);
        if (this.inValidRange(a, f)) {
            d.setAttributeNS(null, "x", a);
            d.setAttributeNS(null, "y", f);
            d.setAttributeNS(null, "width", e.width / c);
            d.setAttributeNS(null, "height", e.height / c);
            return d
        } else {
            return false
        }
    },
    drawSurface: function(g, j) {
        var h = null;
        var c = true;
        for (var f = 0, a = j.components.length; f < a; f++) {
            if ((f % 3) == 0 && (f / 3) == 0) {
                var e = this.getShortString(j.components[f]);
                if (!e) {
                    c = false
                }
                h = "M " + e
            } else {
                if ((f % 3) == 1) {
                    var e = this.getShortString(j.components[f]);
                    if (!e) {
                        c = false
                    }
                    h += " C " + e
                } else {
                    var e = this.getShortString(j.components[f]);
                    if (!e) {
                        c = false
                    }
                    h += " " + e
                }
            }
        }
        h += " Z";
        if (c) {
            g.setAttributeNS(null, "d", h);
            return g
        } else {
            return false
        }
    },
    drawText: function(f, a, o) {
        var c = this.getResolution();
        var n = (o.x / c + this.left);
        var k = (o.y / c - this.top);
        var m = this.nodeFactory(f + this.LABEL_ID_SUFFIX, "text");
        m.setAttributeNS(null, "x", n);
        m.setAttributeNS(null, "y", -k);
        if (a.fontColor) {
            m.setAttributeNS(null, "fill", a.fontColor)
        }
        if (a.fontOpacity) {
            m.setAttributeNS(null, "opacity", a.fontOpacity)
        }
        if (a.fontFamily) {
            m.setAttributeNS(null, "font-family", a.fontFamily)
        }
        if (a.fontSize) {
            m.setAttributeNS(null, "font-size", a.fontSize)
        }
        if (a.fontWeight) {
            m.setAttributeNS(null, "font-weight", a.fontWeight)
        }
        if (a.fontStyle) {
            m.setAttributeNS(null, "font-style", a.fontStyle)
        }
        if (a.labelSelect === true) {
            m.setAttributeNS(null, "pointer-events", "visible");
            m._featureId = f
        } else {
            m.setAttributeNS(null, "pointer-events", "none")
        }
        var h = a.labelAlign || "cm";
        m.setAttributeNS(null, "text-anchor", SuperMap.Renderer.SVG.LABEL_ALIGN[h[0]] || "middle");
        if (SuperMap.IS_GECKO === true) {
            m.setAttributeNS(null, "dominant-baseline", SuperMap.Renderer.SVG.LABEL_ALIGN[h[1]] || "central")
        }
        var d = a.label.split("\n");
        var g = d.length;
        while (m.childNodes.length > g) {
            m.removeChild(m.lastChild)
        }
        for (var e = 0; e < g; e++) {
            var j = this.nodeFactory(f + this.LABEL_ID_SUFFIX + "_tspan_" + e, "tspan");
            if (a.labelSelect === true) {
                j._featureId = f;
                j._geometry = o;
                j._geometryClass = o.CLASS_NAME
            }
            if (SuperMap.IS_GECKO === false) {
                j.setAttributeNS(null, "baseline-shift", SuperMap.Renderer.SVG.LABEL_VSHIFT[h[1]] || "-35%")
            }
            j.setAttribute("x", n);
            if (e == 0) {
                var l = SuperMap.Renderer.SVG.LABEL_VFACTOR[h[1]];
                if (l == null) {
                    l = -0.5
                }
                j.setAttribute("dy", (l * (g - 1)) + "em")
            } else {
                j.setAttribute("dy", "1em")
            }
            j.textContent = (d[e] === "") ? " " : d[e];
            if (!j.parentNode) {
                m.appendChild(j)
            }
        }
        if (!m.parentNode) {
            this.textRoot.appendChild(m)
        }
    },
    getComponentsString: function(e, d) {
        var g = [];
        var a = true;
        var f = e.length;
        var k = [];
        var h, j;
        for (var c = 0; c < f; c++) {
            j = e[c];
            g.push(j);
            h = this.getShortString(j);
            if (h) {
                k.push(h)
            } else {
                if (c > 0) {
                    if (this.getShortString(e[c - 1])) {
                        k.push(this.clipLine(e[c], e[c - 1]))
                    }
                }
                if (c < f - 1) {
                    if (this.getShortString(e[c + 1])) {
                        k.push(this.clipLine(e[c], e[c + 1]))
                    }
                }
                a = false
            }
        }
        return {
            path: k.join(d || ","),
            complete: a
        }
    },
    clipLine: function(f, i) {
        if (i.equals(f)) {
            return ""
        }
        var g = this.getResolution();
        var c = this.MAX_PIXEL - this.translationParameters.x;
        var a = this.MAX_PIXEL - this.translationParameters.y;
        var e = i.x / g + this.left;
        var l = this.top - i.y / g;
        var d = f.x / g + this.left;
        var j = this.top - f.y / g;
        var h;
        if (d < -c || d > c) {
            h = (j - l) / (d - e);
            d = d < 0 ? -c : c;
            j = l + (d - e) * h
        }
        if (j < -a || j > a) {
            h = (d - e) / (j - l);
            j = j < 0 ? -a : a;
            d = e + (j - l) * h
        }
        return d + "," + j
    },
    getShortString: function(c) {
        var d = this.getResolution();
        var a = (c.x / d + this.left);
        var e = (this.top - c.y / d);
        if (this.inValidRange(a, e)) {
            return a + "," + e
        } else {
            return false
        }
    },
    getPosition: function(a) {
        return ( {
            x: parseFloat(a.getAttributeNS(null, "cx")),
            y: parseFloat(a.getAttributeNS(null, "cy"))
        })
    },
    importSymbol: function(g) {
        if (!this.defs) {
            this.defs = this.createDefs()
        }
        var c = this.container.id + "-" + g;
        var d = document.getElementById(c);
        if (d != null) {
            return d
        }
        var f = SuperMap.Renderer.symbol[g];
        if (!f) {
            throw new Error(g + " is not a valid symbol name")
        }
        var j = this.nodeFactory(c, "symbol");
        var e = this.nodeFactory(null, "polygon");
        j.appendChild(e);
        var o = new SuperMap.Bounds(Number.MAX_VALUE,Number.MAX_VALUE,0,0);
        var m = [];
        var l, k;
        for (var h = 0; h < f.length; h = h + 2) {
            l = f[h];
            k = f[h + 1];
            o.left = Math.min(o.left, l);
            o.bottom = Math.min(o.bottom, k);
            o.right = Math.max(o.right, l);
            o.top = Math.max(o.top, k);
            m.push(l, ",", k)
        }
        e.setAttributeNS(null, "points", m.join(" "));
        var a = o.getWidth();
        var n = o.getHeight();
        var p = [o.left - a, o.bottom - n, a * 3, n * 3];
        j.setAttributeNS(null, "viewBox", p.join(" "));
        this.symbolMetrics[c] = [Math.max(a, n), o.getCenterLonLat().lon, o.getCenterLonLat().lat];
        this.defs.appendChild(j);
        return j
    },
    getFeatureIdFromEvent: function(a) {
        var d = SuperMap.Renderer.Elements.prototype.getFeatureIdFromEvent.apply(this, arguments);
        if (!d) {
            var c = a.target;
            d = c.parentNode && c != this.rendererRoot && c.parentNode._featureId
        }
        return d
    },
    CLASS_NAME: "SuperMap.Renderer.SVG"
});
SuperMap.Renderer.SVG.LABEL_ALIGN = {
    l: "start",
    r: "end",
    b: "bottom",
    t: "hanging"
};
SuperMap.Renderer.SVG.LABEL_VSHIFT = {
    t: "-70%",
    b: "0"
};
SuperMap.Renderer.SVG.LABEL_VFACTOR = {
    t: 0,
    b: -1
};
SuperMap.Renderer.SVG.preventDefault = function(a) {
    a.preventDefault && a.preventDefault()
}
;
SuperMap.Renderer.Canvas = SuperMap.Class(SuperMap.Renderer, {
    hitDetection: true,
    hitOverflow: 0,
    canvas: null,
    features: null,
    pendingRedraw: false,
    initialize: function(a, c) {
        SuperMap.Renderer.prototype.initialize.apply(this, arguments);
        this.root = document.createElement("canvas");
        this.container.appendChild(this.root);
        this.canvas = this.root.getContext("2d");
        this.features = {};
        if (this.hitDetection) {
            this.hitCanvas = document.createElement("canvas");
            this.hitContext = this.hitCanvas.getContext("2d")
        }
    },
    setExtent: function(a, c) {
        SuperMap.Renderer.prototype.setExtent.apply(this, arguments);
        return false
    },
    eraseGeometry: function(c, a) {
        this.eraseFeatures(this.features[a][0])
    },
    supported: function() {
        var a = document.createElement("canvas");
        return !!a.getContext
    },
    setSize: function(c) {
        this.size = c.clone();
        var a = this.root;
        a.style.width = c.w + "px";
        a.style.height = c.h + "px";
        a.width = c.w;
        a.height = c.h;
        this.resolution = null;
        if (this.hitDetection) {
            var d = this.hitCanvas;
            d.style.width = c.w + "px";
            d.style.height = c.h + "px";
            d.width = c.w;
            d.height = c.h
        }
    },
    drawFeature: function(a, c) {
        var e;
        if (a.geometry) {
            c = this.applyDefaultSymbolizer(c || a.style);
            var d = a.geometry.getBounds();
            e = (c.display !== "none") && !!d && d.intersectsBounds(this.extent);
            if (e) {
                this.features[a.id] = [a, c]
            } else {
                delete (this.features[a.id])
            }
            this.pendingRedraw = true
        }
        if (this.pendingRedraw && !this.locked) {
            this.redraw();
            this.pendingRedraw = false
        }
        return e
    },
    drawGeometry: function(f, d, e) {
        var c = f.CLASS_NAME;
        if ((c == "SuperMap.Geometry.Collection") || (c == "SuperMap.Geometry.MultiPoint") || (c == "SuperMap.Geometry.MultiLineString") || (c == "SuperMap.Geometry.MultiPolygon")) {
            for (var a = 0; a < f.components.length; a++) {
                this.drawGeometry(f.components[a], d, e)
            }
            return
        }
        switch (f.CLASS_NAME) {
        case "SuperMap.Geometry.Point":
            this.drawPoint(f, d, e);
            break;
        case "SuperMap.Geometry.LineString":
        case "SuperMap.REST.Route":
            this.drawLineString(f, d, e);
            break;
        case "SuperMap.Geometry.LinearRing":
            this.drawLinearRing(f, d, e);
            break;
        case "SuperMap.Geometry.Polygon":
            this.drawPolygon(f, d, e);
            break;
        default:
            break
        }
    },
    drawExternalGraphic: function(j, a, e) {
        var f = new Image();
        if (a.graphicTitle) {
            f.title = a.graphicTitle
        }
        var c = a.graphicWidth || a.graphicHeight;
        var k = a.graphicHeight || a.graphicWidth;
        c = c ? c : a.pointRadius * 2;
        k = k ? k : a.pointRadius * 2;
        var h = (a.graphicXOffset != undefined) ? a.graphicXOffset : -(0.5 * c);
        var d = (a.graphicYOffset != undefined) ? a.graphicYOffset : -(0.5 * k);
        var g = a.graphicOpacity || a.fillOpacity;
        var i = function() {
            if (!this.features[e]) {
                return
            }
            var o = this.getLocalXY(j);
            var r = o[0];
            var p = o[1];
            if (!isNaN(r) && !isNaN(p)) {
                var l = (r + h) | 0;
                var q = (p + d) | 0;
                var m = this.canvas;
                m.globalAlpha = g;
                var n = SuperMap.Renderer.Canvas.drawImageScaleFactor || (SuperMap.Renderer.Canvas.drawImageScaleFactor = /android 2.1/.test(navigator.userAgent.toLowerCase()) ? 320 / window.screen.width : 1);
                m.drawImage(f, l * n, q * n, c * n, k * n);
                if (this.hitDetection) {
                    this.setHitContextStyle("fill", e);
                    this.hitContext.fillRect(l, q, c, k)
                }
            }
        };
        f.onload = SuperMap.Function.bind(i, this);
        f.src = a.externalGraphic
    },
    setCanvasStyle: function(c, a) {
        if (c === "fill") {
            this.canvas.globalAlpha = a.fillOpacity;
            this.canvas.fillStyle = a.fillColor
        } else {
            if (c === "stroke") {
                this.canvas.globalAlpha = a.strokeOpacity;
                this.canvas.strokeStyle = a.strokeColor;
                this.canvas.lineWidth = a.strokeWidth
            } else {
                this.canvas.globalAlpha = 0;
                this.canvas.lineWidth = 1
            }
        }
    },
    featureIdToHex: function(d) {
        var e = Number(d.split("_").pop()) + 1;
        if (e >= 16777216) {
            this.hitOverflow = e - 16777215;
            e = e % 16777216 + 1
        }
        var c = "000000" + e.toString(16);
        var a = c.length;
        c = "#" + c.substring(a - 6, a);
        return c
    },
    setHitContextStyle: function(c, e, a) {
        var d = this.featureIdToHex(e);
        if (c == "fill") {
            this.hitContext.globalAlpha = 1;
            this.hitContext.fillStyle = d
        } else {
            if (c == "stroke") {
                this.hitContext.globalAlpha = 1;
                this.hitContext.strokeStyle = d;
                this.hitContext.lineWidth = a.strokeWidth + 2
            } else {
                this.hitContext.globalAlpha = 0;
                this.hitContext.lineWidth = 1
            }
        }
    },
    drawPoint: function(h, d, g) {
        if (d.graphic !== false) {
            if (d.externalGraphic) {
                this.drawExternalGraphic(h, d, g)
            } else {
                var e = this.getLocalXY(h);
                var i = e[0];
                var f = e[1];
                if (!isNaN(i) && !isNaN(f)) {
                    var c = Math.PI * 2;
                    var a = d.pointRadius;
                    if (d.fill !== false) {
                        this.setCanvasStyle("fill", d);
                        this.canvas.beginPath();
                        this.canvas.arc(i, f, a, 0, c, true);
                        this.canvas.fill();
                        if (this.hitDetection) {
                            this.setHitContextStyle("fill", g, d);
                            this.hitContext.beginPath();
                            this.hitContext.arc(i, f, a, 0, c, true);
                            this.hitContext.fill()
                        }
                    }
                    if (d.stroke !== false) {
                        this.setCanvasStyle("stroke", d);
                        this.canvas.beginPath();
                        this.canvas.arc(i, f, a, 0, c, true);
                        this.canvas.stroke();
                        if (this.hitDetection) {
                            this.setHitContextStyle("stroke", g, d);
                            this.hitContext.beginPath();
                            this.hitContext.arc(i, f, a, 0, c, true);
                            this.hitContext.stroke()
                        }
                        this.setCanvasStyle("reset")
                    }
                }
            }
        }
    },
    drawLineString: function(d, a, c) {
        a = SuperMap.Util.applyDefaults({
            fill: false
        }, a);
        this.drawLinearRing(d, a, c)
    },
    drawLinearRing: function(d, a, c) {
        if (a.fill !== false) {
            this.setCanvasStyle("fill", a);
            this.renderPath(this.canvas, d, a, c, "fill");
            if (this.hitDetection) {
                this.setHitContextStyle("fill", c, a);
                this.renderPath(this.hitContext, d, a, c, "fill")
            }
        }
        if (a.stroke !== false) {
            this.setCanvasStyle("stroke", a);
            this.renderPath(this.canvas, d, a, c, "stroke");
            if (this.hitDetection) {
                this.setHitContextStyle("stroke", c, a);
                this.renderPath(this.hitContext, d, a, c, "stroke")
            }
        }
        this.setCanvasStyle("reset")
    },
    renderPath: function(d, l, a, f, j) {
        var g = l.components;
        var h = g.length;
        d.beginPath();
        var c = this.getLocalXY(g[0]);
        var m = c[0];
        var k = c[1];
        if (!isNaN(m) && !isNaN(k)) {
            d.moveTo(c[0], c[1]);
            for (var e = 1; e < h; ++e) {
                var n = this.getLocalXY(g[e]);
                d.lineTo(n[0], n[1])
            }
            if (j === "fill") {
                d.fill()
            } else {
                d.stroke()
            }
        }
    },
    drawPolygon: function(g, d, f) {
        var e = g.components;
        var a = e.length;
        this.drawLinearRing(e[0], d, f);
        for (var c = 1; c < a; ++c) {
            this.canvas.globalCompositeOperation = "destination-out";
            if (this.hitDetection) {
                this.hitContext.globalCompositeOperation = "destination-out"
            }
            this.drawLinearRing(e[c], SuperMap.Util.applyDefaults({
                stroke: false,
                fillOpacity: 1
            }, d), f);
            this.canvas.globalCompositeOperation = "source-over";
            if (this.hitDetection) {
                this.hitContext.globalCompositeOperation = "source-over"
            }
            this.drawLinearRing(e[c], SuperMap.Util.applyDefaults({
                fill: false
            }, d), f)
        }
    },
    drawText: function(m, a) {
        a = SuperMap.Util.extend({
            fontColor: "#000000",
            labelAlign: "cm"
        }, a);
        var n = this.getLocalXY(m);
        this.setCanvasStyle("reset");
        this.canvas.fillStyle = a.fontColor;
        this.canvas.globalAlpha = a.fontOpacity || 1;
        var e = [a.fontStyle ? a.fontStyle : "normal", "normal", a.fontWeight ? a.fontWeight : "normal", a.fontSize ? a.fontSize : "1em", a.fontFamily ? a.fontFamily : "sans-serif"].join(" ");
        var d = a.label.split("\n");
        var g = d.length;
        if (this.canvas.fillText) {
            this.canvas.font = e;
            this.canvas.textAlign = SuperMap.Renderer.Canvas.LABEL_ALIGN[a.labelAlign[0]] || "center";
            this.canvas.textBaseline = SuperMap.Renderer.Canvas.LABEL_ALIGN[a.labelAlign[1]] || "middle";
            var k = SuperMap.Renderer.Canvas.LABEL_FACTOR[a.labelAlign[1]];
            if (k == null) {
                k = -0.5
            }
            var l = this.canvas.measureText("Mg").height || this.canvas.measureText("xx").width;
            n[1] += l * k * (g - 1);
            for (var f = 0; f < g; f++) {
                this.canvas.fillText(d[f], n[0], n[1] + (l * f))
            }
        } else {
            if (this.canvas.mozDrawText) {
                this.canvas.mozTextStyle = e;
                var c = SuperMap.Renderer.Canvas.LABEL_FACTOR[a.labelAlign[0]];
                if (c == null) {
                    c = -0.5
                }
                var k = SuperMap.Renderer.Canvas.LABEL_FACTOR[a.labelAlign[1]];
                if (k == null) {
                    k = -0.5
                }
                var l = this.canvas.mozMeasureText("xx");
                n[1] += l * (1 + (k * g));
                for (var f = 0; f < g; f++) {
                    var j = n[0] + (c * this.canvas.mozMeasureText(d[f]));
                    var h = n[1] + (f * l);
                    this.canvas.translate(j, h);
                    this.canvas.mozDrawText(d[f]);
                    this.canvas.translate(-j, -h)
                }
            }
        }
        this.setCanvasStyle("reset")
    },
    getLocalXY: function(c) {
        var d = this.getResolution();
        var e = this.extent;
        var a = (c.x / d + (-e.left / d));
        var f = ((e.top / d) - c.y / d);
        return [a, f]
    },
    clear: function() {
        var a = this.root.height;
        var c = this.root.width;
        this.canvas.clearRect(0, 0, c, a);
        this.features = {};
        if (this.hitDetection) {
            this.hitContext.clearRect(0, 0, c, a)
        }
    },
    getFeatureIdFromEvent: function(c) {
        var d = null;
        if (this.hitDetection) {
            if (!this.map.dragging) {
                var f = c.xy;
                var a = f.x | 0;
                var h = f.y | 0;
                var e = this.hitContext.getImageData(a, h, 1, 1).data;
                if (e[3] === 255) {
                    var g = e[2] + (256 * (e[1] + (256 * e[0])));
                    if (g) {
                        d = this.features["SuperMap.Feature.Vector_" + (g - 1 + this.hitOverflow)][0]
                    }
                }
            }
        }
        return d
    },
    eraseFeatures: function(c) {
        if (!(SuperMap.Util.isArray(c))) {
            c = [c]
        }
        for (var a = 0; a < c.length; ++a) {
            delete this.features[c[a].id]
        }
        this.redraw()
    },
    redraw: function() {
        if (!this.locked) {
            var h = this.root.height;
            var d = this.root.width;
            this.canvas.clearRect(0, 0, d, h);
            if (this.hitDetection) {
                this.hitContext.clearRect(0, 0, d, h)
            }
            var g = [];
            var k, a;
            for (var c in this.features) {
                if (!this.features.hasOwnProperty(c)) {
                    continue
                }
                k = this.features[c][0];
                a = this.features[c][1];
                this.drawGeometry(k.geometry, a, k.id);
                if (a.label) {
                    g.push([k, a])
                }
            }
            var j;
            for (var e = 0, f = g.length; e < f; ++e) {
                j = g[e];
                this.drawText(j[0].geometry.getCentroid(), j[1])
            }
        }
    },
    CLASS_NAME: "SuperMap.Renderer.Canvas"
});
SuperMap.Renderer.Canvas.LABEL_ALIGN = {
    l: "left",
    r: "right",
    t: "top",
    b: "bottom"
};
SuperMap.Renderer.Canvas.LABEL_FACTOR = {
    l: 0,
    r: -1,
    t: 0,
    b: -1
};
SuperMap.Renderer.Canvas.drawImageScaleFactor = null;
SuperMap.Renderer.VML = SuperMap.Class(SuperMap.Renderer.Elements, {
    xmlns: "urn:schemas-microsoft-com:vml",
    symbolCache: {},
    offset: null,
    initialize: function(c) {
        if (!this.supported()) {
            return
        }
        if (!document.namespaces.olv) {
            document.namespaces.add("olv", this.xmlns);
            var f = document.createStyleSheet();
            var d = ["shape", "rect", "oval", "fill", "stroke", "imagedata", "group", "textbox"];
            for (var e = 0, a = d.length; e < a; e++) {
                f.addRule("olv\\:" + d[e], "behavior: url(#default#VML); position: absolute; display: inline-block;")
            }
        }
        SuperMap.Renderer.Elements.prototype.initialize.apply(this, arguments)
    },
    supported: function() {
        try {
            return !!(document.namespaces)
        } catch (a) {
            return true
        }
    },
    setExtent: function(k, a) {
        SuperMap.Renderer.Elements.prototype.setExtent.apply(this, arguments);
        var d = this.getResolution();
        var c = (k.left / d) | 0;
        var g = (k.top / d - this.size.h) | 0;
        if (a || !this.offset) {
            this.offset = {
                x: c,
                y: g
            };
            c = 0;
            g = 0
        } else {
            c = c - this.offset.x;
            g = g - this.offset.y
        }
        var m = c + " " + g;
        this.root.coordorigin = m;
        var j = [this.root, this.vectorRoot, this.textRoot];
        var h;
        for (var e = 0, f = j.length; e < f; ++e) {
            h = j[e];
            var l = this.size.w + " " + this.size.h;
            h.coordsize = l
        }
        this.root.style.flip = "y";
        return true
    },
    setSize: function(g) {
        SuperMap.Renderer.prototype.setSize.apply(this, arguments);
        var e = [this.rendererRoot, this.root, this.vectorRoot, this.textRoot];
        var d = this.size.w + "px";
        var j = this.size.h + "px";
        var c;
        for (var f = 0, a = e.length; f < a; ++f) {
            c = e[f];
            c.style.width = d;
            c.style.height = j
        }
    },
    getNodeType: function(d, c) {
        var a = null;
        switch (d.CLASS_NAME) {
        case "SuperMap.Geometry.Point":
            if (c.externalGraphic) {
                a = "olv:rect"
            } else {
                if (this.isComplexSymbol(c.graphicName)) {
                    a = "olv:shape"
                } else {
                    a = "olv:oval"
                }
            }
            break;
        case "SuperMap.Geometry.Rectangle":
            a = "olv:rect";
            break;
        case "SuperMap.Geometry.LineString":
        case "SuperMap.Geometry.LinearRing":
        case "SuperMap.Geometry.Polygon":
        case "SuperMap.Geometry.Curve":
        case "SuperMap.Geometry.Surface":
        case "SuperMap.REST.Route":
            a = "olv:shape";
            break;
        default:
            break
        }
        return a
    },
    setStyle: function(f, c, r, l) {
        c = c || f._style;
        r = r || f._options;
        var d = c.fillColor;
        if (f._geometryClass === "SuperMap.Geometry.Point") {
            if (c.externalGraphic) {
                r.isFilled = true;
                if (c.graphicTitle) {
                    f.title = c.graphicTitle
                }
                var e = c.graphicWidth || c.graphicHeight;
                var m = c.graphicHeight || c.graphicWidth;
                e = e ? e : c.pointRadius * 2;
                m = m ? m : c.pointRadius * 2;
                var h = this.getResolution();
                var j = (c.graphicXOffset != undefined) ? c.graphicXOffset : -(0.5 * e);
                var g = (c.graphicYOffset != undefined) ? c.graphicYOffset : -(0.5 * m);
                f.style.left = (((l.x / h - this.offset.x) + j) | 0) + "px";
                f.style.top = (((l.y / h - this.offset.y) - (g + m)) | 0) + "px";
                f.style.width = e + "px";
                f.style.height = m + "px";
                f.style.flip = "y";
                d = "none";
                r.isStroked = false
            } else {
                if (this.isComplexSymbol(c.graphicName)) {
                    var a = this.importSymbol(c.graphicName);
                    f.path = a.path;
                    f.coordorigin = a.left + "," + a.bottom;
                    var q = a.size;
                    f.coordsize = q + "," + q;
                    this.drawCircle(f, l, c.pointRadius);
                    f.style.flip = "y"
                } else {
                    this.drawCircle(f, l, c.pointRadius)
                }
            }
        }
        if (r.isFilled) {
            f.fillcolor = d
        } else {
            f.filled = "false"
        }
        var k = f.getElementsByTagName("fill");
        var p = (k.length == 0) ? null : k[0];
        if (!r.isFilled) {
            if (p) {
                f.removeChild(p)
            }
        } else {
            if (!p) {
                p = this.createNode("olv:fill", f.id + "_fill")
            }
            p.opacity = c.fillOpacity;
            if (f._geometryClass === "SuperMap.Geometry.Point" && c.externalGraphic) {
                if (c.graphicOpacity) {
                    p.opacity = c.graphicOpacity
                }
                p.src = c.externalGraphic;
                p.type = "frame";
                if (!(c.graphicWidth && c.graphicHeight)) {
                    p.aspect = "atmost"
                }
            }
            if (p.parentNode != f) {
                f.appendChild(p)
            }
        }
        var o = c.rotation;
        if ((o !== undefined || f._rotation !== undefined) ) {
            f._rotation = o;
            if (c.externalGraphic) {
                this.graphicRotate(f, j, g, c);
                p.opacity = 0
            } else {
                if (f._geometryClass === "SuperMap.Geometry.Point") {
                    f.style.rotation = o || 0
                }
            }
        }
        var i = f.getElementsByTagName("stroke");
        var n = (i.length == 0) ? null : i[0];
        if (!r.isStroked) {
            f.stroked = false;
            if (n) {
                n.on = false
            }
        } else {
            if (!n) {
                n = this.createNode("olv:stroke", f.id + "_stroke");
                f.appendChild(n)
            }
            n.on = true;
            n.color = c.strokeColor;
            n.weight = c.strokeWidth + "px";
            n.opacity = c.strokeOpacity;
            n.endcap = c.strokeLinecap == "butt" ? "flat" : (c.strokeLinecap || "round");
            if (c.strokeDashstyle) {
                n.dashstyle = this.dashStyle(c)
            }
        }
        if (c.cursor != "inherit" && c.cursor != null) {
            f.style.cursor = c.cursor
        }
        return f
    },
    graphicRotate: function(o, s, f, r) {
        var r = r || o._style;
        var p = r.rotation || 0;
        var a, k;
        if (!(r.graphicWidth && r.graphicHeight)) {
            var t = new Image();
            t.onreadystatechange = SuperMap.Function.bind(function() {
                if (t.readyState == "complete" || t.readyState == "interactive") {
                    a = t.width / t.height;
                    k = Math.max(r.pointRadius * 2, r.graphicWidth || 0, r.graphicHeight || 0);
                    s = s * a;
                    r.graphicWidth = k * a;
                    r.graphicHeight = k;
                    this.graphicRotate(o, s, f, r)
                }
            }, this);
            t.src = r.externalGraphic;
            return
        } else {
            k = Math.max(r.graphicWidth, r.graphicHeight);
            a = r.graphicWidth / r.graphicHeight
        }
        var n = Math.round(r.graphicWidth || k * a);
        var l = Math.round(r.graphicHeight || k);
        o.style.width = n + "px";
        o.style.height = l + "px";
        var m = document.getElementById(o.id + "_image");
        if (!m) {
            m = this.createNode("olv:imagedata", o.id + "_image");
            o.appendChild(m)
        }
        m.style.width = n + "px";
        m.style.height = l + "px";
        m.src = r.externalGraphic;
        m.style.filter = "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='', sizingMethod='scale')";
        var g = p * Math.PI / 180;
        var i = Math.sin(g);
        var e = Math.cos(g);
        var h = "progid:DXImageTransform.Microsoft.Matrix(M11=" + e + ",M12=" + (-i) + ",M21=" + i + ",M22=" + e + ",SizingMethod='auto expand')\n";
        var c = r.graphicOpacity || r.fillOpacity;
        if (c && c != 1) {
            h += "progid:DXImageTransform.Microsoft.BasicImage(opacity=" + c + ")\n"
        }
        o.style.filter = h;
        var q = new SuperMap.Geometry.Point(-s,-f);
        var d = new SuperMap.Bounds(0,0,n,l).toGeometry();
        d.rotate(r.rotation, q);
        var j = d.getBounds();
        o.style.left = Math.round(parseInt(o.style.left) + j.left) + "px";
        o.style.top = Math.round(parseInt(o.style.top) - j.bottom) + "px"
    },
    postDraw: function(a) {
        a.style.visibility = "visible";
        var d = a._style.fillColor;
        var c = a._style.strokeColor;
        if (d == "none" && a.fillcolor != d) {
            a.fillcolor = d
        }
        if (c == "none" && a.strokecolor != c) {
            a.strokecolor = c
        }
    },
    setNodeDimension: function(c, f) {
        var e = f.getBounds();
        if (e) {
            var a = this.getResolution();
            var d = new SuperMap.Bounds((e.left / a - this.offset.x) | 0,(e.bottom / a - this.offset.y) | 0,(e.right / a - this.offset.x) | 0,(e.top / a - this.offset.y) | 0);
            c.style.left = d.left + "px";
            c.style.top = d.top + "px";
            c.style.width = d.getWidth() + "px";
            c.style.height = d.getHeight() + "px";
            c.coordorigin = d.left + " " + d.top;
            c.coordsize = d.getWidth() + " " + d.getHeight()
        }
    },
    dashStyle: function(a) {
        var d = a.strokeDashstyle;
        switch (d) {
        case "solid":
        case "dot":
        case "dash":
        case "dashdot":
        case "longdash":
        case "longdashdot":
            return d;
        default:
            var c = d.split(/[ ,]/);
            if (c.length == 2) {
                if (1 * c[0] >= 2 * c[1]) {
                    return "longdash"
                }
                return (c[0] == 1 || c[1] == 1) ? "dot" : "dash"
            } else {
                if (c.length == 4) {
                    return (1 * c[0] >= 2 * c[1]) ? "longdashdot" : "dashdot"
                }
            }
            return "solid"
        }
    },
    createNode: function(a, d) {
        var c = document.createElement(a);
        if (d) {
            c.id = d
        }
        c.unselectable = "on";
        c.onselectstart = SuperMap.Function.False;
        return c
    },
    nodeTypeCompare: function(d, c) {
        var e = c;
        var a = e.indexOf(":");
        if (a != -1) {
            e = e.substr(a + 1)
        }
        var f = d.nodeName;
        a = f.indexOf(":");
        if (a != -1) {
            f = f.substr(a + 1)
        }
        return ( e == f)
    },
    createRenderRoot: function() {
        return this.nodeFactory(this.container.id + "_vmlRoot", "div")
    },
    createRoot: function(a) {
        return this.nodeFactory(this.container.id + a, "olv:group")
    },
    drawPoint: function(a, c) {
        return this.drawCircle(a, c, 1)
    },
    drawCircle: function(e, f, a) {
        if (!isNaN(f.x) && !isNaN(f.y)) {
            var c = this.getResolution();
            e.style.left = (((f.x / c - this.offset.x) | 0) - a) + "px";
            e.style.top = (((f.y / c - this.offset.y) | 0) - a) + "px";
            var d = a * 2;
            e.style.width = d + "px";
            e.style.height = d + "px";
            return e
        }
        return false
    },
    drawLineString: function(a, c) {
        return this.drawLine(a, c, false)
    },
    drawLinearRing: function(a, c) {
        return this.drawLine(a, c, true)
    },
    drawLine: function(c, l, h) {
        this.setNodeDimension(c, l);
        var d = this.getResolution();
        var a = l.components.length;
        var f = new Array(a);
        var j, m, k;
        for (var g = 0; g < a; g++) {
            j = l.components[g];
            m = (j.x / d - this.offset.x) | 0;
            k = (j.y / d - this.offset.y) | 0;
            f[g] = " " + m + "," + k + " l "
        }
        var e = (h) ? " x e" : " e";
        c.path = "m" + f.join("") + e;
        return c
    },
    drawPolygon: function(d, n) {
        this.setNodeDimension(d, n);
        var e = this.getResolution();
        var s = [];
        var f, l, p, a, h, c, g, r, k, q, o, m;
        for (f = 0,
        l = n.components.length; f < l; f++) {
            s.push("m");
            p = n.components[f].components;
            a = (f === 0);
            h = null;
            c = null;
            for (g = 0,
            r = p.length; g < r; g++) {
                k = p[g];
                o = (k.x / e - this.offset.x) | 0;
                m = (k.y / e - this.offset.y) | 0;
                q = " " + o + "," + m;
                s.push(q);
                if (g == 0) {
                    s.push(" l")
                }
                if (!a) {
                    if (!h) {
                        h = q
                    } else {
                        if (h != q) {
                            if (!c) {
                                c = q
                            } else {
                                if (c != q) {
                                    a = true
                                }
                            }
                        }
                    }
                }
            }
            s.push(a ? " x " : " ")
        }
        s.push("e");
        d.path = s.join("");
        return d
    },
    drawRectangle: function(c, d) {
        var a = this.getResolution();
        c.style.left = ((d.x / a - this.offset.x) | 0) + "px";
        c.style.top = ((d.y / a - this.offset.y) | 0) + "px";
        c.style.width = ((d.width / a) | 0) + "px";
        c.style.height = ((d.height / a) | 0) + "px";
        return c
    },
    drawText: function(e, a, i) {
        var h = this.nodeFactory(e + this.LABEL_ID_SUFFIX, "olv:rect");
        var g = this.nodeFactory(e + this.LABEL_ID_SUFFIX + "_textbox", "olv:textbox");
        var d = this.getResolution();
        h.style.left = ((i.x / d - this.offset.x) | 0) + "px";
        h.style.top = ((i.y / d - this.offset.y) | 0) + "px";
        h.style.flip = "y";
        g.innerText = a.label;
        if (a.cursor != "inherit" && a.cursor != null) {
            g.style.cursor = a.cursor
        }
        if (a.fontColor) {
            g.style.color = a.fontColor
        }
        if (a.fontOpacity) {
            g.style.filter = "alpha(opacity=" + (a.fontOpacity * 100) + ")"
        }
        if (a.fontFamily) {
            g.style.fontFamily = a.fontFamily
        }
        if (a.fontSize) {
            g.style.fontSize = a.fontSize
        }
        if (a.fontWeight) {
            g.style.fontWeight = a.fontWeight
        }
        if (a.fontStyle) {
            g.style.fontStyle = a.fontStyle
        }
        if (a.labelSelect === true) {
            h._featureId = e;
            g._featureId = e;
            g._geometry = i;
            g._geometryClass = i.CLASS_NAME
        }
        g.style.whiteSpace = "nowrap";
        g.inset = "1px,0px,0px,0px";
        if (!h.parentNode) {
            h.appendChild(g);
            this.textRoot.appendChild(h)
        }
        var f = a.labelAlign || "cm";
        if (f.length == 1) {
            f += "m"
        }
        var j = g.clientWidth * (SuperMap.Renderer.VML.LABEL_SHIFT[f.substr(0, 1)]);
        var c = g.clientHeight * (SuperMap.Renderer.VML.LABEL_SHIFT[f.substr(1, 1)]);
        h.style.left = parseInt(h.style.left) - j - 1 + "px";
        h.style.top = parseInt(h.style.top) + c + "px"
    },
    drawSurface: function(a, h) {
        this.setNodeDimension(a, h);
        var c = this.getResolution();
        var k = [];
        var e, j, g;
        for (var d = 0, f = h.components.length; d < f; d++) {
            e = h.components[d];
            j = (e.x / c - this.offset.x) | 0;
            g = (e.y / c - this.offset.y) | 0;
            if ((d % 3) == 0 && (d / 3) == 0) {
                k.push("m")
            } else {
                if ((d % 3) == 1) {
                    k.push(" c")
                }
            }
            k.push(" " + j + "," + g)
        }
        k.push(" x e");
        a.path = k.join("");
        return a
    },
    moveRoot: function(c) {
        var a = this.map.getLayer(c.container.id);
        if (a instanceof SuperMap.Layer.Vector.RootContainer) {
            a = this.map.getLayer(this.container.id)
        }
        a && a.renderer.clear();
        SuperMap.Renderer.Elements.prototype.moveRoot.apply(this, arguments);
        a && a.redraw()
    },
    importSymbol: function(e) {
        var c = this.container.id + "-" + e;
        var a = this.symbolCache[c];
        if (a) {
            return a
        }
        var d = SuperMap.Renderer.symbol[e];
        if (!d) {
            throw new Error(e + " is not a valid symbol name")
        }
        var l = new SuperMap.Bounds(Number.MAX_VALUE,Number.MAX_VALUE,0,0);
        var f = ["m"];
        for (var g = 0; g < d.length; g = g + 2) {
            var j = d[g];
            var h = d[g + 1];
            l.left = Math.min(l.left, j);
            l.bottom = Math.min(l.bottom, h);
            l.right = Math.max(l.right, j);
            l.top = Math.max(l.top, h);
            f.push(j);
            f.push(h);
            if (g == 0) {
                f.push("l")
            }
        }
        f.push("x e");
        var m = f.join(" ");
        var k = (l.getWidth() - l.getHeight()) / 2;
        if (k > 0) {
            l.bottom = l.bottom - k;
            l.top = l.top + k
        } else {
            l.left = l.left + k;
            l.right = l.right - k
        }
        a = {
            path: m,
            size: l.getWidth(),
            left: l.left,
            bottom: l.bottom
        };
        this.symbolCache[c] = a;
        return a
    },
    CLASS_NAME: "SuperMap.Renderer.VML"
});
SuperMap.Renderer.VML.LABEL_SHIFT = {
    l: 0,
    c: 0.5,
    r: 1,
    t: 0,
    m: 0.5,
    b: 1
};
SuperMap.Renderer.Canvas2 = SuperMap.Class(SuperMap.Renderer, {
    hitDetection: true,
    hitOverflow: 0,
    canvas: null,
    features: null,
    pendingRedraw: false,
    backCanvas: null,
    backCanvasContext: null,
    lastBounds: null,
    backCanvasPosition: null,
    hitCanvasBack: null,
    hitContextBack: null,
    featuresIds: [],
    selectFeatures: null,
    layer: null,
    transitionObj: null,
    externalGraphicCount: null,
    labelMap: null,
    polygonCanvas: null,
    polygonContext: null,
    initialize: function(a, c, d) {
        SuperMap.Renderer.prototype.initialize.apply(this, arguments);
        this.root = document.createElement("canvas");
        this.canvas = this.root.getContext("2d");
        this.container.appendChild(this.root);
        this.backCanvas = document.createElement("canvas");
        this.backCanvasContext = this.backCanvas.getContext("2d");
        this.polygonCanvas = document.createElement("canvas");
        this.polygonContext = this.polygonCanvas.getContext("2d");
        this.features = {};
        this.selectFeatures = {};
        if (d) {
            this.layer = d
        }
        this.transitionObj = new SuperMap.Animal2(this.layer);
        if (this.hitDetection) {
            this.hitCanvas = document.createElement("canvas");
            this.hitContext = this.hitCanvas.getContext("2d");
            this.hitCanvasBack = document.createElement("canvas");
            this.hitContextBack = this.hitCanvasBack.getContext("2d")
        }
    },
    setExtent: function(a, c) {
        this.lastBounds = !!this.extent ? this.extent.clone() : a.clone();
        c && this.resetCanvas();
        SuperMap.Renderer.prototype.setExtent.apply(this, arguments);
        return false
    },
    setResolution: function(a) {
        this.resolution = a
    },
    restoreCanvas: function() {
        this.backCanvasPosition = this.map.getLonLatFromLayerPx(new SuperMap.Pixel(parseInt(this.container.style.left),parseInt(this.container.style.top)));
        this.backCanvasContext.clearRect(0, 0, this.size.w, this.size.h);
        this.backCanvasContext.drawImage(this.root, 0, 0);
        if (this.hitDetection) {
            this.hitContextBack.clearRect(0, 0, this.size.w, this.size.h);
            this.hitContextBack.drawImage(this.hitCanvas, 0, 0)
        }
    },
    resetCanvas: function() {
        this.backCanvasContext.clearRect(0, 0, this.size.w, this.size.h);
        if (this.hitDetection) {
            this.hitContextBack.clearRect(0, 0, this.size.w, this.size.h)
        }
    },
    eraseGeometry: function(c, a) {
        this.eraseFeatures(this.features[a][0])
    },
    calculateFeatureDx: function(f, e) {
        this.featureDx = 0;
        if (e) {
            var g = e.getWidth()
              , c = (this.extent.left + this.extent.right) / 2
              , d = (f.left + f.right) / 2
              , a = Math.round((d - c) / g);
            this.featureDx = a * g
        }
    },
    supported: function() {
        var a = document.createElement("canvas");
        return !!a.getContext
    },
    setSize: function(c) {
        this.size = c.clone();
        var a = this.root;
        a.style.width = c.w + "px";
        a.style.height = c.h + "px";
        a.width = c.w;
        a.height = c.h;
        this.backCanvas.width = c.w;
        this.backCanvas.height = c.h;
        this.backCanvas.style.width = c.w + "px";
        this.backCanvas.style.height = c.h + "px";
        this.resolution = null;
        this.toClearFeatures = {};
        if (this.hitDetection) {
            var d = this.hitCanvas;
            d.style.width = c.w + "px";
            d.style.height = c.h + "px";
            d.width = c.w;
            d.height = c.h;
            this.hitCanvasBack.style.width = c.w + "px";
            this.hitCanvasBack.style.height = c.h + "px";
            this.hitCanvasBack.width = c.w;
            this.hitCanvasBack.height = c.h
        }
        this.polygonCanvas.width = c.w;
        this.polygonCanvas.height = c.h;
        this.polygonCanvas.style.width = c.w + "px";
        this.polygonCanvas.style.height = c.h + "px"
    },
    getPointBounds: function(h, u, q) {
        q = q || this.map.getResolution();
        var g = h.geometry;
        var a;
        if (u.externalGraphic) {
            var c = u.graphicWidth || u.graphicHeight;
            var m = u.graphicHeight || u.graphicWidth;
            c = c ? c : u.pointRadius * 2;
            m = m ? m : u.pointRadius * 2;
            var y = (u.graphicXOffset != undefined) ? u.graphicXOffset : -(0.5 * c);
            var l = (u.graphicYOffset != undefined) ? u.graphicYOffset : -(0.5 * m);
            var e, w, n, k, f, z, p;
            if (u.rotation) {
                p = u.rotation / 180 * Math.PI;
                f = Math.sin(p);
                z = Math.cos(p)
            }
            if (p) {
                var x, v, o, t = [];
                t.push({
                    x: y,
                    y: -l
                });
                t.push({
                    x: y,
                    y: -l - m
                });
                t.push({
                    x: y + c,
                    y: -l - m
                });
                t.push({
                    x: y + c,
                    y: -l
                });
                for (var s = 0; s < 4; s++) {
                    o = t[s];
                    x = z * o.x + f * o.y;
                    v = f * o.x - z * o.y;
                    t[s] = {
                        x: x,
                        y: v
                    }
                }
                e = w = t[0].x;
                n = k = t[0].y;
                for (var r = 1; r < 4; r++) {
                    if (e > t[r].x) {
                        e = t[r].x
                    }
                    if (t[r].x > w) {
                        w = t[r].x
                    }
                    if (n > t[r].y) {
                        n = t[r].y
                    }
                    if (t[r].y > k) {
                        k = t[r].y
                    }
                }
                e = g.x + e * q;
                w = g.x + w * q;
                n = g.y - n * q;
                k = g.y - k * q
            } else {
                e = g.x + y * q;
                w = e + c * q;
                n = g.y - l * q;
                k = n - m * q
            }
            a = new SuperMap.Bounds(e,k,w,n)
        } else {
            var d = 0;
            if (u.strokeWidth) {
                d += u.strokeWidth
            }
            if (u.pointRadius) {
                d += u.pointRadius
            }
            a = new SuperMap.Bounds(g.x + (-d * q),g.y + (-d * q),g.x + (d * q),g.y + (d * q))
        }
        return a
    },
    drawFeature: function(o, c, i) {
        var e, n, g;
        var d = !!i && !!i.isSelected;
        var j = !!i && !!i.isNewAdd;
        var h = !!i && !!i.isModify;
        if (o.geometry == null || !o.geometry.getBounds()) {
            return false
        }
        if (o.geometry) {
            var a;
            if (o.geometry.CLASS_NAME == "SuperMap.Geometry.Point") {
                a = this.getPointBounds(o, c)
            } else {
                var a = o.geometry.getBounds()
            }
            var l;
            if (this.map.baseLayer && this.map.baseLayer.wrapDateLine) {
                l = this.map.getMaxExtent()
            }
            var k = a && a.intersectsBounds(this.extent, {
                worldBounds: l
            });
            var f = false;
            var m = false;
            if (!j) {
                f = this.lastBounds.containsBounds(a);
                m = !f && this.lastBounds.intersectsBounds(a) || d
            }
            n = (c.display !== "none") && !!a && k;
            e = n && !f || (d && n) || (j && n);
            if (j) {
                this.selectFeatures[o.id] = [o, c]
            }
            if (e) {
                this.features[o.id] = [o, c, m]
            } else {
                delete (this.features[o.id])
            }
            this.pendingRedraw = true
        }
        if (this.pendingRedraw && !this.locked) {
            this.redraw();
            this.pendingRedraw = false
        }
        return true
    },
    setCanvasStyle: function(a, d, c) {
        if (d === "fill") {
            a.globalAlpha = c.fillOpacity;
            a.fillStyle = c.fillColor
        } else {
            if (d === "stroke") {
                a.globalAlpha = c.strokeOpacity;
                a.strokeStyle = c.strokeColor;
                a.lineWidth = c.strokeWidth
            } else {
                if (d === "clear") {
                    a.globalAlpha = 1;
                    a.fillStyle = "rgb(255, 255, 255)"
                } else {
                    a.globalAlpha = 1;
                    a.lineWidth = 1
                }
            }
        }
    },
    setHitContextStyle: function(c, e, a) {
        var d = this.featureIdToHex(e);
        if (c == "fill") {
            this.hitContext.globalAlpha = 1;
            this.hitContext.fillStyle = d
        } else {
            if (c == "stroke") {
                this.hitContext.globalAlpha = 1;
                this.hitContext.strokeStyle = d;
                this.hitContext.lineWidth = a.strokeWidth + 2
            } else {
                this.hitContext.globalAlpha = 1;
                this.hitContext.lineWidth = 1
            }
        }
    },
    featureIdToHex: function(d) {
        var e = Number(d.split("_").pop()) + 1;
        if (e >= 16777216) {
            this.hitOverflow = e - 16777215;
            e = e % 16777216 + 1
        }
        var c = "000000" + e.toString(16);
        var a = c.length;
        c = "#" + c.substring(a - 6, a);
        return c
    },
    drawGeometry: function(f, d, e) {
        var c = f.CLASS_NAME;
        if ((c == "SuperMap.Geometry.Collection") || (c == "SuperMap.Geometry.MultiPoint") || (c == "SuperMap.Geometry.MultiLineString") || (c == "SuperMap.Geometry.MultiPolygon")) {
            for (var a = 0; a < f.components.length; a++) {
                this.drawGeometry(f.components[a], d, e)
            }
            return
        }
        switch (f.CLASS_NAME) {
        case "SuperMap.Geometry.Point":
            this.drawPoint(f, d, e);
            break;
        case "SuperMap.Geometry.LineString":
        case "SuperMap.REST.Route":
            this.drawLineString(f, d, e);
            break;
        case "SuperMap.Geometry.LinearRing":
            this.drawLinearRing(f, d, e);
            break;
        case "SuperMap.Geometry.Polygon":
            this.drawPolygon(f, d, e);
            break;
        default:
            break
        }
    },
    drawExternalGraphic: function(j, a, e) {
        var f = new Image();
        if (a.graphicTitle) {
            f.title = a.graphicTitle
        }
        var c = a.graphicWidth || a.graphicHeight;
        var k = a.graphicHeight || a.graphicWidth;
        c = c ? c : a.pointRadius * 2;
        k = k ? k : a.pointRadius * 2;
        var h = (a.graphicXOffset != undefined) ? a.graphicXOffset : -(0.5 * c);
        var d = (a.graphicYOffset != undefined) ? a.graphicYOffset : -(0.5 * k);
        var g = 1;
        var i = function() {
            if (!this.selectFeatures[e]) {
                return
            }
            var o = this.getLocalXY(j);
            var q = o[0];
            var p = o[1];
            if (!isNaN(q) && !isNaN(p)) {
                var l = this.canvas;
                l.save();
                l.translate(q, p);
                var n;
                if (a.rotation) {
                    n = a.rotation / 180 * Math.PI
                }
                if (n) {
                    l.rotate(n)
                }
                l.translate(h, d);
                l.globalAlpha = g;
                var m = SuperMap.Renderer.Canvas.drawImageScaleFactor || (SuperMap.Renderer.Canvas.drawImageScaleFactor = /android 2.1/.test(navigator.userAgent.toLowerCase()) ? 320 / window.screen.width : 1);
                l.drawImage(f, 0, 0, c * m, k * m);
                if (this.hitDetection) {
                    this.setHitContextStyle("fill", e);
                    this.hitContext.save();
                    this.hitContext.translate(q, p);
                    if (n) {
                        this.hitContext.rotate(n)
                    }
                    this.hitContext.translate(h, d);
                    this.hitContext.fillRect(0, 0, c, k)
                }
            }
            l.restore();
            this.hitContext.restore();
            this.setCanvasStyle(this.canvas, "reset");
            if (!a.externalGraphicSource) {
                this.externalGraphicCount--;
                if (this.externalGraphicCount == 0) {
                    this.restoreCanvas()
                }
            }
        };
        if (a.externalGraphicSource) {
            f = a.externalGraphicSource;
            i.apply(this)
        } else {
            f.onload = SuperMap.Function.bind(i, this);
            f.src = a.externalGraphic
        }
    },
    drawPoint: function(g, c, e) {
        if (c.graphic !== false) {
            if (c.externalGraphic || c.externalGraphicSource) {
                this.drawExternalGraphic(g, c, e)
            } else {
                var j = this.getLocalXY(g);
                var i = parseInt(j[0]);
                var h = parseInt(j[1]);
                if (!isNaN(i) && !isNaN(h)) {
                    var f = c.pointRadius;
                    var d = this.canvas;
                    d.beginPath();
                    d.arc(i, h, f, 0, 6.283185307179586, true);
                    if (c.stroke !== false) {
                        this.setCanvasStyle(this.canvas, "stroke", c);
                        d.stroke()
                    }
                    if (c.fill !== false) {
                        this.setCanvasStyle(this.canvas, "fill", c);
                        d.fill()
                    }
                    if (this.hitDetection) {
                        this.setHitContextStyle("fill", e, c);
                        var a = this.hitContext;
                        a.beginPath();
                        a.arc(i, h, f, 0, 6.283185307179586, true);
                        if (c.stroke !== false) {
                            a.stroke()
                        }
                        if (c.fill !== false) {
                            a.fill()
                        }
                    }
                }
            }
        }
    },
    drawLineString: function(d, a, c) {
        a = SuperMap.Util.applyDefaults({
            fill: false
        }, a);
        this.drawLinearRing(d, a, c)
    },
    drawLinearRing: function(f, a, e) {
        var d = (a.fill !== false);
        var c = (a.stroke !== false);
        this.renderPath(this.canvas, f, a, e, {
            fill: d,
            stroke: c
        });
        if (this.hitDetection) {
            this.setHitContextStyle("fill", e, a);
            this.renderPath(this.hitContext, f, undefined, e, {
                fill: d,
                stroke: c
            })
        }
    },
    renderPath: function(d, l, a, f, j) {
        var g = l.components;
        var h = g.length;
        d.beginPath();
        var c = this.getLocalXY(g[0]);
        var m = c[0];
        var k = c[1];
        if (!isNaN(m) && !isNaN(k)) {
            d.moveTo(c[0], c[1]);
            for (var e = 1; e < h; ++e) {
                var n = this.getLocalXY(g[e]);
                d.lineTo(n[0], n[1])
            }
            if (j.fill) {
                if (a) {
                    this.setCanvasStyle(d, "fill", a)
                }
                d.fill()
            }
            if (j.stroke) {
                if (a) {
                    this.setCanvasStyle(d, "stroke", a)
                }
                d.stroke()
            }
        }
    },
    drawPolygon: function(h, a, d) {
        var f = h.components;
        var g = f.length;
        if (g == 1) {
            this.drawLinearRing(f[0], a, d)
        } else {
            this.polygonContext.clearRect(0, 0, this.size.w, this.size.h);
            var j = (a.fill !== false);
            var k = (a.stroke !== false);
            this.renderPath(this.polygonContext, f[0], SuperMap.Util.applyDefaults({
                fillOpacity: 1
            }, a), d, {
                fill: j,
                stroke: k
            });
            this.polygonContext.globalCompositeOperation = "xor";
            for (var e = 1; e < g; ++e) {
                this.renderPath(this.polygonContext, f[e], SuperMap.Util.applyDefaults({
                    fillOpacity: 1
                }, a), d, {
                    fill: j,
                    stroke: k
                })
            }
            this.polygonContext.globalCompositeOperation = "source-over";
            var c = this.canvas.globalAlpha;
            this.canvas.globalAlpha = a.fillOpacity;
            this.canvas.drawImage(this.polygonCanvas, 0, 0);
            this.canvas.globalAlpha = c;
            for (var e = 1; e < g; ++e) {
                this.drawLinearRing(f[e], SuperMap.Util.applyDefaults({
                    fill: false
                }, a), d)
            }
        }
    },
    drawText: function(m, a) {
        a = SuperMap.Util.extend({
            fontColor: "#000000",
            labelAlign: "cm"
        }, a);
        var n = this.getLocalXY(m);
        this.setCanvasStyle(this.canvas, "reset");
        this.canvas.fillStyle = a.fontColor;
        this.canvas.globalAlpha = a.fontOpacity || 1;
        var e = [a.fontStyle ? a.fontStyle : "normal", "normal", a.fontWeight ? a.fontWeight : "normal", a.fontSize ? a.fontSize : "1em", a.fontFamily ? a.fontFamily : "sans-serif"].join(" ");
        var d = a.label.split("\n");
        var g = d.length;
        if (this.canvas.fillText) {
            this.canvas.font = e;
            this.canvas.textAlign = SuperMap.Renderer.Canvas.LABEL_ALIGN[a.labelAlign[0]] || "center";
            this.canvas.textBaseline = SuperMap.Renderer.Canvas.LABEL_ALIGN[a.labelAlign[1]] || "middle";
            var k = SuperMap.Renderer.Canvas.LABEL_FACTOR[a.labelAlign[1]];
            if (k == null) {
                k = -0.5
            }
            var l = this.canvas.measureText("Mg").height || this.canvas.measureText("xx").width;
            n[1] += l * k * (g - 1);
            for (var f = 0; f < g; f++) {
                this.canvas.fillText(d[f], n[0], n[1] + (l * f))
            }
        } else {
            if (this.canvas.mozDrawText) {
                this.canvas.mozTextStyle = e;
                var c = SuperMap.Renderer.Canvas.LABEL_FACTOR[a.labelAlign[0]];
                if (c == null) {
                    c = -0.5
                }
                var k = SuperMap.Renderer.Canvas.LABEL_FACTOR[a.labelAlign[1]];
                if (k == null) {
                    k = -0.5
                }
                var l = this.canvas.mozMeasureText("xx");
                n[1] += l * (1 + (k * g));
                for (var f = 0; f < g; f++) {
                    var j = n[0] + (c * this.canvas.mozMeasureText(d[f]));
                    var h = n[1] + (f * l);
                    this.canvas.translate(j, h);
                    this.canvas.mozDrawText(d[f]);
                    this.canvas.translate(-j, -h)
                }
            }
        }
        this.setCanvasStyle(this.canvas, "reset")
    },
    getLocalXY: function(c) {
        var d = this.getResolution();
        var e = this.extent;
        var a = ((c.x - this.featureDx) / d + (-e.left / d));
        var f = ((e.top / d) - c.y / d);
        return [a, f]
    },
    localToMap: function(a, g) {
        var c = this.getResolution();
        var d = this.extent;
        var f = a * c + this.featureDx + d.left;
        var e = d.top - g * c;
        return new SuperMap.Geometry.Point(f,e)
    },
    clear: function() {
        var a = this.root.height;
        var c = this.root.width;
        this.canvas.clearRect(0, 0, c, a);
        this.features = {};
        this.selectFeatures = {};
        if (this.hitDetection) {
            this.hitContext.clearRect(0, 0, c, a);
            this.hitContextBack.clearRect(0, 0, c, a)
        }
        this.backCanvasContext.clearRect(0, 0, this.size.w, this.size.h);
        if (this.hitDetection) {
            this.hitContextBack.clearRect(0, 0, this.size.w, this.size.h)
        }
    },
    clearFeatures: function(a) {
        this.features = {}
    },
    getFeatureIdFromEvent: function(h) {
        var i = null;
        var k = null;
        if (this.hitDetection) {
            if (!this.map.dragging) {
                var j = h.xy;
                var f = j.x | 0;
                var e = j.y | 0;
                var d = this.hitContext.getImageData(f, e, 1, 1).data;
                if (d[3] === 255) {
                    var c = d[2] + (256 * (d[1] + (256 * d[0])));
                    if (c) {
                        i = this.selectFeatures["SuperMap.Feature.Vector_" + (c - 1 + this.hitOverflow)];
                        if (i) {
                            k = i[0];
                            var a;
                            if (k.geometry.CLASS_NAME == "SuperMap.Geometry.Point") {
                                a = this.getPointBounds(k, i[1])
                            } else {
                                a = k.geometry.getBounds()
                            }
                            var g = this.localToMap(f, e);
                            if (!a.contains(g.x, g.y)) {
                                k = null
                            }
                        }
                    }
                }
            }
        }
        return k
    },
    eraseFeatures: function(k, o) {
        if (!(SuperMap.Util.isArray(k))) {
            k = [k]
        }
        this.canvas.globalCompositeOperation = "destination-out";
        var f = {};
        for (var r = 0, s = k.length; r < s; ++r) {
            var m = k[r].geometry.getBounds();
            var d = m && m.intersectsBounds(this.extent);
            if (d) {
                var j = this.selectFeatures[k[r].id];
                var g = j[0].geometry;
                var t = j[1];
                var e = this.getLocalXY(new SuperMap.Geometry.Point(m.left,m.top));
                var c = this.getLocalXY(new SuperMap.Geometry.Point(m.right,m.bottom));
                this.canvas.clearRect(e[0], e[1], Math.abs(c[0] - e[0]), Math.abs(c[1] - e[1]));
                for (var n in this.layer.features) {
                    q = this.layer.features[n];
                    if (!f[q.id]) {
                        if (m.intersectsBounds(q.geometry.getBounds())) {
                            this.features[q.id] = [q, this.selectFeatures[q.id][1]];
                            f[q.id] = [q, this.selectFeatures[q.id][1]]
                        }
                    }
                }
                for (var l = startRow; l <= endRow; l++) {
                    for (var h = startCol; h <= endCol; h++) {
                        var v = l * layer.featuresGridColumn + h;
                        var u = layer.featureGridList[v];
                        if (u) {
                            for (var p in u) {
                                var q = u[p]
                            }
                        }
                    }
                }
                if (!(o && o.forDisplay)) {
                    delete this.selectFeatures[j[0].id]
                }
            }
        }
        for (var p in f) {
            var a = f[p];
            this.drawGeometry(a[0].geometry, SuperMap.Util.applyDefaults({
                fillOpacity: 1,
                stroke: false
            }, a[1]), a[0].id)
        }
        this.canvas.globalCompositeOperation = "source-over";
        this.restoreCanvas();
        this.redraw()
    },
    redraw: function() {
        if (this.locked) {
            return
        }
        this.setCanvasStyle(this.canvas, "reset");
        var m = this.root.height;
        var d = this.root.width;
        this.canvas.clearRect(0, 0, d, m);
        if (this.hitDetection) {
            this.hitContext.clearRect(0, 0, d, m)
        }
        if (this.lastBounds) {
            var k = this.map.getPixelFromLonLat(this.backCanvasPosition);
            this.canvas.drawImage(this.backCanvas, k.x, k.y, this.size.w, this.size.h);
            if (this.hitDetection) {
                this.hitContext.drawImage(this.hitCanvasBack, k.x, k.y, this.size.w, this.size.h)
            }
        }
        this.labelMap = [];
        var n, j, a, g;
        var l = (this.map.baseLayer && this.map.baseLayer.wrapDateLine) && this.map.getMaxExtent();
        this.externalGraphicCount = 0;
        var e = this.features;
        for (var c in e) {
            g = e[c];
            n = g[0];
            a = g[1];
            j = n.geometry;
            this.calculateFeatureDx(j.getBounds(), l);
            if (g[2] && !a.externalGraphic) {
                this.canvas.globalCompositeOperation = "destination-out";
                this.drawGeometry(j, SuperMap.Util.applyDefaults({
                    fillOpacity: 1,
                    strokeWidth: a.strokeWidth + 2
                }, a), n.id);
                this.canvas.globalCompositeOperation = "source-over"
            }
            if (a.externalGraphic && !a.externalGraphicSource && j.CLASS_NAME == "SuperMap.Geometry.Point") {
                this.externalGraphicCount++
            }
            this.drawGeometry(j, a, n.id);
            if (a.label) {
                this.labelMap.push([n, a])
            }
            if (a.stroke == true) {
                var h = j.CLASS_NAME;
                if ((h == "SuperMap.Geometry.Collection") || (h == "SuperMap.Geometry.MultiPolygon")) {
                    for (var f = 0; f < j.components.length; f++) {
                        this.drawLinearRing(j.components[f], SuperMap.Util.applyDefaults({
                            fill: false
                        }, a), n.id)
                    }
                }
                switch (j.CLASS_NAME) {
                case "SuperMap.Geometry.Polygon":
                    this.drawLinearRing(j.components[0], SuperMap.Util.applyDefaults({
                        fill: false
                    }, a), n.id);
                    break;
                default:
                    break
                }
            }
            delete e[c]
        }
        this.addLabel(this.labelMap);
        this.restoreCanvas();
        this.canvas.globalCompositeOperation = "source-over"
    },
    addLabel: function(e) {
        var d;
        for (var c = 0, a = e.length; c < a; ++c) {
            d = e[c];
            this.drawText(d[0].geometry.getCentroid(), d[1])
        }
    },
    destroy: function() {
        this.transitionObj.destroy();
        this.transitionObj = null;
        SuperMap.Renderer.prototype.destroy.apply(this, arguments)
    },
    CLASS_NAME: "SuperMap.Renderer.Canvas2"
});
SuperMap.Renderer.Canvas.LABEL_ALIGN = {
    l: "left",
    r: "right",
    t: "top",
    b: "bottom"
};
SuperMap.Renderer.Canvas.LABEL_FACTOR = {
    l: 0,
    r: -1,
    t: 0,
    b: -1
};
SuperMap.Renderer.Canvas.drawImageScaleFactor = null;
SuperMap.Layer.Vector = SuperMap.Class(SuperMap.Layer, {
    EVENT_TYPES: ["beforefeatureadded", "beforefeaturesadded", "featureadded", "featuresadded", "beforefeatureremoved", "beforefeaturesremoved", "featureremoved", "featuresremoved", "beforefeatureselected", "featureselected", "featureunselected", "beforefeaturemodified", "featuremodified", "afterfeaturemodified", "vertexmodified", "vertexremoved", "sketchstarted", "sketchmodified", "sketchcomplete", "refresh"],
    isBaseLayer: false,
    isFixed: false,
    features: null,
    filter: null,
    selectedFeatures: null,
    unrenderedFeatures: null,
    reportError: true,
    style: null,
    styleMap: null,
    strategies: null,
    protocol: null,
    renderers: ["SVG", "VML", "Canvas", "Canvas2"],
    renderer: null,
    rendererOptions: null,
    geometryType: null,
    drawn: false,
    ratio: 1,
    transition: true,
    firstLoad: true,
    featureGridList: [],
    featuresGridRow: 10,
    featuresGridColumn: 20,
    unitsWidth: null,
    unitsHeight: null,
    featuresGrid: [],
    zoomChanged: null,
    useCanvas2: false,
    lastResolution: 0,
    lastCanvasPosition: 0,
    initialize: function(d, c) {
        this.EVENT_TYPES = SuperMap.Layer.Vector.prototype.EVENT_TYPES.concat(SuperMap.Layer.prototype.EVENT_TYPES);
        SuperMap.Layer.prototype.initialize.apply(this, arguments);
        if (!this.renderer || !this.renderer.supported()) {
            this.assignRenderer()
        }
        if (!this.renderer || !this.renderer.supported()) {
            this.renderer = null;
            this.displayError()
        }
        if (!this.styleMap) {
            this.styleMap = new SuperMap.StyleMap()
        }
        this.features = [];
        this.selectedFeatures = [];
        this.unrenderedFeatures = {};
        if (this.strategies) {
            for (var e = 0, a = this.strategies.length; e < a; e++) {
                this.strategies[e].setLayer(this)
            }
        }
        this.tempIndex = [];
        this.useCanvas2 = this.renderer instanceof SuperMap.Renderer.Canvas2
    },
    destroy: function() {
        if (this.strategies) {
            var d, c, a;
            for (c = 0,
            a = this.strategies.length; c < a; c++) {
                d = this.strategies[c];
                if (d.autoDestroy) {
                    d.destroy()
                }
            }
            this.strategies = null
        }
        if (this.protocol) {
            if (this.protocol.autoDestroy) {
                this.protocol.destroy()
            }
            this.protocol = null
        }
        this.destroyFeatures();
        this.features = null;
        this.selectedFeatures = null;
        this.unrenderedFeatures = null;
        if (this.renderer) {
            this.renderer.destroy()
        }
        this.renderer = null;
        this.geometryType = null;
        this.drawn = null;
        SuperMap.Layer.prototype.destroy.apply(this, arguments)
    },
    clone: function(f) {
        if (f == null) {
            f = new SuperMap.Layer.Vector(this.name,this.getOptions())
        }
        f = SuperMap.Layer.prototype.clone.apply(this, [f]);
        var d = this.features;
        var a = d.length;
        var e = new Array(a);
        for (var c = 0; c < a; ++c) {
            e[c] = d[c].clone()
        }
        f.features = e;
        return f
    },
    refresh: function(a) {
        if (this.calculateInRange() && this.visibility) {
            this.events.triggerEvent("refresh", a)
        }
    },
    assignRenderer: function() {
        for (var d = 0, a = this.renderers.length; d < a; d++) {
            var c = this.renderers[d];
            var e = (typeof c == "function") ? c : SuperMap.Renderer[c];
            if (e && e.prototype.supported()) {
                this.renderer = new e(this.div,this.rendererOptions,this);
                break
            }
        }
    },
    displayError: function() {},
    setMap: function(c) {
        SuperMap.Layer.prototype.setMap.apply(this, arguments);
        if (!this.renderer) {
            this.map.removeLayer(this)
        } else {
            this.renderer.map = this.map;
            var a = this.map.getSize();
            a.w = a.w * this.ratio;
            a.h = a.h * this.ratio;
            this.renderer.setSize(a)
        }
    },
    afterAdd: function() {
        if (this.strategies) {
            var d, c, a;
            for (c = 0,
            a = this.strategies.length; c < a; c++) {
                d = this.strategies[c];
                if (d.autoActivate) {
                    d.activate()
                }
            }
        }
    },
    removeMap: function(d) {
        this.drawn = false;
        if (this.strategies) {
            var e, c, a;
            for (c = 0,
            a = this.strategies.length; c < a; c++) {
                e = this.strategies[c];
                if (e.autoActivate) {
                    e.deactivate()
                }
            }
        }
    },
    onMapResize: function() {
        SuperMap.Layer.prototype.onMapResize.apply(this, arguments);
        var a = this.map.getSize();
        a.w = a.w * this.ratio;
        a.h = a.h * this.ratio;
        this.renderer.setSize(a)
    },
    moveTo: function(a, c, p) {
        SuperMap.Layer.prototype.moveTo.apply(this, arguments);
        var k = this.useCanvas2;
        this.zoomChanged = c;
        var h = (SuperMap.Renderer.NG && this.renderer instanceof SuperMap.Renderer.NG);
        if (h) {
            p || this.renderer.updateDimensions(c)
        } else {
            var d = true;
            if (!p) {
                this.renderer.root.style.visibility = "hidden";
                if (k) {
                    this.renderer.restoreCanvas()
                }
                var o = this.map.getSize()
                  , m = o.w
                  , g = o.h
                  , f = (m / 2 * this.ratio) - m / 2
                  , e = (g / 2 * this.ratio) - g / 2;
                f += parseInt(this.map.layerContainerDiv.style.left, 10);
                f = -Math.round(f);
                e += parseInt(this.map.layerContainerDiv.style.top, 10);
                e = -Math.round(e);
                this.div.style.left = f + "px";
                this.div.style.top = e + "px";
                var r = this.map.getExtent().scale(this.ratio);
                d = this.renderer.setExtent(r, c);
                this.renderer.root.style.visibility = "visible";
                if (SuperMap.IS_GECKO === true) {
                    this.div.scrollLeft = this.div.scrollLeft
                }
                if (!c && d) {
                    for (var l in this.unrenderedFeatures) {
                        var s = this.unrenderedFeatures[l];
                        this.drawFeature(s)
                    }
                }
            }
        }
        if (!this.drawn || (!h && (c || !d))) {
            this.drawn = true;
            if (this.transition && k) {
                if (!c || !this.lastCanvasPosition) {
                    this.drawFeatures(a)
                } else {
                    var j = this.map.getLayerPxFromLonLat(this.lastCanvasPosition)
                      , q = SuperMap.Function.bind(function() {
                        this.drawFeatures(a)
                    }, this);
                    this.renderer.transitionObj.begin(this.renderer.root, j, q)
                }
            }
            if (!k || !this.transition) {
                this.drawFeatures(a)
            }
            this.firstLoad = false
        }
        if (k) {
            this.lastResolution = this.map.getResolution();
            var n = new SuperMap.Pixel(parseInt(this.renderer.container.style.left),parseInt(this.renderer.container.style.top));
            this.lastCanvasPosition = this.map.getLonLatFromLayerPx(n)
        }
    },
    drawFeatures: function(g) {
        var f = this, e, d = f.features;
        f.renderer.locked = true;
        for (var c = 0, a = d.length; c < a; c++) {
            if (c == (a - 1)) {
                f.renderer.locked = false
            }
            e = d[c];
            f.drawFeature(e, undefined, {
                isNewAdd: f.firstLoad || f.zoomChanged
            })
        }
    },
    redraw: function() {
        if (SuperMap.Renderer.NG && this.renderer instanceof SuperMap.Renderer.NG) {
            this.drawn = false
        }
        return SuperMap.Layer.prototype.redraw.apply(this, arguments)
    },
    display: function(a) {
        SuperMap.Layer.prototype.display.apply(this, arguments);
        var c = this.div.style.display;
        if (c != this.renderer.root.style.display) {
            this.renderer.root.style.display = c
        }
    },
    addFeatures: function(c, m) {
        if (!(SuperMap.Util.isArray(c))) {
            c = [c]
        }
        var k = !m || !m.silent;
        if (k) {
            var a = {
                features: c
            };
            var j = this.events.triggerEvent("beforefeaturesadded", a);
            if (j === false) {
                return
            }
            c = a.features
        }
        var g = [];
        this.renderer.locked = true;
        for (var e = 0, h = c.length; e < h; e++) {
            if (e == (h - 1)) {
                this.renderer.locked = false
            }
            var l = c[e];
            if (this.geometryType && !(l.geometry instanceof this.geometryType)) {
                throw new TypeError("addFeatures: component should be an " + this.geometryType.prototype.CLASS_NAME)
            }
            l.layer = this;
            if (!l.style && this.style) {
                l.style = SuperMap.Util.extend({}, this.style)
            }
            this.features.push(l);
            var f = this.drawFeature(l, undefined, {
                isNewAdd: true
            });
            if (!f) {
                g.push(l)
            }
        }
        var d = g.length == 0 ? true : false;
        this.events.triggerEvent("featuresadded", {
            features: g,
            succeed: d
        })
    },
    destroyFeatures: function(e, a) {
        var d = (e == undefined);
        if (d) {
            e = this.features
        }
        if (e) {
            this.removeFeatures(e, a);
            for (var c = e.length - 1; c >= 0; c--) {
                e[c].destroy()
            }
        }
    },
    removeFeatures: function(c) {
        if (!c || c.length === 0) {
            return
        }
        if (c === this.features) {
            return this.removeAllFeatures()
        }
        if (!(SuperMap.Util.isArray(c))) {
            c = [c]
        }
        if (c === this.selectedFeatures) {
            c = c.slice()
        }
        var d = [];
        for (var g = c.length - 1; g >= 0; g--) {
            var k = c[g];
            delete this.unrenderedFeatures[k.id];
            var j = SuperMap.Util.indexOf(this.features, k);
            if (j === -1) {
                d.push(k);
                continue
            }
            this.features.splice(j, 1);
            if (SuperMap.Util.indexOf(this.selectedFeatures, k) != -1) {
                SuperMap.Util.removeItem(this.selectedFeatures, k)
            }
        }
        this.renderer.clear();
        var a = [];
        for (var e = 0, h = this.features.length; e < h; e++) {
            k = this.features[e];
            a.push(k)
        }
        this.features = [];
        this.addFeatures(a);
        var f = d.length == 0 ? true : false;
        this.events.triggerEvent("featuresremoved", {
            features: d,
            succeed: f
        })
    },
    removeAllFeatures: function() {
        this.renderer.clear();
        this.featureGridList = [];
        this.features = [];
        this.unrenderedFeatures = {};
        this.selectedFeatures = [];
        this.events.triggerEvent("featuresremoved", {
            features: [],
            succeed: true
        })
    },
    drawFeature: function(a, d, c) {
        if (!this.drawn) {
            return
        }
        if (typeof d != "object") {
            if (!d && a.state === SuperMap.State.DELETE) {
                d = "delete"
            }
            var e = d || a.renderIntent;
            d = a.style || this.style;
            if (!d) {
                d = this.styleMap.createSymbolizer(a, e)
            }
        }
        var f = this.renderer.drawFeature(a, d, c);
        if (f === false || f === null) {
            this.unrenderedFeatures[a.id] = a
        } else {
            delete this.unrenderedFeatures[a.id]
        }
        return f
    },
    eraseFeatures: function(a) {
        this.renderer.eraseFeatures(a)
    },
    getFeatureFromEvent: function(a) {
        if (!this.renderer) {
            throw new Error("getFeatureFromEvent called on layer with no renderer. This usually means you destroyed a layer, but not some handler which is associated with it.")
        }
        var c = null;
        var d = this.renderer.getFeatureIdFromEvent(a);
        if (d) {
            if (typeof d === "string") {
                c = this.getFeatureById(d)
            } else {
                c = d
            }
        }
        return c
    },
    getFeatureBy: function(d, c) {
        var a = null;
        for (var e in this.features) {
            if (this.features[e][d] == c) {
                a = this.features[e];
                break
            }
        }
        return a
    },
    getFeatureById: function(a) {
        return this.getFeatureBy("id", a)
    },
    getFeatureByFid: function(a) {
        return this.getFeatureBy("fid", a)
    },
    getFeaturesByAttribute: function(d, e) {
        var c, a, g = [];
        for (var f in this.features) {
            a = this.features[f];
            if (a && a.attributes) {
                if (a.attributes[d] === e) {
                    g.push(a)
                }
            }
        }
        return g
    },
    onFeatureInsert: function(a) {},
    preFeatureInsert: function(a) {},
    getDataExtent: function() {
        var a = null;
        var c = this.features;
        if (c) {
            var d = null;
            for (var e in this.features) {
                d = c[e].geometry;
                if (d) {
                    if (a === null) {
                        a = new SuperMap.Bounds()
                    }
                    a.extend(d.getBounds())
                }
            }
        }
        return a
    },
    CLASS_NAME: "SuperMap.Layer.Vector"
});
SuperMap.Layer.Vector.RootContainer = SuperMap.Class(SuperMap.Layer.Vector, {
    displayInLayerSwitcher: false,
    layers: null,
    initialize: function(c, a) {
        SuperMap.Layer.Vector.prototype.initialize.apply(this, arguments)
    },
    display: function() {},
    getFeatureFromEvent: function(a) {
        var e = this.layers;
        var d;
        for (var c = 0; c < e.length; c++) {
            d = e[c].getFeatureFromEvent(a);
            if (d) {
                return d
            }
        }
    },
    setMap: function(a) {
        SuperMap.Layer.Vector.prototype.setMap.apply(this, arguments);
        this.collectRoots();
        a.events.register("changelayer", this, this.handleChangeLayer)
    },
    removeMap: function(a) {
        a.events.unregister("changelayer", this, this.handleChangeLayer);
        this.resetRoots();
        SuperMap.Layer.Vector.prototype.removeMap.apply(this, arguments)
    },
    collectRoots: function() {
        var c;
        for (var a = 0; a < this.map.layers.length; ++a) {
            c = this.map.layers[a];
            if (SuperMap.Util.indexOf(this.layers, c) != -1) {
                c.renderer.moveRoot(this.renderer)
            }
        }
    },
    resetRoots: function() {
        var c;
        for (var a = 0; a < this.layers.length; ++a) {
            c = this.layers[a];
            if (this.renderer && c.renderer.getRenderLayerId() == this.id) {
                this.renderer.moveRoot(c.renderer)
            }
        }
    },
    handleChangeLayer: function(a) {
        var c = a.layer;
        if (a.property == "order" && SuperMap.Util.indexOf(this.layers, c) != -1) {
            this.resetRoots();
            this.collectRoots()
        }
    },
    CLASS_NAME: "SuperMap.Layer.Vector.RootContainer"
});
SuperMap.Layer.ClusterLayer = SuperMap.Class(SuperMap.Layer.Vector, {
    maxLevel: null,
    isDiffused: true,
    tolerance: 60,
    maxDiffuseAmount: 50,
    clusterStyles: [{
        count: 15,
        style: {
            fontColor: "#404040",
            graphic: true,
            externalGraphic: SuperMap.Util.getImagesLocation() + "cluster3.png",
            graphicWidth: 37,
            graphicHeight: 38,
            labelXOffset: -4,
            labelYOffset: 5
        }
    }, {
        count: 50,
        style: {
            fontColor: "#404040",
            graphic: true,
            externalGraphic: SuperMap.Util.getImagesLocation() + "cluster2.png",
            graphicWidth: 41,
            graphicHeight: 46,
            labelXOffset: -3,
            labelYOffset: 6
        }
    }, {
        count: "moreThanMax",
        style: {
            fontColor: "#404040",
            graphic: true,
            externalGraphic: SuperMap.Util.getImagesLocation() + "cluster1.png",
            graphicWidth: 48,
            graphicHeight: 53,
            labelXOffset: -5,
            labelYOffset: 8
        }
    }],
    noDrawClusters: false,
    isFeatureChanged: true,
    clusterPoints: [],
    toDrawFeatures: null,
    openedPoints: [],
    lastOpenedPoints: [],
    pointMap: null,
    origin: null,
    curOpenCluster: null,
    drawAllTimeout: [],
    drawDiffusePointTimeout: [],
    displayedBounds: null,
    dataExtent: null,
    initialize: function(c, a) {
        SuperMap.Layer.Vector.prototype.initialize.apply(this, arguments);
        this.EVENT_TYPES = ["mouseoverCluster", "mouseoutCluster", "clickCluster", "mouseoverFeature", "mouseoutFeature", "clickFeature", "clickout"];
        this.EVENT_TYPES = this.EVENT_TYPES.concat(SuperMap.Layer.Vector.prototype.EVENT_TYPES.concat(SuperMap.Layer.prototype.EVENT_TYPES));
        this.events = new SuperMap.Events(this,this.div,this.EVENT_TYPES);
        if (this.eventListeners instanceof Object) {
            this.events.on(this.eventListeners)
        }
        this.clusterStyles = this.clusterStyles.sort(function(e, d) {
            if (e.count == "moreThanMax") {
                return true
            } else {
                if (d.count == "moreThanMax") {
                    return false
                } else {
                    return e.count - d.count
                }
            }
        })
    },
    addFeatures: function(t, e) {
        if (!t || (t instanceof Array && t.length == 0)) {
            return
        }
        if (e == "isRefresh") {
            this.clusterPoints = t
        } else {
            t = this.clusterPoints = (this.clusterPoints || []).concat(t);
            this.isFeatureChanged = true
        }
        var a = this.getTileSizeLonlat();
        var B = this.getOrigin();
        var A = this.map.getExtent();
        var q = this.getIdxOfBounds(A, a, B);
        var k = q.minRowIdx;
        var j = q.minColIdx;
        var d = q.maxRowIdx;
        var r = q.maxColIdx;
        var c = [];
        var C = [];
        for (var u = 0; u < t.length; u++) {
            var h = this.getPointTileIdx(t[u], a, B);
            var m = h[1];
            var l = h[0];
            if (j <= l && r >= l) {
                if (k <= m && d >= m) {
                    var z = this.displayedBounds;
                    var w = h[2];
                    var v = w.geometry;
                    v = new SuperMap.LonLat(v.x,v.y);
                    if (z && z.containsLonLat(v)) {
                        C.push(w)
                    } else {
                        c.push(h)
                    }
                }
            }
        }
        var o = [];
        for (var u = 0; u < c.length; u++) {
            var s = c[u];
            var l = s[0];
            var m = s[1];
            if (!o[l]) {
                o[l] = []
            }
            var n = o[l];
            if (n[m]) {
                n[m].push(s[2])
            } else {
                n[m] = [s[2]]
            }
        }
        if (C.length > 0) {
            o.displayedPoints = C
        }
        this.drawPointMap(o, k, j, d, r);
        this.pointMap = o
    },
    refresh: function() {
        this.renderer.locked = true;
        this.clearCluster();
        this.renderer.locked = false;
        this.addFeatures(this.clusterPoints, "isRefresh")
    },
    displayFeatures: function(a) {
        this.displayedBounds = a || this.map.getExtent();
        this.refresh()
    },
    cancelDisplayFeatures: function() {
        this.displayedBounds = null;
        this.refresh()
    },
    getFeaturesByBounds: function(a) {
        if (!this.pointMap || (this.pointMap.length && this.pointMap.length == 0)) {
            return []
        }
        var c = this.pointMap;
        var d = this.getTileSizeLonlat();
        var i = this.getOrigin();
        var h = this.map.getExtent();
        var j = this.getIdxOfBounds(h, d, i);
        var e = [];
        for (var f = j.minColIdx; f <= j.maxColIdx; f++) {
            if (c[f]) {
                for (var g = j.minRowIdx; g <= j.maxRowIdx; g++) {
                    if (c[f][g]) {
                        e = e.concat(c[f][g])
                    }
                }
            }
        }
        return e
    },
    clearCluster: function(a) {
        this.removeAllFeatures("isFather");
        this.toDrawFeatures = null;
        if (a != 123) {
            this.openedPoints = [];
            this.curOpenCluster = null
        }
    },
    destroyCluster: function() {
        this.clearCluster();
        this.clusterPoints = null;
        this.pointMap = null;
        this.isFeatureChanged = true
    },
    removeAllFeatures: function(a) {
        if (a == "isFather") {
            SuperMap.Layer.Vector.prototype.removeAllFeatures.apply(this)
        } else {
            this.destroyCluster()
        }
    },
    assembleFeature: function(a) {
        var c = a;
        c.style.strokeWidth = 1;
        return c
    },
    removeFeatures: function(c) {
        if (!c || c.length === 0) {
            return
        }
        if (c === this.features) {
            return this.removeAllFeatures("isFather")
        }
        if (!(SuperMap.Util.isArray(c))) {
            c = [c]
        }
        if (c === this.selectedFeatures) {
            c = c.slice()
        }
        var d = [];
        for (var g = c.length - 1; g >= 0; g--) {
            var k = c[g];
            delete this.unrenderedFeatures[k.id];
            var j = SuperMap.Util.indexOf(this.features, k);
            if (j === -1) {
                d.push(k);
                continue
            }
            this.features.splice(j, 1);
            if (SuperMap.Util.indexOf(this.selectedFeatures, k) != -1) {
                SuperMap.Util.removeItem(this.selectedFeatures, k)
            }
        }
        this.renderer.clear();
        var a = [];
        for (var e = 0, h = this.features.length; e < h; e++) {
            k = this.features[e];
            a.push(k)
        }
        this.features = [];
        this._addFeatures(a);
        var f = d.length == 0 ? true : false;
        this.events.triggerEvent("featuresremoved", {
            features: d,
            succeed: f
        })
    },
    setMap: function(a) {
        SuperMap.Layer.Vector.prototype.setMap.apply(this, arguments);
        if (this.isVML()) {
            this.map.events.register("movestart", this, function() {
                this.clearTimeout(this.drawAllTimeout);
                this.clearTimeout(this.drawDiffusePointTimeout);
                this.removeAllFeatures("isFather")
            })
        }
    },
    isVML: function() {
        return ( this.renderer.CLASS_NAME == "SuperMap.Renderer.VML")
    },
    moveTo: function(c, a) {
        this.renderer.locked = true;
        this.clearCluster(a ? null : 123);
        SuperMap.Layer.Vector.prototype.moveTo.apply(this, arguments);
        this.renderer.locked = this.curOpenCluster ? true : false;
        this.addFeatures(this.clusterPoints, "isRefresh");
        if (this.curOpenCluster) {
            if (this.isVML()) {
                window.setTimeout(function(d) {
                    return function() {
                        d.addFeatures20(d.openedPoints, d.curOpenCluster.geometry, null, "drawDiffusePointTimeout")
                    }
                }(this), 100)
            } else {
                this.renderer.locked = false;
                this._addFeatures(this.openedPoints)
            }
        }
    },
    clickCluster: function(l) {
        if (this.isDiffused) {
            try {
                var k = this.isVML();
                if (k) {
                    var n = this.drawDiffusePointTimeout;
                    if (n.length > 0) {
                        this.clearTimeout(n);
                        this.clearOpenedPoints(this.lastOpenedPoints)
                    }
                }
                var a, c, d;
                this.renderer.locked = true;
                if (this.curOpenCluster) {
                    this.showOpenedCluster();
                    this.renderer.locked = true;
                    this.curOpenCluster = null
                }
                if (!k) {
                    this.clearOpenedPoints(this.openedPoints)
                } else {
                    d = this.openedPoints.concat([]);
                    this.lastOpenedPoints = d
                }
                this.openedPoints = [];
                a = l.children;
                if (this.maxDiffuseAmount >= a.length) {
                    for (var h = 0; h < a.length; h++) {
                        c = this._makeFeature(a[h], 0, "#0F9FF2", 2);
                        for (var g = 0; g < c.length; g++) {
                            c[g].isPoint = true;
                            this.openedPoints.push(c[g])
                        }
                    }
                    this.curOpenCluster = l;
                    l.style.display = "none";
                    this.renderer.locked = false;
                    if (k) {
                        this.addFeatures20(this.openedPoints, null, function(e, f) {
                            return function() {
                                f.clearOpenedPoints(e)
                            }
                        }(d, this), "drawDiffusePointTimeout")
                    } else {
                        this._addFeatures(this.openedPoints)
                    }
                } else {
                    if (k) {
                        this.clearOpenedPoints(d)
                    }
                }
                this.renderer.locked = false
            } catch (m) {}
        }
    },
    clickoutCluster: function() {
        try {
            var c = this.isVML();
            if (c) {
                var a = this.drawDiffusePointTimeout;
                if (a.length > 0) {
                    this.clearTimeout(a);
                    this.clearOpenedPoints(this.lastOpenedPoints)
                }
            }
            this.showOpenedCluster();
            this.clearOpenedPoints(this.openedPoints);
            this.openedPoints = [];
            this.curOpenCluster = null
        } catch (d) {}
    },
    showOpenedCluster: function() {
        if (this.curOpenCluster) {
            if (this.curOpenCluster.style.display == "none") {
                this.curOpenCluster.style.display = ""
            } else {
                this.renderer.locked = true;
                this._addFeatures([this.curOpenCluster]);
                this.renderer.locked = false
            }
        }
    },
    getIdxOfBounds: function(c, i, k) {
        var l = {
            x: c.left,
            y: c.top
        };
        var e = {
            x: c.right,
            y: c.bottom
        };
        var j = this.getPointTileIdx(l, i, k);
        var g = j[1];
        var h = j[0];
        j = this.getPointTileIdx(e, i, k);
        var d = j[1];
        var f = j[0];
        return {
            minRowIdx: g,
            minColIdx: h,
            maxRowIdx: d,
            maxColIdx: f
        }
    },
    getTileSizeLonlat: function() {
        var e = this.map.getZoom();
        var d = this.map.getResolutionForZoom(e);
        var c = {
            w: this.tolerance * 2,
            h: this.tolerance * 2
        };
        var a = {
            w: c.w * d,
            h: c.h * d
        };
        return a
    },
    getOrigin: function() {
        if (!this.origin) {
            var a = this.map.getMaxExtent();
            this.origin = {
                x: a.left,
                y: a.top
            }
        }
        return this.origin
    },
    isMaxLeve: function() {
        var d = false;
        try {
            var a = this.map.getZoom();
            var c = this.map.baseLayer.resolutions.length;
            if (this.maxLevel != null) {
                c = this.maxLevel + 1
            }
            if (a && c) {
                if (a >= c - 1) {
                    d = true
                }
            }
        } catch (f) {}
        return d
    },
    drawPointMap: function(q, h, k, c, g) {
        if (this.noDrawClusters) {
            return
        }
        var p = this.isMaxLeve();
        var o = [];
        for (var l = k; l <= g; l++) {
            if (q[l]) {
                for (var e = h; e <= c; e++) {
                    if (q[l][e]) {
                        var r = q[l][e];
                        if (r.length >= 2 && !p) {
                            var n = this.makeCluster(r);
                            if (this.curOpenCluster) {
                                var a = this.curOpenCluster.geometry;
                                var s = n.geometry;
                                if (a.x == s.x && a.y == s.y) {
                                    this.curOpenCluster = n;
                                    n = null
                                }
                            }
                            if (n) {
                                o = o.concat(n)
                            }
                        } else {
                            o = d(r, o, this)
                        }
                    }
                }
            }
        }
        var m = q.displayedPoints;
        if (m && m.length > 0) {
            o = d(m, o, this)
        }
        if (this.toDrawFeatures) {
            this.removeFeatures(this.toDrawFeatures)
        }
        this.toDrawFeatures = o;
        if (this.isVML()) {
            this.addFeatures20(o, null, null, "drawAllTimeout")
        } else {
            this._addFeatures(o)
        }
        function d(u, t, v) {
            for (var i = 0; i < u.length; i++) {
                var w = v._makeFeature(u[i], 0, "#0F9FF2", 4);
                for (var j = 0; j < w.length; j++) {
                    w[j].isPoint = true;
                    t.push(w[j])
                }
            }
            return t
        }
    },
    _addFeatures: function(c, m) {
        if (!(SuperMap.Util.isArray(c))) {
            c = [c]
        }
        var k = !m || !m.silent;
        if (k) {
            var a = {
                features: c
            };
            var j = this.events.triggerEvent("beforefeaturesadded", a);
            if (j === false) {
                return
            }
            c = a.features
        }
        var g = [];
        this.renderer.locked = true;
        for (var e = 0, h = c.length; e < h; e++) {
            if (e == (h - 1)) {
                this.renderer.locked = false
            }
            var l = c[e];
            if (this.geometryType && !(l.geometry instanceof this.geometryType)) {
                throw new TypeError("addFeatures: component should be an " + this.geometryType.prototype.CLASS_NAME)
            }
            l.layer = this;
            if (!l.style && this.style) {
                l.style = SuperMap.Util.extend({}, this.style)
            }
            this.features.push(l);
            this.modifyVMLLabel(l);
            var f = this.drawFeature(l, undefined, {
                isNewAdd: true
            });
            this.drawTextVML(l, f);
            if (!f) {
                g.push(l)
            }
        }
        var d = g.length == 0 ? true : false;
        this.events.triggerEvent("featuresadded", {
            features: g,
            succeed: d
        })
    },
    addFeatures20: function(d, a, j, f) {
        var e = d.concat([]);
        if (a) {
            a = {
                lon: a.x,
                lat: a.y
            }
        }
        var i = a || this.map.getCenter();
        e.sort(function(k) {
            return function(l, c) {
                return Math.abs(l.geometry.getBounds().left - k.lon) - Math.abs(c.geometry.getBounds().left - k.lon)
            }
        }(i));
        e.sort(function(k, c) {
            var m = k.style;
            var l = c.style;
            m.zIndex_c = m.zIndex_c || 0;
            l.zIndex_c = l.zIndex_c || 0;
            return m.zIndex_c - l.zIndex_c
        });
        h(e, this, j, f);
        function h(c, m, p, o) {
            if (c.length > 0) {
                var k = [];
                for (var l = 0; l < 10; l++) {
                    var n = c.shift();
                    if (n) {
                        k.push(n)
                    } else {
                        break
                    }
                }
                m._addFeatures(k);
                g(c, h, m, p, o)
            } else {
                if (p) {
                    p()
                }
                m[o] = []
            }
        }
        function g(c, k, l, o, n) {
            var m = window.setTimeout(function(p, q, r, t, s) {
                return function() {
                    q(p, r, t, s)
                }
            }(c, k, l, o, n), 14);
            l[n].push(m)
        }
    },
    clearTimeout: function(c) {
        for (var a = 0; a < c.length; a++) {
            window.clearTimeout(c[a])
        }
        c = []
    },
    drawTextVML: function(j, f) {
        var h = j.style;
        if (h) {
            var d = h.clusterLabel;
            if (d && f) {
                var g = h.pointRadius ? h.pointRadius * 2 : (h.graphicWidth ? h.graphicWidth : h.backgroundWidth);
                var c = h.pointRadius ? h.pointRadius * 2 : (h.graphicHeight ? h.graphicHeight : h.backgroundHeight);
                var a = document.createElement("span");
                var i = a.style;
                i.textAlign = "center";
                i.lineHeight = g + "px";
                i.width = c + "px";
                i.display = "inline-block";
                i.color = h.fontColor || "#000";
                if (h.labelXOffset || h.labelYOffset) {
                    i.position = "relative";
                    if (h.labelXOffset) {
                        i.left = h.labelXOffset + "px"
                    }
                    if (h.labelYOffset) {
                        i.top = (-1 * h.labelYOffset) + "px"
                    }
                }
                a._featureId = j.id;
                a._geometryClass = j.geometry.CLASS_NAME;
                var e = document.createTextNode(d);
                a.appendChild(e);
                f.appendChild(a)
            }
        }
    },
    modifyVMLLabel: function(c) {
        if (this.isVML()) {
            var d = c.style;
            if (d) {
                var a = d.label;
                if (a) {
                    d.label = null;
                    d.labelSelect = null;
                    d.clusterLabel = a
                }
            }
        }
    },
    makeCluster: function(h) {
        var c = this.getTileCenter(h);
        var k, j = this;
        for (var g = 0; g < this.clusterStyles.length; g++) {
            var e = this.clusterStyles[g];
            if (e.count == "moreThanMax") {
                k = d(c, e.style, h.length, h, this)
            } else {
                if (e.count >= h.length) {
                    k = d(c, e.style, h.length, h, this);
                    break
                }
            }
        }
        return k;
        function d(a, l, n, i, m) {
            var o = new SuperMap.Feature.Vector();
            o.geometry = new SuperMap.Geometry.Point(a.x,a.y);
            o.style = SuperMap.Util.JSONClone(null, l);
            if (n) {
                o.style.label = n + "";
                o.style.labelSelect = true;
                var p = SuperMap.Util.getBrowser();
                if (p.name == "msie" && p.version == "9.0") {
                    if (o.style.labelYOffset == undefined) {
                        o.style.labelYOffset = -5
                    } else {
                        o.style.labelYOffset += -5
                    }
                }
            }
            if (i) {
                o.children = i;
                o.isCluster = true
            }
            if (m.isVML() && (l.externalGraphic || l.backgroundGraphic)) {
                o.style.fillColor = "none"
            }
            return o
        }
    },
    _makeFeature: function(m, j, d, k, a) {
        if (m.geometry) {
            var e = this.assembleFeature(m);
            if (e.length) {
                var h = [];
                for (var g = 0; g < e.length; g++) {
                    var c = e[g].clone();
                    c.isPoint = true;
                    c.info = e[g].info;
                    c.attributes = e[g].attributes;
                    h.push(c)
                }
            } else {
                var c = e.clone();
                c.isPoint = true;
                c.info = e.info;
                c.attributes = e.attributes;
                var h = [c]
            }
        } else {
            var h = new SuperMap.Feature.Vector();
            h.geometry = new SuperMap.Geometry.Point(m.x,m.y);
            h.style = {
                strokeColor: "#fff",
                strokeOpacity: 0.8,
                strokeDashstyle: "solid",
                fillColor: d || "#00f",
                fillOpacity: 0.7,
                fontColor: "#fff"
            };
            h.style.strokeWidth = 1;
            if (j) {
                h.style.label = j + "";
                var l = SuperMap.Util.getBrowser();
                if (l.name == "msie" && l.version == "9.0") {
                    if (h.style.labelYOffset == undefined) {
                        h.style.labelYOffset = -5
                    } else {
                        h.style.labelYOffset += -5
                    }
                }
            }
            if (a) {
                h.children = a;
                h.isCluster = true
            }
            h = [h]
        }
        return h
    },
    clearOpenedPoints: function(a) {
        if (a && a.length > 0) {
            this.removeFeatures(a)
        }
    },
    getPointTileIdx: function(f, e, d) {
        var c = f.geometry || f;
        var a = Math.floor((c.x - d.x) / e.w);
        var g = Math.floor((d.y - c.y) / e.h);
        return [g, a, f]
    },
    getTileCenter: function(d) {
        var e = d[0];
        e = e.geometry;
        for (var c = 1; c < d.length; c++) {
            var a = (e.x + d[c].geometry.x) / 2;
            var g = (e.y + d[c].geometry.y) / 2;
            e = {
                x: a,
                y: g
            }
        }
        return e
    },
    getDataExtent: function() {
        if (this.isFeatureChanged) {
            this.isFeatureChanged = false;
            var a = null;
            var c = this.clusterPoints;
            if (c) {
                var d = null;
                for (var e in c) {
                    d = c[e].geometry;
                    if (d) {
                        if (a === null) {
                            a = new SuperMap.Bounds()
                        }
                        a.extend(d.getBounds())
                    }
                }
            }
            this.dataExtent = a
        }
        return this.dataExtent
    },
    CLASS_NAME: "SuperMap.Layer.ClusterLayer"
});
SuperMap.Popup.Anchored = SuperMap.Class(SuperMap.Popup, {
    relativePosition: null,
    keepInMap: true,
    anchor: null,
    initialize: function(i, e, h, d, c, g, f) {
        var a = [i, e, h, d, g, f];
        SuperMap.Popup.prototype.initialize.apply(this, a);
        this.anchor = (c != null) ? c : {
            size: new SuperMap.Size(0,0),
            offset: new SuperMap.Pixel(0,0)
        }
    },
    destroy: function() {
        this.anchor = null;
        this.relativePosition = null;
        SuperMap.Popup.prototype.destroy.apply(this, arguments)
    },
    show: function() {
        this.updatePosition();
        SuperMap.Popup.prototype.show.apply(this, arguments)
    },
    moveTo: function(d) {
        var c = this.relativePosition;
        this.relativePosition = this.calculateRelativePosition(d);
        var e = this.calculateNewPx(d);
        var a = new Array(e);
        SuperMap.Popup.prototype.moveTo.apply(this, a);
        if (this.relativePosition != c) {
            this.updateRelativePosition()
        }
    },
    setSize: function(c) {
        SuperMap.Popup.prototype.setSize.apply(this, arguments);
        if ((this.lonlat) && (this.map)) {
            var a = this.map.getLayerPxFromLonLat(this.lonlat);
            this.moveTo(a)
        }
    },
    calculateRelativePosition: function(c) {
        var e = this.map.getLonLatFromLayerPx(c);
        var d = this.map.getExtent();
        var a = d.determineQuadrant(e);
        return SuperMap.Bounds.oppositeQuadrant(a)
    },
    updateRelativePosition: function() {},
    calculateNewPx: function(c) {
        var f = c.offset(this.anchor.offset);
        var a = this.size || this.contentSize;
        if (this.isShowShadow) {
            this.relativePosition = "tr"
        }
        var e = (this.relativePosition.charAt(0) == "t");
        f.y += (e) ? -a.h : this.anchor.size.h;
        var d = (this.relativePosition.charAt(1) == "l");
        f.x += (d) ? -a.w : this.anchor.size.w;
        return f
    },
    CLASS_NAME: "SuperMap.Popup.Anchored"
});
SuperMap.Popup.Framed = SuperMap.Class(SuperMap.Popup.Anchored, {
    imageSrc: null,
    imageSize: null,
    isAlphaImage: false,
    positionBlocks: null,
    blocks: null,
    fixedRelativePosition: false,
    initialize: function(h, d, g, c, a, f, e) {
        SuperMap.Popup.Anchored.prototype.initialize.apply(this, arguments);
        if (this.fixedRelativePosition) {
            this.updateRelativePosition();
            this.calculateRelativePosition = function(i) {
                return this.relativePosition
            }
        }
        this.contentDiv.style.position = "absolute";
        this.contentDiv.style.zIndex = 1;
        if (f) {
            this.closeDiv.style.zIndex = 1
        }
        this.groupDiv.style.position = "absolute";
        this.groupDiv.style.top = "0px";
        this.groupDiv.style.left = "0px";
        this.groupDiv.style.height = "100%";
        this.groupDiv.style.width = "100%"
    },
    destroy: function() {
        this.imageSrc = null;
        this.imageSize = null;
        this.isAlphaImage = null;
        this.fixedRelativePosition = false;
        this.positionBlocks = null;
        for (var a = 0; a < this.blocks.length; a++) {
            var c = this.blocks[a];
            if (c.image) {
                c.div.removeChild(c.image)
            }
            c.image = null;
            if (c.div) {
                this.groupDiv.removeChild(c.div)
            }
            c.div = null
        }
        this.blocks = null;
        SuperMap.Popup.Anchored.prototype.destroy.apply(this, arguments)
    },
    setBackgroundColor: function(a) {},
    setBorder: function() {},
    setOpacity: function(a) {},
    setSize: function(a) {
        SuperMap.Popup.Anchored.prototype.setSize.apply(this, arguments);
        this.updateBlocks()
    },
    updateRelativePosition: function() {
        this.padding = this.positionBlocks[this.relativePosition].padding;
        if (this.closeDiv) {
            var a = this.getContentDivPadding();
            this.closeDiv.style.right = a.right + this.padding.right + "px";
            this.closeDiv.style.top = a.top + this.padding.top + "px"
        }
        this.updateBlocks()
    },
    calculateNewPx: function(a) {
        var c = SuperMap.Popup.Anchored.prototype.calculateNewPx.apply(this, arguments);
        c = c.offset(this.positionBlocks[this.relativePosition].offset);
        return c
    },
    createBlocks: function() {
        this.blocks = [];
        var g = null;
        for (var f in this.positionBlocks) {
            g = f;
            break
        }
        var a = this.positionBlocks[g];
        for (var e = 0; e < a.blocks.length; e++) {
            var j = {};
            this.blocks.push(j);
            var c = this.id + "_FrameDecorationDiv_" + e;
            j.div = SuperMap.Util.createDiv(c, null, null, null, "absolute", null, "hidden", null);
            var d = this.id + "_FrameDecorationImg_" + e;
            var h = (this.isAlphaImage) ? SuperMap.Util.createAlphaImageDiv : SuperMap.Util.createImage;
            j.image = h(d, null, this.imageSize, this.imageSrc, "absolute", null, null, null);
            j.div.appendChild(j.image);
            this.groupDiv.appendChild(j.div)
        }
    },
    updateBlocks: function() {
        if (!this.blocks) {
            this.createBlocks()
        }
        if (this.size && this.relativePosition) {
            var j = this.positionBlocks[this.relativePosition];
            for (var f = 0; f < j.blocks.length; f++) {
                var c = j.blocks[f];
                var e = this.blocks[f];
                var d = c.anchor.left;
                var k = c.anchor.bottom;
                var a = c.anchor.right;
                var n = c.anchor.top;
                var m = (isNaN(c.size.w)) ? this.size.w - (a + d) : c.size.w;
                var g = (isNaN(c.size.h)) ? this.size.h - (k + n) + 32 : c.size.h;
                e.div.style.width = (m < 0 ? 0 : m) + "px";
                e.div.style.height = (g < 0 ? 0 : g) + "px";
                e.div.style.left = (d != null) ? d + "px" : "";
                e.div.style.bottom = (k != null) ? k + "px" : "";
                e.div.style.right = (a != null) ? a + "px" : "";
                e.div.style.top = (n != null) ? n + "px" : "";
                e.image.style.left = c.position.x + "px";
                e.image.style.top = c.position.y + "px"
            }
            this.contentDiv.style.left = this.padding.left + "px";
            this.contentDiv.style.top = this.padding.top + "px"
        }
    },
    CLASS_NAME: "SuperMap.Popup.Framed"
});
SuperMap.Popup.FramedCloud = SuperMap.Class(SuperMap.Popup.Framed, {
    contentDisplayClass: "smFramedCloudPopupContent",
    autoSize: true,
    panMapIfOutOfView: true,
    imageSize: new SuperMap.Size(1276,736),
    isAlphaImage: false,
    fixedRelativePosition: false,
    positionBlocks: {
        tl: {
            offset: new SuperMap.Pixel(44,-32),
            padding: new SuperMap.Bounds(0,0,0,-2),
            blocks: [{
                size: new SuperMap.Size("auto","auto"),
                anchor: new SuperMap.Bounds(0,51,22,0),
                position: new SuperMap.Pixel(0,0)
            }, {
                size: new SuperMap.Size(22,"auto"),
                anchor: new SuperMap.Bounds(null,50,0,0),
                position: new SuperMap.Pixel(-1238,0)
            }, {
                size: new SuperMap.Size("auto",19),
                anchor: new SuperMap.Bounds(0,0,22,null),
                position: new SuperMap.Pixel(0,-631)
            }, {
                size: new SuperMap.Size(22,18),
                anchor: new SuperMap.Bounds(null,0,0,null),
                position: new SuperMap.Pixel(-1238,-632)
            }, {
                size: new SuperMap.Size(29,35),
                anchor: new SuperMap.Bounds(null,-27,44,null),
                position: new SuperMap.Pixel(-4,-683)
            }]
        },
        tr: {
            offset: new SuperMap.Pixel(-45,-32),
            padding: new SuperMap.Bounds(0,0,0,-1),
            blocks: [{
                size: new SuperMap.Size("auto","auto"),
                anchor: new SuperMap.Bounds(0,51,22,0),
                position: new SuperMap.Pixel(0,0)
            }, {
                size: new SuperMap.Size(22,"auto"),
                anchor: new SuperMap.Bounds(null,50,0,0),
                position: new SuperMap.Pixel(-1238,0)
            }, {
                size: new SuperMap.Size("auto",19),
                anchor: new SuperMap.Bounds(0,0,22,null),
                position: new SuperMap.Pixel(0,-631)
            }, {
                size: new SuperMap.Size(22,19),
                anchor: new SuperMap.Bounds(null,0,0,null),
                position: new SuperMap.Pixel(-1238,-631)
            }, {
                size: new SuperMap.Size(29,35),
                anchor: new SuperMap.Bounds(43,-27,null,null),
                position: new SuperMap.Pixel(-263,-682)
            }]
        },
        bl: {
            offset: new SuperMap.Pixel(45,32),
            padding: new SuperMap.Bounds(0,1,0,0),
            blocks: [{
                size: new SuperMap.Size("auto","auto"),
                anchor: new SuperMap.Bounds(0,53,22,0),
                position: new SuperMap.Pixel(0,0)
            }, {
                size: new SuperMap.Size(22,"auto"),
                anchor: new SuperMap.Bounds(null,53,0,0),
                position: new SuperMap.Pixel(-1238,0)
            }, {
                size: new SuperMap.Size("auto",21),
                anchor: new SuperMap.Bounds(0,0,22,null),
                position: new SuperMap.Pixel(0,-629)
            }, {
                size: new SuperMap.Size(22,21),
                anchor: new SuperMap.Bounds(null,0,0,null),
                position: new SuperMap.Pixel(-1238,-629)
            }, {
                size: new SuperMap.Size(29,33),
                anchor: new SuperMap.Bounds(null,null,43,-27),
                position: new SuperMap.Pixel(-106,-679)
            }]
        },
        br: {
            offset: new SuperMap.Pixel(-44,32),
            padding: new SuperMap.Bounds(0,1,0,0),
            blocks: [{
                size: new SuperMap.Size("auto","auto"),
                anchor: new SuperMap.Bounds(0,53,22,0),
                position: new SuperMap.Pixel(0,0)
            }, {
                size: new SuperMap.Size(22,"auto"),
                anchor: new SuperMap.Bounds(null,53,0,0),
                position: new SuperMap.Pixel(-1238,0)
            }, {
                size: new SuperMap.Size("auto",21),
                anchor: new SuperMap.Bounds(0,0,22,null),
                position: new SuperMap.Pixel(0,-629)
            }, {
                size: new SuperMap.Size(22,21),
                anchor: new SuperMap.Bounds(null,0,0,null),
                position: new SuperMap.Pixel(-1238,-629)
            }, {
                size: new SuperMap.Size(29,33),
                anchor: new SuperMap.Bounds(45,null,null,-28),
                position: new SuperMap.Pixel(-359,-678)
            }]
        }
    },
    minSize: new SuperMap.Size(105,30),
    maxSize: new SuperMap.Size(1200,660),
    shadowDiv: null,
    isShowShadow: true,
    initialize: function(i, e, h, d, a, g, f, c) {
        if (c != undefined) {
            this.isShowShadow = c
        }
        this.imageSrc = SuperMap.Util.getImagesLocation() + "cloud-popup-relative.png";
        SuperMap.Popup.Framed.prototype.initialize.apply(this, arguments);
        this.contentDiv.className = this.contentDisplayClass
    },
    draw: function(a) {
        SuperMap.Popup.prototype.draw.apply(this, [a]);
        if (this.isShowShadow) {
            this.shadowDiv = this.createShadowFromPopup(parseInt(this.div.style.left), parseInt(this.div.style.top), parseInt(this.div.style.width), parseInt(this.div.style.height));
            this.map.shadowContainerDiv.appendChild(this.shadowDiv)
        }
        return this.div
    },
    createShadowFromPopup: function(q, p, e, s) {
        var r = {
            url: SuperMap.Util.getImagesLocation() + "shadow-popup-subject.png",
            width: 1187,
            height: 331,
            leftTop: {
                x: 338,
                y: 0
            },
            leftBottom: {
                x: 8,
                y: 330
            },
            rightTop: {
                x: 1175,
                y: 0
            },
            rightBottom: {
                x: 845,
                y: 330
            }
        };
        r.ratio = (r.leftBottom.y - r.leftTop.y) / (r.leftTop.x - r.leftBottom.x);
        var l = s * (2 / 3);
        var a = l / r.ratio;
        var d = {
            left: q,
            top: parseInt(p + s - l + 15),
            width: parseInt(e + a + a / 4),
            height: parseInt(l)
        };
        var c = document.createElement("div");
        c.id = SuperMap.Util.createUniqueID("SuperMapShadowDiv");
        c.style.position = "absolute";
        c.style.left = d.left + "px";
        c.style.top = d.top + "px";
        c.style.width = d.width + "px";
        c.style.height = d.height + "px";
        var h = parseInt(a);
        var k = 10;
        var n = [];
        n[0] = {
            div: {
                left: 0,
                top: 0,
                width: h,
                height: k
            },
            img: {
                left: -r.leftTop.x + h,
                top: -r.leftTop.y,
                width: r.width,
                height: r.height
            }
        };
        n[1] = {
            div: {
                left: h,
                top: 0,
                width: d.width - h * 2,
                height: k
            },
            img: {
                left: -r.leftTop.x,
                top: -r.leftTop.y,
                width: r.width,
                height: r.height
            }
        };
        n[6] = {
            div: {
                left: 0,
                top: d.height - k,
                width: h,
                height: k
            },
            img: {
                left: -(d.height) / r.ratio - r.leftBottom.x + h,
                top: -r.leftBottom.y + k,
                width: r.width,
                height: r.height
            }
        };
        n[3] = {
            div: {
                left: 0,
                top: k,
                width: h,
                height: d.height - k * 2
            },
            img: {
                left: -r.leftTop.x + h,
                top: -r.leftTop.y - k,
                width: r.width,
                height: r.height
            }
        };
        n[4] = {
            div: {
                left: h,
                top: k,
                width: d.width - h * 2,
                height: d.height - k * 2
            },
            img: {
                left: -r.leftTop.x,
                top: -r.leftTop.y - k,
                width: r.width,
                height: r.height
            }
        };
        n[8] = {
            div: {
                left: d.width - h,
                top: d.height - k,
                width: h,
                height: k
            },
            img: {
                left: -r.rightBottom.x,
                top: -r.rightBottom.y + k,
                width: r.width,
                height: r.height
            }
        };
        n[7] = {
            div: {
                left: h,
                top: d.height - k,
                width: d.width - h * 2,
                height: k
            },
            img: {
                left: -r.rightBottom.x + d.width - h * 2,
                top: -r.rightBottom.y + k,
                width: r.width,
                height: r.height
            }
        };
        n[5] = {
            div: {
                left: d.width - h,
                top: k,
                width: h,
                height: d.height - k * 2
            },
            img: {
                left: -r.rightBottom.x,
                top: -r.rightBottom.y + d.height - k,
                width: r.width,
                height: r.height
            }
        };
        n[2] = {
            div: {
                left: d.width - h,
                top: 0,
                width: h,
                height: k
            },
            img: {
                left: -r.rightTop.x + (d.height) / r.ratio,
                top: -r.rightTop.y,
                width: r.width,
                height: r.height
            }
        };
        for (var j = 0; j < n.length; j++) {
            if (n[j] != null) {
                var m = document.createElement("div");
                m.id = SuperMap.Util.createUniqueID("SuperMapDiv");
                m.style.overflow = "hidden";
                m.style.index = 1;
                m.style.zIndex = j + 1;
                m.style.position = "absolute";
                m.style.left = n[j].div.left + "px";
                m.style.top = n[j].div.top + "px";
                m.style.width = n[j].div.width + "px";
                m.style.height = n[j].div.height + "px";
                var g = document.createElement("img");
                g.src = SuperMap.Util.getImagesLocation() + "shadow-popup-subject.png";
                g.style.position = "absolute";
                g.style.left = n[j].img.left + "px";
                g.style.top = n[j].img.top + "px";
                g.style.width = n[j].img.width + "px";
                g.style.height = n[j].img.height + "px";
                m.appendChild(g);
                c.appendChild(m)
            }
        }
        var f = document.createElement("div");
        f.id = SuperMap.Util.createUniqueID("SuperMapDivimgCorner");
        f.style.overflow = "hidden";
        f.style.index = 1;
        f.style.zIndex = 0;
        f.style.position = "absolute";
        f.style.left = 50 + "px";
        f.style.top = d.height - 11 + "px";
        f.style.width = 80 + "px";
        f.style.height = 20 + "px";
        var o = document.createElement("img");
        o.src = SuperMap.Util.getImagesLocation() + "shadow-popup-corner.png";
        o.style.position = "absolute";
        o.style.left = 0 + "px";
        o.style.top = 0 + "px";
        o.style.width = 80 + "px";
        o.style.height = 20 + "px";
        f.appendChild(o);
        c.appendChild(f);
        return c
    },
    hide: function() {
        SuperMap.Popup.prototype.hide.apply(this);
        if (this.shadowDiv) {
            this.isShowShadow = false;
            this.shadowDiv.style.display = "none"
        }
    },
    CLASS_NAME: "SuperMap.Popup.FramedCloud"
});
SuperMap.Style = SuperMap.Class({
    id: null,
    name: null,
    title: null,
    description: null,
    layerName: null,
    isDefault: false,
    rules: null,
    context: null,
    defaultStyle: null,
    defaultsPerSymbolizer: false,
    propertyStyles: null,
    initialize: function(c, a) {
        SuperMap.Util.extend(this, a);
        this.rules = [];
        if (a && a.rules) {
            this.addRules(a.rules)
        }
        this.setDefaultStyle(c || SuperMap.Feature.Vector.style["default"]);
        this.id = SuperMap.Util.createUniqueID(this.CLASS_NAME + "_")
    },
    destroy: function() {
        for (var c = 0, a = this.rules.length; c < a; c++) {
            this.rules[c].destroy();
            this.rules[c] = null
        }
        this.rules = null;
        this.defaultStyle = null
    },
    createSymbolizer: function(l) {
        var a = this.defaultsPerSymbolizer ? {} : this.createLiterals(SuperMap.Util.extend({}, this.defaultStyle), l);
        var k = this.rules;
        var j, c;
        var d = [];
        var g = false;
        for (var e = 0, f = k.length; e < f; e++) {
            j = k[e];
            var h = j.evaluate(l);
            if (h) {
                if (j instanceof SuperMap.Rule && j.elseFilter) {
                    d.push(j)
                } else {
                    g = true;
                    this.applySymbolizer(j, a, l)
                }
            }
        }
        if (g == false && d.length > 0) {
            g = true;
            for (var e = 0, f = d.length; e < f; e++) {
                this.applySymbolizer(d[e], a, l)
            }
        }
        if (k.length > 0 && g == false) {
            a.display = "none"
        }
        if (a.label != null && typeof a.label !== "string") {
            a.label = String(a.label)
        }
        return a
    },
    applySymbolizer: function(g, e, c) {
        var a = c.geometry ? this.getSymbolizerPrefix(c.geometry) : SuperMap.Style.SYMBOLIZER_PREFIXES[0];
        var d = g.symbolizer[a] || g.symbolizer;
        if (this.defaultsPerSymbolizer === true) {
            var f = this.defaultStyle;
            SuperMap.Util.applyDefaults(d, {
                pointRadius: f.pointRadius
            });
            if (d.stroke === true || d.graphic === true) {
                SuperMap.Util.applyDefaults(d, {
                    strokeWidth: f.strokeWidth,
                    strokeColor: f.strokeColor,
                    strokeOpacity: f.strokeOpacity,
                    strokeDashstyle: f.strokeDashstyle,
                    strokeLinecap: f.strokeLinecap
                })
            }
            if (d.fill === true || d.graphic === true) {
                SuperMap.Util.applyDefaults(d, {
                    fillColor: f.fillColor,
                    fillOpacity: f.fillOpacity
                })
            }
            if (d.graphic === true) {
                SuperMap.Util.applyDefaults(d, {
                    pointRadius: this.defaultStyle.pointRadius,
                    externalGraphic: this.defaultStyle.externalGraphic,
                    graphicName: this.defaultStyle.graphicName,
                    graphicOpacity: this.defaultStyle.graphicOpacity,
                    graphicWidth: this.defaultStyle.graphicWidth,
                    graphicHeight: this.defaultStyle.graphicHeight,
                    graphicXOffset: this.defaultStyle.graphicXOffset,
                    graphicYOffset: this.defaultStyle.graphicYOffset
                })
            }
        }
        return this.createLiterals(SuperMap.Util.extend(e, d), c)
    },
    createLiterals: function(e, d) {
        var c = SuperMap.Util.extend({}, d.attributes || d.data);
        SuperMap.Util.extend(c, this.context);
        for (var a in this.propertyStyles) {
            e[a] = SuperMap.Style.createLiteral(e[a], c, d, a)
        }
        return e
    },
    findPropertyStyles: function() {
        var e = {};
        var g = this.defaultStyle;
        this.addPropertyStyles(e, g);
        var j = this.rules;
        var f, h;
        for (var d = 0, a = j.length; d < a; d++) {
            f = j[d].symbolizer;
            for (var c in f) {
                h = f[c];
                if (typeof h == "object") {
                    this.addPropertyStyles(e, h)
                } else {
                    this.addPropertyStyles(e, f);
                    break
                }
            }
        }
        return e
    },
    addPropertyStyles: function(c, d) {
        var e;
        for (var a in d) {
            e = d[a];
            if (typeof e == "string" && e.match(/\$\{\w+\}/)) {
                c[a] = true
            }
        }
        return c
    },
    addRules: function(a) {
        Array.prototype.push.apply(this.rules, a);
        this.propertyStyles = this.findPropertyStyles()
    },
    setDefaultStyle: function(a) {
        this.defaultStyle = a;
        this.propertyStyles = this.findPropertyStyles()
    },
    getSymbolizerPrefix: function(e) {
        var d = SuperMap.Style.SYMBOLIZER_PREFIXES;
        for (var c = 0, a = d.length; c < a; c++) {
            if (e.CLASS_NAME.indexOf(d[c]) != -1) {
                return d[c]
            }
        }
    },
    clone: function() {
        var c = SuperMap.Util.extend({}, this);
        if (this.rules) {
            c.rules = [];
            for (var d = 0, a = this.rules.length; d < a; ++d) {
                c.rules.push(this.rules[d].clone())
            }
        }
        c.context = this.context && SuperMap.Util.extend({}, this.context);
        var e = SuperMap.Util.extend({}, this.defaultStyle);
        return new SuperMap.Style(e,c)
    },
    CLASS_NAME: "SuperMap.Style"
});
SuperMap.Style.createLiteral = function(e, c, a, d) {
    if (typeof e == "string" && e.indexOf("${") != -1) {
        e = SuperMap.String.format(e, c, [a, d]);
        e = (isNaN(e) || !e) ? e : parseFloat(e)
    }
    return e
}
;
SuperMap.Style.SYMBOLIZER_PREFIXES = ["Point", "Line", "Polygon", "Text", "Raster"];
SuperMap.StyleMap = SuperMap.Class({
    styles: null,
    extendDefault: true,
    initialize: function(d, a) {
        this.styles = {
            "default": new SuperMap.Style(SuperMap.Feature.Vector.style["default"]),
            select: new SuperMap.Style(SuperMap.Feature.Vector.style.select),
            temporary: new SuperMap.Style(SuperMap.Feature.Vector.style.temporary),
            "delete": new SuperMap.Style(SuperMap.Feature.Vector.style["delete"])
        };
        if (d instanceof SuperMap.Style) {
            this.styles["default"] = d;
            this.styles.select = d;
            this.styles.temporary = d;
            this.styles["delete"] = d
        } else {
            if (typeof d == "object") {
                for (var c in d) {
                    if (d[c]instanceof SuperMap.Style) {
                        this.styles[c] = d[c]
                    } else {
                        if (typeof d[c] == "object") {
                            this.styles[c] = new SuperMap.Style(d[c])
                        } else {
                            this.styles["default"] = new SuperMap.Style(d);
                            this.styles.select = new SuperMap.Style(d);
                            this.styles.temporary = new SuperMap.Style(d);
                            this.styles["delete"] = new SuperMap.Style(d);
                            break
                        }
                    }
                }
            }
        }
        SuperMap.Util.extend(this, a)
    },
    destroy: function() {
        for (var a in this.styles) {
            this.styles[a].destroy()
        }
        this.styles = null
    },
    createSymbolizer: function(c, d) {
        if (!c) {
            c = new SuperMap.Feature.Vector()
        }
        if (!this.styles[d]) {
            d = "default"
        }
        c.renderIntent = d;
        var a = {};
        if (this.extendDefault && d != "default") {
            a = this.styles["default"].createSymbolizer(c)
        }
        return SuperMap.Util.extend(a, this.styles[d].createSymbolizer(c))
    },
    addUniqueValueRules: function(c, e, g, a) {
        var f = [];
        for (var d in g) {
            f.push(new SuperMap.Rule({
                symbolizer: g[d],
                context: a,
                filter: new SuperMap.Filter.Comparison({
                    type: SuperMap.Filter.Comparison.EQUAL_TO,
                    property: e,
                    value: d
                })
            }))
        }
        this.styles[c].addRules(f)
    },
    CLASS_NAME: "SuperMap.StyleMap"
});
SuperMap.Rule = SuperMap.Class({
    id: null,
    name: null,
    title: null,
    description: null,
    context: null,
    filter: null,
    elseFilter: false,
    symbolizer: null,
    symbolizers: null,
    minScaleDenominator: null,
    maxScaleDenominator: null,
    initialize: function(a) {
        this.symbolizer = {};
        SuperMap.Util.extend(this, a);
        if (this.symbolizers) {
            delete this.symbolizer
        }
        this.id = SuperMap.Util.createUniqueID(this.CLASS_NAME + "_")
    },
    destroy: function() {
        for (var a in this.symbolizer) {
            this.symbolizer[a] = null
        }
        this.symbolizer = null;
        delete this.symbolizers
    },
    evaluate: function(d) {
        var c = this.getContext(d);
        var a = true;
        if (this.minScaleDenominator || this.maxScaleDenominator) {
            var e = d.layer.map.getScale()
        }
        if (this.minScaleDenominator) {
            a = e >= SuperMap.Style.createLiteral(this.minScaleDenominator, c)
        }
        if (a && this.maxScaleDenominator) {
            a = e < SuperMap.Style.createLiteral(this.maxScaleDenominator, c)
        }
        if (a && this.filter) {
            if (this.filter.CLASS_NAME == "SuperMap.Filter.FeatureId") {
                a = this.filter.evaluate(d)
            } else {
                a = this.filter.evaluate(c)
            }
        }
        return a
    },
    getContext: function(c) {
        var a = this.context;
        if (!a) {
            a = c.attributes || c.data
        }
        if (typeof this.context == "function") {
            a = this.context(c)
        }
        return a
    },
    clone: function() {
        var c = SuperMap.Util.extend({}, this);
        if (this.symbolizers) {
            var a = this.symbolizers.length;
            c.symbolizers = new Array(a);
            for (var e = 0; e < a; ++e) {
                c.symbolizers[e] = this.symbolizers[e].clone()
            }
        } else {
            c.symbolizer = {};
            var g, f;
            for (var d in this.symbolizer) {
                g = this.symbolizer[d];
                f = typeof g;
                if (f === "object") {
                    c.symbolizer[d] = SuperMap.Util.extend({}, g)
                } else {
                    if (f === "string") {
                        c.symbolizer[d] = g
                    }
                }
            }
        }
        c.filter = this.filter && this.filter.clone();
        c.context = this.context && SuperMap.Util.extend({}, this.context);
        return new SuperMap.Rule(c)
    },
    CLASS_NAME: "SuperMap.Rule"
});
SuperMap.Filter = SuperMap.Class({
    initialize: function(a) {
        SuperMap.Util.extend(this, a)
    },
    destroy: function() {},
    evaluate: function(a) {
        return true
    },
    clone: function() {
        return null
    },
    toString: function() {
        var a;
        if (SuperMap.Format && SuperMap.Format.CQL) {
            a = SuperMap.Format.CQL.prototype.write(this)
        } else {
            a = Object.prototype.toString.call(this)
        }
        return a
    },
    CLASS_NAME: "SuperMap.Filter"
});
SuperMap.Filter.Spatial = SuperMap.Class(SuperMap.Filter, {
    type: null,
    property: null,
    value: null,
    distance: null,
    distanceUnits: null,
    evaluate: function(d) {
        var a = false;
        switch (this.type) {
        case SuperMap.Filter.Spatial.BBOX:
        case SuperMap.Filter.Spatial.INTERSECTS:
            if (d.geometry) {
                var c = this.value;
                if (this.value.CLASS_NAME == "SuperMap.Bounds") {
                    c = this.value.toGeometry()
                }
                if (d.geometry.intersects(c)) {
                    a = true
                }
            }
            break;
        default:
            throw new Error("evaluate is not implemented for this filter type.")
        }
        return a
    },
    clone: function() {
        var a = SuperMap.Util.applyDefaults({
            value: this.value && this.value.clone && this.value.clone()
        }, this);
        return new SuperMap.Filter.Spatial(a)
    },
    CLASS_NAME: "SuperMap.Filter.Spatial"
});
SuperMap.Filter.Spatial.BBOX = "BBOX";
SuperMap.Filter.Spatial.INTERSECTS = "INTERSECTS";
SuperMap.Filter.Spatial.DWITHIN = "DWITHIN";
SuperMap.Filter.Spatial.WITHIN = "WITHIN";
SuperMap.Filter.Spatial.CONTAINS = "CONTAINS";
SuperMap.Filter.Logical = SuperMap.Class(SuperMap.Filter, {
    filters: null,
    type: null,
    initialize: function(a) {
        this.filters = [];
        SuperMap.Filter.prototype.initialize.apply(this, [a])
    },
    destroy: function() {
        this.filters = null;
        SuperMap.Filter.prototype.destroy.apply(this)
    },
    evaluate: function(d) {
        var c, a;
        switch (this.type) {
        case SuperMap.Filter.Logical.AND:
            for (c = 0,
            a = this.filters.length; c < a; c++) {
                if (this.filters[c].evaluate(d) == false) {
                    return false
                }
            }
            return true;
        case SuperMap.Filter.Logical.OR:
            for (c = 0,
            a = this.filters.length; c < a; c++) {
                if (this.filters[c].evaluate(d) == true) {
                    return true
                }
            }
            return false;
        case SuperMap.Filter.Logical.NOT:
            return ( !this.filters[0].evaluate(d))
        }
        return undefined
    },
    clone: function() {
        var d = [];
        for (var c = 0, a = this.filters.length; c < a; ++c) {
            d.push(this.filters[c].clone())
        }
        return new SuperMap.Filter.Logical({
            type: this.type,
            filters: d
        })
    },
    CLASS_NAME: "SuperMap.Filter.Logical"
});
SuperMap.Filter.Logical.AND = "&&";
SuperMap.Filter.Logical.OR = "||";
SuperMap.Filter.Logical.NOT = "!";
SuperMap.Filter.Comparison = SuperMap.Class(SuperMap.Filter, {
    type: null,
    property: null,
    value: null,
    matchCase: true,
    lowerBoundary: null,
    upperBoundary: null,
    initialize: function(a) {
        SuperMap.Filter.prototype.initialize.apply(this, [a]);
        if (this.type === SuperMap.Filter.Comparison.LIKE && a.matchCase === undefined) {
            this.matchCase = null
        }
    },
    evaluate: function(d) {
        if (d instanceof SuperMap.Feature.Vector) {
            d = d.attributes
        }
        var a = false;
        var c = d[this.property];
        var f;
        switch (this.type) {
        case SuperMap.Filter.Comparison.EQUAL_TO:
            f = this.value;
            if (!this.matchCase && typeof c == "string" && typeof f == "string") {
                a = (c.toUpperCase() == f.toUpperCase())
            } else {
                a = (c == f)
            }
            break;
        case SuperMap.Filter.Comparison.NOT_EQUAL_TO:
            f = this.value;
            if (!this.matchCase && typeof c == "string" && typeof f == "string") {
                a = (c.toUpperCase() != f.toUpperCase())
            } else {
                a = (c != f)
            }
            break;
        case SuperMap.Filter.Comparison.LESS_THAN:
            a = c < this.value;
            break;
        case SuperMap.Filter.Comparison.GREATER_THAN:
            a = c > this.value;
            break;
        case SuperMap.Filter.Comparison.LESS_THAN_OR_EQUAL_TO:
            a = c <= this.value;
            break;
        case SuperMap.Filter.Comparison.GREATER_THAN_OR_EQUAL_TO:
            a = c >= this.value;
            break;
        case SuperMap.Filter.Comparison.BETWEEN:
            a = (c >= this.lowerBoundary) && (c <= this.upperBoundary);
            break;
        case SuperMap.Filter.Comparison.LIKE:
            var e = new RegExp(this.value,"gi");
            a = e.test(c);
            break
        }
        return a
    },
    value2regex: function(d, c, a) {
        if (d == ".") {
            throw new Error("'.' is an unsupported wildCard character for SuperMap.Filter.Comparison")
        }
        d = d ? d : "*";
        c = c ? c : ".";
        a = a ? a : "!";
        this.value = this.value.replace(new RegExp("\\" + a + "(.|$)","g"), "\\$1");
        this.value = this.value.replace(new RegExp("\\" + c,"g"), ".");
        this.value = this.value.replace(new RegExp("\\" + d,"g"), ".*");
        this.value = this.value.replace(new RegExp("\\\\.\\*","g"), "\\" + d);
        this.value = this.value.replace(new RegExp("\\\\\\.","g"), "\\" + c);
        return this.value
    },
    regex2value: function() {
        var a = this.value;
        a = a.replace(/!/g, "!!");
        a = a.replace(/(\\)?\\\./g, function(d, c) {
            return c ? d : "!."
        });
        a = a.replace(/(\\)?\\\*/g, function(d, c) {
            return c ? d : "!*"
        });
        a = a.replace(/\\\\/g, "\\");
        a = a.replace(/\.\*/g, "*");
        return a
    },
    clone: function() {
        return SuperMap.Util.extend(new SuperMap.Filter.Comparison(), this)
    },
    CLASS_NAME: "SuperMap.Filter.Comparison"
});
SuperMap.Filter.Comparison.EQUAL_TO = "==";
SuperMap.Filter.Comparison.NOT_EQUAL_TO = "!=";
SuperMap.Filter.Comparison.LESS_THAN = "<";
SuperMap.Filter.Comparison.GREATER_THAN = ">";
SuperMap.Filter.Comparison.LESS_THAN_OR_EQUAL_TO = "<=";
SuperMap.Filter.Comparison.GREATER_THAN_OR_EQUAL_TO = ">=";
SuperMap.Filter.Comparison.BETWEEN = "..";
SuperMap.Filter.Comparison.LIKE = "~";
SuperMap.Format = SuperMap.Class({
    options: null,
    externalProjection: null,
    internalProjection: null,
    data: null,
    keepData: false,
    initialize: function(a) {
        SuperMap.Util.extend(this, a);
        this.options = a
    },
    destroy: function() {},
    read: function(a) {},
    write: function(a) {},
    CLASS_NAME: "SuperMap.Format"
});
SuperMap.Format.WKT = SuperMap.Class(SuperMap.Format, {
    initialize: function(a) {
        this.regExes = {
            typeStr: /^\s*(\w+)\s*\(\s*(.*)\s*\)\s*$/,
            spaces: /\s+/,
            parenComma: /\)\s*,\s*\(/,
            doubleParenComma: /\)\s*\)\s*,\s*\(\s*\(/,
            trimParens: /^\s*\(?(.*?)\)?\s*$/
        };
        SuperMap.Format.prototype.initialize.apply(this, [a])
    },
    read: function(g) {
        var f, e, j;
        g = g.replace(/[\n\r]/g, " ");
        var h = this.regExes.typeStr.exec(g);
        if (h) {
            e = h[1].toLowerCase();
            j = h[2];
            if (this.parse[e]) {
                f = this.parse[e].apply(this, [j])
            }
            if (this.internalProjection && this.externalProjection) {
                if (f && f.CLASS_NAME == "SuperMap.Feature.Vector") {
                    f.geometry.transform(this.externalProjection, this.internalProjection)
                } else {
                    if (f && e != "geometrycollection" && typeof f == "object") {
                        for (var d = 0, a = f.length; d < a; d++) {
                            var c = f[d];
                            c.geometry.transform(this.externalProjection, this.internalProjection)
                        }
                    }
                }
            }
        }
        return f
    },
    write: function(a) {
        var g, k, j, e, c;
        if (a.constructor == Array) {
            g = a;
            c = true
        } else {
            g = [a];
            c = false
        }
        var d = [];
        if (c) {
            d.push("GEOMETRYCOLLECTION(")
        }
        for (var f = 0, h = g.length; f < h; ++f) {
            if (c && f > 0) {
                d.push(",")
            }
            k = g[f].geometry;
            d.push(this.extractGeometry(k))
        }
        if (c) {
            d.push(")")
        }
        return d.join("")
    },
    extractGeometry: function(e) {
        var c = e.CLASS_NAME.split(".")[2].toLowerCase();
        if (!this.extract[c]) {
            return null
        }
        if (this.internalProjection && this.externalProjection) {
            e = e.clone();
            e.transform(this.internalProjection, this.externalProjection)
        }
        var a = c == "collection" ? "GEOMETRYCOLLECTION" : c.toUpperCase();
        var d = a + "(" + this.extract[c].apply(this, [e]) + ")";
        return d
    },
    extract: {
        point: function(a) {
            return a.x + " " + a.y
        },
        multipoint: function(d) {
            var e = [];
            for (var c = 0, a = d.components.length; c < a; ++c) {
                e.push("(" + this.extract.point.apply(this, [d.components[c]]) + ")")
            }
            return e.join(",")
        },
        linestring: function(c) {
            var e = [];
            for (var d = 0, a = c.components.length; d < a; ++d) {
                e.push(this.extract.point.apply(this, [c.components[d]]))
            }
            return e.join(",")
        },
        multilinestring: function(d) {
            var e = [];
            for (var c = 0, a = d.components.length; c < a; ++c) {
                e.push("(" + this.extract.linestring.apply(this, [d.components[c]]) + ")")
            }
            return e.join(",")
        },
        polygon: function(d) {
            var e = [];
            for (var c = 0, a = d.components.length; c < a; ++c) {
                e.push("(" + this.extract.linestring.apply(this, [d.components[c]]) + ")")
            }
            return e.join(",")
        },
        multipolygon: function(e) {
            var d = [];
            for (var c = 0, a = e.components.length; c < a; ++c) {
                d.push("(" + this.extract.polygon.apply(this, [e.components[c]]) + ")")
            }
            return d.join(",")
        },
        collection: function(d) {
            var e = [];
            for (var c = 0, a = d.components.length; c < a; ++c) {
                e.push(this.extractGeometry.apply(this, [d.components[c]]))
            }
            return e.join(",")
        }
    },
    parse: {
        point: function(c) {
            var a = SuperMap.String.trim(c).split(this.regExes.spaces);
            return new SuperMap.Feature.Vector(new SuperMap.Geometry.Point(a[0],a[1]))
        },
        multipoint: function(g) {
            var c;
            var e = SuperMap.String.trim(g).split(",");
            var f = [];
            for (var d = 0, a = e.length; d < a; ++d) {
                c = e[d].replace(this.regExes.trimParens, "$1");
                f.push(this.parse.point.apply(this, [c]).geometry)
            }
            return new SuperMap.Feature.Vector(new SuperMap.Geometry.MultiPoint(f))
        },
        linestring: function(f) {
            var d = SuperMap.String.trim(f).split(",");
            var e = [];
            for (var c = 0, a = d.length; c < a; ++c) {
                e.push(this.parse.point.apply(this, [d[c]]).geometry)
            }
            return new SuperMap.Feature.Vector(new SuperMap.Geometry.LineString(e))
        },
        multilinestring: function(g) {
            var d;
            var c = SuperMap.String.trim(g).split(this.regExes.parenComma);
            var f = [];
            for (var e = 0, a = c.length; e < a; ++e) {
                d = c[e].replace(this.regExes.trimParens, "$1");
                f.push(this.parse.linestring.apply(this, [d]).geometry)
            }
            return new SuperMap.Feature.Vector(new SuperMap.Geometry.MultiLineString(f))
        },
        polygon: function(j) {
            var d, c, g;
            var h = SuperMap.String.trim(j).split(this.regExes.parenComma);
            var f = [];
            for (var e = 0, a = h.length; e < a; ++e) {
                d = h[e].replace(this.regExes.trimParens, "$1");
                c = this.parse.linestring.apply(this, [d]).geometry;
                g = new SuperMap.Geometry.LinearRing(c.components);
                f.push(g)
            }
            return new SuperMap.Feature.Vector(new SuperMap.Geometry.Polygon(f))
        },
        multipolygon: function(g) {
            var e;
            var c = SuperMap.String.trim(g).split(this.regExes.doubleParenComma);
            var f = [];
            for (var d = 0, a = c.length; d < a; ++d) {
                e = c[d].replace(this.regExes.trimParens, "$1");
                f.push(this.parse.polygon.apply(this, [e]).geometry)
            }
            return new SuperMap.Feature.Vector(new SuperMap.Geometry.MultiPolygon(f))
        },
        geometrycollection: function(f) {
            f = f.replace(/,\s*([A-Za-z])/g, "|$1");
            var e = SuperMap.String.trim(f).split("|");
            var d = [];
            for (var c = 0, a = e.length; c < a; ++c) {
                d.push(SuperMap.Format.WKT.prototype.read.apply(this, [e[c]]))
            }
            return d
        }
    },
    CLASS_NAME: "SuperMap.Format.WKT"
});
SuperMap.Format.XML = SuperMap.Class(SuperMap.Format, {
    namespaces: null,
    namespaceAlias: null,
    defaultPrefix: null,
    readers: {},
    writers: {},
    xmldom: null,
    initialize: function(a) {
        if (window.ActiveXObject) {
            this.xmldom = new ActiveXObject("Microsoft.XMLDOM")
        }
        SuperMap.Format.prototype.initialize.apply(this, [a]);
        this.namespaces = SuperMap.Util.extend({}, this.namespaces);
        this.namespaceAlias = {};
        for (var c in this.namespaces) {
            this.namespaceAlias[this.namespaces[c]] = c
        }
    },
    destroy: function() {
        this.xmldom = null;
        SuperMap.Format.prototype.destroy.apply(this, arguments)
    },
    setNamespace: function(a, c) {
        this.namespaces[a] = c;
        this.namespaceAlias[c] = a
    },
    read: function(d) {
        var a = d.indexOf("<");
        if (a > 0) {
            d = d.substring(a)
        }
        var c = SuperMap.Util.Try(SuperMap.Function.bind((function() {
            var e;
            if (window.ActiveXObject && !this.xmldom) {
                e = new ActiveXObject("Microsoft.XMLDOM")
            } else {
                e = this.xmldom
            }
            e.loadXML(d);
            return e
        }), this), function() {
            return new DOMParser().parseFromString(d, "text/xml")
        }, function() {
            var e = new XMLHttpRequest();
            e.open("GET", "data:text/xml;charset=utf-8," + encodeURIComponent(d), false);
            if (e.overrideMimeType) {
                e.overrideMimeType("text/xml")
            }
            e.send(null);
            return e.responseXML
        });
        if (this.keepData) {
            this.data = c
        }
        return c
    },
    write: function(c) {
        var d;
        if (this.xmldom) {
            d = c.xml
        } else {
            var a = new XMLSerializer();
            if (c.nodeType == 1) {
                var e = document.implementation.createDocument("", "", null);
                if (e.importNode) {
                    c = e.importNode(c, true)
                }
                e.appendChild(c);
                d = a.serializeToString(e)
            } else {
                d = a.serializeToString(c)
            }
        }
        return d
    },
    createElementNS: function(d, a) {
        var c;
        if (this.xmldom) {
            if (typeof d == "string") {
                c = this.xmldom.createNode(1, a, d)
            } else {
                c = this.xmldom.createNode(1, a, "")
            }
        } else {
            c = document.createElementNS(d, a)
        }
        return c
    },
    createTextNode: function(c) {
        var a;
        if (typeof c !== "string") {
            c = String(c)
        }
        if (this.xmldom) {
            a = this.xmldom.createTextNode(c)
        } else {
            a = document.createTextNode(c)
        }
        return a
    },
    getElementsByTagNameNS: function(f, e, d) {
        var a = [];
        if (f.getElementsByTagNameNS) {
            a = f.getElementsByTagNameNS(e, d)
        } else {
            var c = f.getElementsByTagName("*");
            var k, g;
            for (var h = 0, j = c.length; h < j; ++h) {
                k = c[h];
                g = (k.prefix) ? (k.prefix + ":" + d) : d;
                if ((d == "*") || (g == k.nodeName)) {
                    if ((e == "*") || (e == k.namespaceURI)) {
                        a.push(k)
                    }
                }
            }
        }
        return a
    },
    getAttributeNodeNS: function(d, c, a) {
        var k = null;
        if (d.getAttributeNodeNS) {
            k = d.getAttributeNodeNS(c, a)
        } else {
            var f = d.attributes;
            var j, e;
            for (var g = 0, h = f.length; g < h; ++g) {
                j = f[g];
                if (j.namespaceURI == c) {
                    e = (j.prefix) ? (j.prefix + ":" + a) : a;
                    if (e == j.nodeName) {
                        k = j;
                        break
                    }
                }
            }
        }
        return k
    },
    getAttributeNS: function(f, e, a) {
        var c = "";
        if (f.getAttributeNS) {
            c = f.getAttributeNS(e, a) || ""
        } else {
            var d = this.getAttributeNodeNS(f, e, a);
            if (d) {
                c = d.nodeValue
            }
        }
        return c
    },
    getChildValue: function(a, d) {
        var c = d || "";
        if (a) {
            for (var e = a.firstChild; e; e = e.nextSibling) {
                switch (e.nodeType) {
                case 3:
                case 4:
                    c += e.nodeValue
                }
            }
        }
        return c
    },
    isSimpleContent: function(a) {
        var d = true;
        for (var c = a.firstChild; c; c = c.nextSibling) {
            if (c.nodeType === 1) {
                d = false;
                break
            }
        }
        return d
    },
    contentType: function(d) {
        var f = false
          , c = false;
        var a = SuperMap.Format.XML.CONTENT_TYPE.EMPTY;
        for (var e = d.firstChild; e; e = e.nextSibling) {
            switch (e.nodeType) {
            case 1:
                c = true;
                break;
            case 8:
                break;
            default:
                f = true
            }
            if (c && f) {
                break
            }
        }
        if (c && f) {
            a = SuperMap.Format.XML.CONTENT_TYPE.MIXED
        } else {
            if (c) {
                return SuperMap.Format.XML.CONTENT_TYPE.COMPLEX
            } else {
                if (f) {
                    return SuperMap.Format.XML.CONTENT_TYPE.SIMPLE
                }
            }
        }
        return a
    },
    hasAttributeNS: function(d, c, a) {
        var e = false;
        if (d.hasAttributeNS) {
            e = d.hasAttributeNS(c, a)
        } else {
            e = !!this.getAttributeNodeNS(d, c, a)
        }
        return e
    },
    setAttributeNS: function(e, d, a, f) {
        if (e.setAttributeNS) {
            e.setAttributeNS(d, a, f)
        } else {
            if (this.xmldom) {
                if (d) {
                    var c = e.ownerDocument.createNode(2, a, d);
                    c.nodeValue = f;
                    e.setAttributeNode(c)
                } else {
                    e.setAttribute(a, f)
                }
            } else {
                throw "setAttributeNS not implemented"
            }
        }
    },
    createElementNSPlus: function(c, a) {
        a = a || {};
        var e = a.uri || this.namespaces[a.prefix];
        if (!e) {
            var g = c.indexOf(":");
            e = this.namespaces[c.substring(0, g)]
        }
        if (!e) {
            e = this.namespaces[this.defaultPrefix]
        }
        var d = this.createElementNS(e, c);
        if (a.attributes) {
            this.setAttributes(d, a.attributes)
        }
        var f = a.value;
        if (f != null) {
            d.appendChild(this.createTextNode(f))
        }
        return d
    },
    setAttributes: function(d, f) {
        var e, c;
        for (var a in f) {
            if (f[a] != null && f[a].toString) {
                e = f[a].toString();
                c = this.namespaces[a.substring(0, a.indexOf(":"))] || null;
                this.setAttributeNS(d, c, a, e)
            }
        }
    },
    readNode: function(d, f) {
        if (!f) {
            f = {}
        }
        var e = this.readers[d.namespaceURI ? this.namespaceAlias[d.namespaceURI] : this.defaultPrefix];
        if (e) {
            var c = d.localName || d.nodeName.split(":").pop();
            var a = e[c] || e["*"];
            if (a) {
                a.apply(this, [d, f])
            }
        }
        return f
    },
    readChildNodes: function(e, f) {
        if (!f) {
            f = {}
        }
        var d = e.childNodes;
        var g;
        for (var c = 0, a = d.length; c < a; ++c) {
            g = d[c];
            if (g.nodeType == 1) {
                this.readNode(g, f)
            }
        }
        return f
    },
    writeNode: function(a, g, e) {
        var f, d;
        var c = a.indexOf(":");
        if (c > 0) {
            f = a.substring(0, c);
            d = a.substring(c + 1)
        } else {
            if (e) {
                f = this.namespaceAlias[e.namespaceURI]
            } else {
                f = this.defaultPrefix
            }
            d = a
        }
        var h = this.writers[f][d].apply(this, [g]);
        if (e) {
            e.appendChild(h)
        }
        return h
    },
    getChildEl: function(d, a, c) {
        return d && this.getThisOrNextEl(d.firstChild, a, c)
    },
    getNextEl: function(d, a, c) {
        return d && this.getThisOrNextEl(d.nextSibling, a, c)
    },
    getThisOrNextEl: function(e, a, d) {
        outer: for (var c = e; c; c = c.nextSibling) {
            switch (c.nodeType) {
            case 1:
                if ((!a || a === (c.localName || c.nodeName.split(":").pop())) && (!d || d === c.namespaceURI)) {
                    break outer
                }
                c = null;
                break outer;
            case 3:
                if (/^\s*$/.test(c.nodeValue)) {
                    break
                }
            case 4:
            case 6:
            case 12:
            case 10:
            case 11:
                c = null;
                break outer
            }
        }
        return c || null
    },
    lookupNamespaceURI: function(f, g) {
        var e = null;
        if (f) {
            if (f.lookupNamespaceURI) {
                e = f.lookupNamespaceURI(g)
            } else {
                outer: switch (f.nodeType) {
                case 1:
                    if (f.namespaceURI !== null && f.prefix === g) {
                        e = f.namespaceURI;
                        break outer
                    }
                    var c = f.attributes.length;
                    if (c) {
                        var a;
                        for (var d = 0; d < c; ++d) {
                            a = f.attributes[d];
                            if (a.prefix === "xmlns" && a.name === "xmlns:" + g) {
                                e = a.value || null;
                                break outer
                            } else {
                                if (a.name === "xmlns" && g === null) {
                                    e = a.value || null;
                                    break outer
                                }
                            }
                        }
                    }
                    e = this.lookupNamespaceURI(f.parentNode, g);
                    break outer;
                case 2:
                    e = this.lookupNamespaceURI(f.ownerElement, g);
                    break outer;
                case 9:
                    e = this.lookupNamespaceURI(f.documentElement, g);
                    break outer;
                case 6:
                case 12:
                case 10:
                case 11:
                    break outer;
                default:
                    e = this.lookupNamespaceURI(f.parentNode, g);
                    break outer
                }
            }
        }
        return e
    },
    getXMLDoc: function() {
        if (!SuperMap.Format.XML.document && !this.xmldom) {
            if (document.implementation && document.implementation.createDocument) {
                SuperMap.Format.XML.document = document.implementation.createDocument("", "", null)
            } else {
                if (!this.xmldom && window.ActiveXObject) {
                    this.xmldom = new ActiveXObject("Microsoft.XMLDOM")
                }
            }
        }
        return SuperMap.Format.XML.document || this.xmldom
    },
    CLASS_NAME: "SuperMap.Format.XML"
});
SuperMap.Format.XML.CONTENT_TYPE = {
    EMPTY: 0,
    SIMPLE: 1,
    COMPLEX: 2,
    MIXED: 3
};
SuperMap.Format.XML.lookupNamespaceURI = SuperMap.Function.bind(SuperMap.Format.XML.prototype.lookupNamespaceURI, SuperMap.Format.XML.prototype);
SuperMap.Format.XML.document = null;
SuperMap.Format.GML = SuperMap.Class(SuperMap.Format.XML, {
    featureNS: "http://mapserver.gis.umn.edu/mapserver",
    featurePrefix: "feature",
    featureName: "featureMember",
    layerName: "features",
    geometryName: "geometry",
    collectionName: "FeatureCollection",
    gmlns: "http://www.opengis.net/gml",
    extractAttributes: true,
    xy: true,
    initialize: function(a) {
        this.regExes = {
            trimSpace: (/^\s*|\s*$/g),
            removeSpace: (/\s*/g),
            splitSpace: (/\s+/),
            trimComma: (/\s*,\s*/g)
        };
        SuperMap.Format.XML.prototype.initialize.apply(this, [a])
    },
    read: function(e) {
        if (typeof e == "string") {
            e = SuperMap.Format.XML.prototype.read.apply(this, [e])
        }
        var f = this.getElementsByTagNameNS(e.documentElement, this.gmlns, this.featureName);
        var d = [];
        for (var c = 0; c < f.length; c++) {
            var a = this.parseFeature(f[c]);
            if (a) {
                d.push(a)
            }
        }
        return d
    },
    parseFeature: function(e) {
        var f = ["MultiPolygon", "Polygon", "MultiLineString", "LineString", "MultiPoint", "Point", "Envelope"];
        var q, j, r, d;
        for (var m = 0; m < f.length; ++m) {
            q = f[m];
            j = this.getElementsByTagNameNS(e, this.gmlns, q);
            if (j.length > 0) {
                d = this.parseGeometry[q.toLowerCase()];
                if (d) {
                    r = d.apply(this, [j[0]]);
                    if (this.internalProjection && this.externalProjection) {
                        r.transform(this.externalProjection, this.internalProjection)
                    }
                } else {
                    throw new TypeError("Unsupported geometry type: " + q)
                }
                break
            }
        }
        var c;
        var l = this.getElementsByTagNameNS(e, this.gmlns, "Box");
        for (m = 0; m < l.length; ++m) {
            var p = l[m];
            var o = this.parseGeometry.box.apply(this, [p]);
            var n = p.parentNode;
            var h = n.localName || n.nodeName.split(":").pop();
            if (h === "boundedBy") {
                c = o
            } else {
                r = o.toGeometry()
            }
        }
        var k;
        if (this.extractAttributes) {
            k = this.parseAttributes(e)
        }
        var s = new SuperMap.Feature.Vector(r,k);
        s.bounds = c;
        s.gml = {
            featureType: e.firstChild.nodeName.split(":")[1],
            featureNS: e.firstChild.namespaceURI,
            featureNSPrefix: e.firstChild.prefix
        };
        var a = e.firstChild;
        var g;
        while (a) {
            if (a.nodeType == 1) {
                g = a.getAttribute("fid") || a.getAttribute("id");
                if (g) {
                    break
                }
            }
            a = a.nextSibling
        }
        s.fid = g;
        return s
    },
    parseGeometry: {
        point: function(e) {
            var c, a;
            var f = [];
            var c = this.getElementsByTagNameNS(e, this.gmlns, "pos");
            if (c.length > 0) {
                a = c[0].firstChild.nodeValue;
                a = a.replace(this.regExes.trimSpace, "");
                f = a.split(this.regExes.splitSpace)
            }
            if (f.length == 0) {
                c = this.getElementsByTagNameNS(e, this.gmlns, "coordinates");
                if (c.length > 0) {
                    a = c[0].firstChild.nodeValue;
                    a = a.replace(this.regExes.removeSpace, "");
                    f = a.split(",")
                }
            }
            if (f.length == 0) {
                c = this.getElementsByTagNameNS(e, this.gmlns, "coord");
                if (c.length > 0) {
                    var g = this.getElementsByTagNameNS(c[0], this.gmlns, "X");
                    var d = this.getElementsByTagNameNS(c[0], this.gmlns, "Y");
                    if (g.length > 0 && d.length > 0) {
                        f = [g[0].firstChild.nodeValue, d[0].firstChild.nodeValue]
                    }
                }
            }
            if (f.length == 2) {
                f[2] = null
            }
            if (this.xy) {
                return new SuperMap.Geometry.Point(f[0],f[1],f[2])
            } else {
                return new SuperMap.Geometry.Point(f[1],f[0],f[2])
            }
        },
        multipoint: function(f) {
            var c = this.getElementsByTagNameNS(f, this.gmlns, "Point");
            var e = [];
            if (c.length > 0) {
                var a;
                for (var d = 0; d < c.length; ++d) {
                    a = this.parseGeometry.point.apply(this, [c[d]]);
                    if (a) {
                        e.push(a)
                    }
                }
            }
            return new SuperMap.Geometry.MultiPoint(e)
        },
        linestring: function(d, f) {
            var e, c;
            var o = [];
            var p = [];
            e = this.getElementsByTagNameNS(d, this.gmlns, "posList");
            if (e.length > 0) {
                c = this.getChildValue(e[0]);
                c = c.replace(this.regExes.trimSpace, "");
                o = c.split(this.regExes.splitSpace);
                var k = parseInt(e[0].getAttribute("dimension"));
                var g, n, m, l;
                for (var h = 0; h < o.length / k; ++h) {
                    g = h * k;
                    n = o[g];
                    m = o[g + 1];
                    l = (k == 2) ? null : o[g + 2];
                    if (this.xy) {
                        p.push(new SuperMap.Geometry.Point(n,m,l))
                    } else {
                        p.push(new SuperMap.Geometry.Point(m,n,l))
                    }
                }
            }
            if (o.length == 0) {
                e = this.getElementsByTagNameNS(d, this.gmlns, "coordinates");
                if (e.length > 0) {
                    c = this.getChildValue(e[0]);
                    c = c.replace(this.regExes.trimSpace, "");
                    c = c.replace(this.regExes.trimComma, ",");
                    var a = c.split(this.regExes.splitSpace);
                    for (var h = 0; h < a.length; ++h) {
                        o = a[h].split(",");
                        if (o.length == 2) {
                            o[2] = null
                        }
                        if (this.xy) {
                            p.push(new SuperMap.Geometry.Point(o[0],o[1],o[2]))
                        } else {
                            p.push(new SuperMap.Geometry.Point(o[1],o[0],o[2]))
                        }
                    }
                }
            }
            var q = null;
            if (p.length != 0) {
                if (f) {
                    q = new SuperMap.Geometry.LinearRing(p)
                } else {
                    q = new SuperMap.Geometry.LineString(p)
                }
            }
            return q
        },
        multilinestring: function(f) {
            var c = this.getElementsByTagNameNS(f, this.gmlns, "LineString");
            var e = [];
            if (c.length > 0) {
                var a;
                for (var d = 0; d < c.length; ++d) {
                    a = this.parseGeometry.linestring.apply(this, [c[d]]);
                    if (a) {
                        e.push(a)
                    }
                }
            }
            return new SuperMap.Geometry.MultiLineString(e)
        },
        polygon: function(f) {
            var c = this.getElementsByTagNameNS(f, this.gmlns, "LinearRing");
            var e = [];
            if (c.length > 0) {
                var a;
                for (var d = 0; d < c.length; ++d) {
                    a = this.parseGeometry.linestring.apply(this, [c[d], true]);
                    if (a) {
                        e.push(a)
                    }
                }
            }
            return new SuperMap.Geometry.Polygon(e)
        },
        multipolygon: function(f) {
            var a = this.getElementsByTagNameNS(f, this.gmlns, "Polygon");
            var e = [];
            if (a.length > 0) {
                var d;
                for (var c = 0; c < a.length; ++c) {
                    d = this.parseGeometry.polygon.apply(this, [a[c]]);
                    if (d) {
                        e.push(d)
                    }
                }
            }
            return new SuperMap.Geometry.MultiPolygon(e)
        },
        envelope: function(c) {
            var f = [];
            var a;
            var g;
            var k = this.getElementsByTagNameNS(c, this.gmlns, "lowerCorner");
            if (k.length > 0) {
                var i = [];
                if (k.length > 0) {
                    a = k[0].firstChild.nodeValue;
                    a = a.replace(this.regExes.trimSpace, "");
                    i = a.split(this.regExes.splitSpace)
                }
                if (i.length == 2) {
                    i[2] = null
                }
                if (this.xy) {
                    var e = new SuperMap.Geometry.Point(i[0],i[1],i[2])
                } else {
                    var e = new SuperMap.Geometry.Point(i[1],i[0],i[2])
                }
            }
            var h = this.getElementsByTagNameNS(c, this.gmlns, "upperCorner");
            if (h.length > 0) {
                var i = [];
                if (h.length > 0) {
                    a = h[0].firstChild.nodeValue;
                    a = a.replace(this.regExes.trimSpace, "");
                    i = a.split(this.regExes.splitSpace)
                }
                if (i.length == 2) {
                    i[2] = null
                }
                if (this.xy) {
                    var j = new SuperMap.Geometry.Point(i[0],i[1],i[2])
                } else {
                    var j = new SuperMap.Geometry.Point(i[1],i[0],i[2])
                }
            }
            if (e && j) {
                f.push(new SuperMap.Geometry.Point(e.x,e.y));
                f.push(new SuperMap.Geometry.Point(j.x,e.y));
                f.push(new SuperMap.Geometry.Point(j.x,j.y));
                f.push(new SuperMap.Geometry.Point(e.x,j.y));
                f.push(new SuperMap.Geometry.Point(e.x,e.y));
                var d = new SuperMap.Geometry.LinearRing(f);
                g = new SuperMap.Geometry.Polygon([d])
            }
            return g
        },
        box: function(f) {
            var d = this.getElementsByTagNameNS(f, this.gmlns, "coordinates");
            var c;
            var g, a = null, e = null;
            if (d.length > 0) {
                c = d[0].firstChild.nodeValue;
                g = c.split(" ");
                if (g.length == 2) {
                    a = g[0].split(",");
                    e = g[1].split(",")
                }
            }
            if (a !== null && e !== null) {
                return new SuperMap.Bounds(parseFloat(a[0]),parseFloat(a[1]),parseFloat(e[0]),parseFloat(e[1]))
            }
        }
    },
    parseAttributes: function(f) {
        var g = {};
        var a = f.firstChild;
        var e, h, d, l, k, c, j;
        while (a) {
            if (a.nodeType == 1) {
                e = a.childNodes;
                for (h = 0; h < e.length; ++h) {
                    d = e[h];
                    if (d.nodeType == 1) {
                        l = d.childNodes;
                        if (l.length == 1) {
                            k = l[0];
                            if (k.nodeType == 3 || k.nodeType == 4) {
                                c = (d.prefix) ? d.nodeName.split(":")[1] : d.nodeName;
                                j = k.nodeValue.replace(this.regExes.trimSpace, "");
                                g[c] = j
                            }
                        } else {
                            g[d.nodeName.split(":").pop()] = null
                        }
                    }
                }
                break
            }
            a = a.nextSibling
        }
        return g
    },
    write: function(d) {
        if (!(SuperMap.Util.isArray(d))) {
            d = [d]
        }
        var c = this.createElementNS("http://www.opengis.net/wfs", "wfs:" + this.collectionName);
        for (var a = 0; a < d.length; a++) {
            c.appendChild(this.createFeatureXML(d[a]))
        }
        return SuperMap.Format.XML.prototype.write.apply(this, [c])
    },
    createFeatureXML: function(k) {
        var i = k.geometry;
        var f = this.buildGeometryNode(i);
        var j = this.createElementNS(this.featureNS, this.featurePrefix + ":" + this.geometryName);
        j.appendChild(f);
        var a = this.createElementNS(this.gmlns, "gml:" + this.featureName);
        var l = this.createElementNS(this.featureNS, this.featurePrefix + ":" + this.layerName);
        var d = k.fid || k.id;
        l.setAttribute("fid", d);
        l.appendChild(j);
        for (var h in k.attributes) {
            var g = this.createTextNode(k.attributes[h]);
            var e = h.substring(h.lastIndexOf(":") + 1);
            var c = this.createElementNS(this.featureNS, this.featurePrefix + ":" + e);
            c.appendChild(g);
            l.appendChild(c)
        }
        a.appendChild(l);
        return a
    },
    buildGeometryNode: function(e) {
        if (this.externalProjection && this.internalProjection) {
            e = e.clone();
            e.transform(this.internalProjection, this.externalProjection)
        }
        var d = e.CLASS_NAME;
        var c = d.substring(d.lastIndexOf(".") + 1);
        var a = this.buildGeometry[c.toLowerCase()];
        return a.apply(this, [e])
    },
    buildGeometry: {
        point: function(c) {
            var a = this.createElementNS(this.gmlns, "gml:Point");
            a.appendChild(this.buildCoordinatesNode(c));
            return a
        },
        multipoint: function(g) {
            var e = this.createElementNS(this.gmlns, "gml:MultiPoint");
            var d = g.components;
            var c, f;
            for (var a = 0; a < d.length; a++) {
                c = this.createElementNS(this.gmlns, "gml:pointMember");
                f = this.buildGeometry.point.apply(this, [d[a]]);
                c.appendChild(f);
                e.appendChild(c)
            }
            return e
        },
        linestring: function(c) {
            var a = this.createElementNS(this.gmlns, "gml:LineString");
            a.appendChild(this.buildCoordinatesNode(c));
            return a
        },
        multilinestring: function(g) {
            var e = this.createElementNS(this.gmlns, "gml:MultiLineString");
            var a = g.components;
            var d, f;
            for (var c = 0; c < a.length; ++c) {
                d = this.createElementNS(this.gmlns, "gml:lineStringMember");
                f = this.buildGeometry.linestring.apply(this, [a[c]]);
                d.appendChild(f);
                e.appendChild(d)
            }
            return e
        },
        linearring: function(c) {
            var a = this.createElementNS(this.gmlns, "gml:LinearRing");
            a.appendChild(this.buildCoordinatesNode(c));
            return a
        },
        polygon: function(h) {
            var e = this.createElementNS(this.gmlns, "gml:Polygon");
            var g = h.components;
            var d, f, c;
            for (var a = 0; a < g.length; ++a) {
                c = (a == 0) ? "outerBoundaryIs" : "innerBoundaryIs";
                d = this.createElementNS(this.gmlns, "gml:" + c);
                f = this.buildGeometry.linearring.apply(this, [g[a]]);
                d.appendChild(f);
                e.appendChild(d)
            }
            return e
        },
        multipolygon: function(g) {
            var e = this.createElementNS(this.gmlns, "gml:MultiPolygon");
            var a = g.components;
            var f, c;
            for (var d = 0; d < a.length; ++d) {
                f = this.createElementNS(this.gmlns, "gml:polygonMember");
                c = this.buildGeometry.polygon.apply(this, [a[d]]);
                f.appendChild(c);
                e.appendChild(f)
            }
            return e
        },
        bounds: function(c) {
            var a = this.createElementNS(this.gmlns, "gml:Box");
            a.appendChild(this.buildCoordinatesNode(c));
            return a
        }
    },
    buildCoordinatesNode: function(g) {
        var a = this.createElementNS(this.gmlns, "gml:coordinates");
        a.setAttribute("decimal", ".");
        a.setAttribute("cs", ",");
        a.setAttribute("ts", " ");
        var f = [];
        if (g instanceof SuperMap.Bounds) {
            f.push(g.left + "," + g.bottom);
            f.push(g.right + "," + g.top)
        } else {
            var d = (g.components) ? g.components : [g];
            for (var c = 0; c < d.length; c++) {
                f.push(d[c].x + "," + d[c].y)
            }
        }
        var e = this.createTextNode(f.join(" "));
        a.appendChild(e);
        return a
    },
    CLASS_NAME: "SuperMap.Format.GML"
});
SuperMap.Format.WFST = function(c) {
    c = SuperMap.Util.applyDefaults(c, SuperMap.Format.WFST.DEFAULTS);
    var a = SuperMap.Format.WFST["v" + c.version.replace(/\./g, "_")];
    if (!a) {
        throw "Unsupported WFST version: " + c.version
    }
    return new a(c)
}
;
SuperMap.Format.WFST.DEFAULTS = {
    version: "1.0.0"
};
SuperMap.Format.XML.VersionedOGC = SuperMap.Class(SuperMap.Format.XML, {
    defaultVersion: null,
    version: null,
    profile: null,
    errorProperty: null,
    name: null,
    stringifyOutput: false,
    parser: null,
    initialize: function(a) {
        SuperMap.Format.XML.prototype.initialize.apply(this, [a]);
        var c = this.CLASS_NAME;
        this.name = c.substring(c.lastIndexOf(".") + 1)
    },
    getVersion: function(c, d) {
        var a;
        if (c) {
            a = this.version;
            if (!a) {
                a = c.getAttribute("version");
                if (!a) {
                    a = this.defaultVersion
                }
            }
        } else {
            a = (d && d.version) || this.version || this.defaultVersion
        }
        return a
    },
    getParser: function(a) {
        a = a || this.defaultVersion;
        var c = this.profile ? "_" + this.profile : "";
        if (!this.parser || this.parser.VERSION != a) {
            var d = SuperMap.Format[this.name]["v" + a.replace(/\./g, "_") + c];
            if (!d) {
                throw "Can't find a " + this.name + " parser for version " + a + c
            }
            this.parser = new d(this.options)
        }
        return this.parser
    },
    write: function(e, d) {
        var c = this.getVersion(null, d);
        this.parser = this.getParser(c);
        var a = this.parser.write(e, d);
        if (this.stringifyOutput === false) {
            return a
        } else {
            return SuperMap.Format.XML.prototype.write.apply(this, [a])
        }
    },
    read: function(e, d) {
        if (typeof e == "string") {
            e = SuperMap.Format.XML.prototype.read.apply(this, [e])
        }
        var c = e.documentElement;
        var a = this.getVersion(c);
        this.parser = this.getParser(a);
        var g = this.parser.read(e, d);
        if (this.errorProperty !== null && g[this.errorProperty] === undefined) {
            var f = new SuperMap.Format.OGCExceptionReport();
            g.error = f.read(e)
        }
        g.version = a;
        return g
    },
    CLASS_NAME: "SuperMap.Format.XML.VersionedOGC"
});
SuperMap.Format.Filter = SuperMap.Class(SuperMap.Format.XML.VersionedOGC, {
    defaultVersion: "1.0.0",
    CLASS_NAME: "SuperMap.Format.Filter"
});
SuperMap.Format.CQL = (function() {
    var l = ["PROPERTY", "COMPARISON", "VALUE", "LOGICAL"]
      , f = {
        PROPERTY: /^[_a-zA-Z]\w*/,
        COMPARISON: /^(=|<>|<=|<|>=|>|LIKE)/i,
        COMMA: /^,/,
        LOGICAL: /^(AND|OR)/i,
        VALUE: /^('\w+'|\d+(\.\d*)?|\.\d+)/,
        LPAREN: /^\(/,
        RPAREN: /^\)/,
        SPATIAL: /^(BBOX|INTERSECTS|DWITHIN|WITHIN|CONTAINS)/i,
        NOT: /^NOT/i,
        BETWEEN: /^BETWEEN/i,
        GEOMETRY: function(s) {
            var q = /^(POINT|LINESTRING|POLYGON|MULTIPOINT|MULTILINESTRING|MULTIPOLYGON|GEOMETRYCOLLECTION)/.exec(s);
            if (q) {
                var p = s.length;
                var i = s.indexOf("(", q[0].length);
                if (i > -1) {
                    var r = 1;
                    while (i < p && r > 0) {
                        i++;
                        switch (s.charAt(i)) {
                        case "(":
                            r++;
                            break;
                        case ")":
                            r--;
                            break;
                        default:
                        }
                    }
                }
                return [s.substr(0, i + 1)]
            }
        },
        END: /^$/
    }
      , k = {
        LPAREN: ["GEOMETRY", "SPATIAL", "PROPERTY", "VALUE", "LPAREN"],
        RPAREN: ["NOT", "LOGICAL", "END", "RPAREN"],
        PROPERTY: ["COMPARISON", "BETWEEN", "COMMA"],
        BETWEEN: ["VALUE"],
        COMPARISON: ["VALUE"],
        COMMA: ["GEOMETRY", "VALUE", "PROPERTY"],
        VALUE: ["LOGICAL", "COMMA", "RPAREN", "END"],
        SPATIAL: ["LPAREN"],
        LOGICAL: ["NOT", "VALUE", "SPATIAL", "PROPERTY", "LPAREN"],
        NOT: ["PROPERTY", "LPAREN"],
        GEOMETRY: ["COMMA", "RPAREN"]
    }
      , h = {
        "=": SuperMap.Filter.Comparison.EQUAL_TO,
        "<>": SuperMap.Filter.Comparison.NOT_EQUAL_TO,
        "<": SuperMap.Filter.Comparison.LESS_THAN,
        "<=": SuperMap.Filter.Comparison.LESS_THAN_OR_EQUAL_TO,
        ">": SuperMap.Filter.Comparison.GREATER_THAN,
        ">=": SuperMap.Filter.Comparison.GREATER_THAN_OR_EQUAL_TO,
        LIKE: SuperMap.Filter.Comparison.LIKE,
        BETWEEN: SuperMap.Filter.Comparison.BETWEEN
    }
      , e = {}
      , o = {
        AND: SuperMap.Filter.Logical.AND,
        OR: SuperMap.Filter.Logical.OR
    }
      , c = {}
      , a = {
        RPAREN: 3,
        LOGICAL: 2,
        COMPARISON: 1
    };
    var j;
    for (j in h) {
        if (h.hasOwnProperty(j)) {
            e[h[j]] = j
        }
    }
    for (j in o) {
        if (o.hasOwnProperty(j)) {
            c[o[j]] = j
        }
    }
    function d(p, i) {
        if (i instanceof RegExp) {
            return i.exec(p)
        } else {
            return i(p)
        }
    }
    function g(y, w) {
        var r, q, v = w.length;
        for (r = 0; r < v; r++) {
            q = w[r];
            var u = f[q];
            var s = d(y, u);
            if (s) {
                var t = s[0];
                var x = y.substr(t.length).replace(/^\s*/, "");
                return {
                    type: q,
                    text: t,
                    remainder: x
                }
            }
        }
        var p = "ERROR: In parsing: [" + y + "], expected one of: ";
        for (r = 0; r < v; r++) {
            q = w[r];
            p += "\n    " + q + ": " + f[q]
        }
        throw new Error(p)
    }
    function n(r) {
        var p = [];
        var i, q = ["NOT", "GEOMETRY", "SPATIAL", "PROPERTY", "LPAREN"];
        do {
            i = g(r, q);
            r = i.remainder;
            q = k[i.type];
            if (i.type != "END" && !q) {
                throw new Error("No follows list for " + i.type)
            }
            p.push(i)
        } while (i.type != "END");return p
    }
    function m(v) {
        var u = []
          , w = [];
        while (v.length) {
            var x = v.shift();
            switch (x.type) {
            case "PROPERTY":
            case "GEOMETRY":
            case "VALUE":
                w.push(x);
                break;
            case "COMPARISON":
            case "BETWEEN":
            case "LOGICAL":
                var q = a[x.type];
                while (u.length > 0 && (a[u[u.length - 1].type] <= q)) {
                    w.push(u.pop())
                }
                u.push(x);
                break;
            case "SPATIAL":
            case "NOT":
            case "LPAREN":
                u.push(x);
                break;
            case "RPAREN":
                while (u.length > 0 && (u[u.length - 1].type != "LPAREN")) {
                    w.push(u.pop())
                }
                u.pop();
                if (u.length > 0 && u[u.length - 1].type == "SPATIAL") {
                    w.push(u.pop())
                }
            case "COMMA":
            case "END":
                break;
            default:
                throw new Error("Unknown token type " + x.type)
            }
        }
        while (u.length > 0) {
            w.push(u.pop())
        }
        function r() {
            var K = w.pop();
            switch (K.type) {
            case "LOGICAL":
                var C = r()
                  , z = r();
                return new SuperMap.Filter.Logical({
                    filters: [z, C],
                    type: o[K.text.toUpperCase()]
                });
            case "NOT":
                var B = r();
                return new SuperMap.Filter.Logical({
                    filters: [B],
                    type: SuperMap.Filter.Logical.NOT
                });
            case "BETWEEN":
                var A, F, I;
                w.pop();
                F = r();
                A = r();
                I = r();
                return new SuperMap.Filter.Comparison({
                    property: I,
                    lowerBoundary: A,
                    upperBoundary: F,
                    type: SuperMap.Filter.Comparison.BETWEEN
                });
            case "COMPARISON":
                var G = r()
                  , I = r();
                return new SuperMap.Filter.Comparison({
                    property: I,
                    value: G,
                    type: h[K.text.toUpperCase()]
                });
            case "VALUE":
                if ((/^'.*'$/).test(K.text)) {
                    return K.text.substr(1, K.text.length - 2)
                } else {
                    return Number(K.text)
                }
            case "SPATIAL":
                switch (K.text.toUpperCase()) {
                case "BBOX":
                    var D = r()
                      , E = r()
                      , H = r()
                      , J = r()
                      , p = r();
                    return new SuperMap.Filter.Spatial({
                        type: SuperMap.Filter.Spatial.BBOX,
                        property: p,
                        value: SuperMap.Bounds.fromArray([J, H, E, D])
                    });
                case "INTERSECTS":
                    var G = r()
                      , I = r();
                    return new SuperMap.Filter.Spatial({
                        type: SuperMap.Filter.Spatial.INTERSECTS,
                        property: I,
                        value: G
                    });
                case "WITHIN":
                    var G = r()
                      , I = r();
                    return new SuperMap.Filter.Spatial({
                        type: SuperMap.Filter.Spatial.WITHIN,
                        property: I,
                        value: G
                    });
                case "CONTAINS":
                    var G = r()
                      , I = r();
                    return new SuperMap.Filter.Spatial({
                        type: SuperMap.Filter.Spatial.CONTAINS,
                        property: I,
                        value: G
                    });
                case "DWITHIN":
                    var i = r()
                      , G = r()
                      , I = r();
                    return new SuperMap.Filter.Spatial({
                        type: SuperMap.Filter.Spatial.DWITHIN,
                        value: G,
                        property: I,
                        distance: Number(i)
                    })
                }
            case "GEOMETRY":
                return SuperMap.Geometry.fromWKT(K.text);
            default:
                return K.text
            }
        }
        var y = r();
        if (w.length > 0) {
            var s = "Remaining tokens after building AST: \n";
            for (var t = w.length - 1; t >= 0; t--) {
                s += w[t].type + ": " + w[t].text + "\n"
            }
            throw new Error(s)
        }
        return y
    }
    return SuperMap.Class(SuperMap.Format, {
        read: function(p) {
            var i = m(n(p));
            if (this.keepData) {
                this.data = i
            }
            return i
        },
        write: function(r) {
            if (r instanceof SuperMap.Geometry) {
                return r.toString()
            }
            switch (r.CLASS_NAME) {
            case "SuperMap.Filter.Spatial":
                switch (r.type) {
                case SuperMap.Filter.Spatial.BBOX:
                    return "BBOX(" + r.property + "," + r.value.toBBOX() + ")";
                case SuperMap.Filter.Spatial.DWITHIN:
                    return "DWITHIN(" + r.property + ", " + this.write(r.value) + ", " + r.distance + ")";
                case SuperMap.Filter.Spatial.WITHIN:
                    return "WITHIN(" + r.property + ", " + this.write(r.value) + ")";
                case SuperMap.Filter.Spatial.INTERSECTS:
                    return "INTERSECTS(" + r.property + ", " + this.write(r.value) + ")";
                case SuperMap.Filter.Spatial.CONTAINS:
                    return "CONTAINS(" + r.property + ", " + this.write(r.value) + ")";
                default:
                    throw new Error("Unknown spatial filter type: " + r.type)
                }
            case "SuperMap.Filter.Logical":
                if (r.type == SuperMap.Filter.Logical.NOT) {
                    return "NOT (" + this.write(r.filters[0]) + ")"
                } else {
                    var q = "(";
                    var s = true;
                    for (var p = 0; p < r.filters.length; p++) {
                        if (s) {
                            s = false
                        } else {
                            q += ") " + c[r.type] + " ("
                        }
                        q += this.write(r.filters[p])
                    }
                    return q + ")"
                }
            case "SuperMap.Filter.Comparison":
                if (r.type == SuperMap.Filter.Comparison.BETWEEN) {
                    return r.property + " BETWEEN " + this.write(r.lowerBoundary) + " AND " + this.write(r.upperBoundary)
                } else {
                    return r.property + " " + e[r.type] + " " + this.write(r.value)
                }
            case undefined:
                if (typeof r === "string") {
                    return "'" + r + "'"
                } else {
                    if (typeof r === "number") {
                        return String(r)
                    }
                }
            default:
                throw new Error("Can't encode: " + r.CLASS_NAME + " " + r)
            }
        },
        CLASS_NAME: "SuperMap.Format.CQL"
    })
})();
if (!SuperMap.Format.GML) {
    SuperMap.Format.GML = {}
}
SuperMap.Format.GML.Base = SuperMap.Class(SuperMap.Format.XML, {
    namespaces: {
        gml: "http://www.opengis.net/gml",
        xlink: "http://www.w3.org/1999/xlink",
        xsi: "http://www.w3.org/2001/XMLSchema-instance",
        wfs: "http://www.opengis.net/wfs"
    },
    defaultPrefix: "gml",
    schemaLocation: null,
    featureType: null,
    featureNS: null,
    geometryName: "geometry",
    extractAttributes: true,
    srsName: null,
    xy: true,
    geometryTypes: null,
    singleFeatureType: null,
    regExes: {
        trimSpace: (/^\s*|\s*$/g),
        removeSpace: (/\s*/g),
        splitSpace: (/\s+/),
        trimComma: (/\s*,\s*/g),
        featureMember: (/^(.*:)?featureMembers?$/)
    },
    initialize: function(a) {
        SuperMap.Format.XML.prototype.initialize.apply(this, [a]);
        this.setGeometryTypes();
        if (a && a.featureNS) {
            this.setNamespace("feature", a.featureNS)
        }
        this.singleFeatureType = !a || (typeof a.featureType === "string")
    },
    read: function(f) {
        if (typeof f == "string") {
            f = SuperMap.Format.XML.prototype.read.apply(this, [f])
        }
        if (f && f.nodeType == 9) {
            f = f.documentElement
        }
        var d = [];
        this.readNode(f, {
            features: d
        }, true);
        if (d.length == 0) {
            var e = this.getElementsByTagNameNS(f, this.namespaces.gml, "featureMember");
            if (e.length) {
                for (var c = 0, a = e.length; c < a; ++c) {
                    this.readNode(e[c], {
                        features: d
                    }, true)
                }
            } else {
                var e = this.getElementsByTagNameNS(f, this.namespaces.gml, "featureMembers");
                if (e.length) {
                    this.readNode(e[0], {
                        features: d
                    }, true)
                }
            }
        }
        return d
    },
    readNode: function(a, c, d) {
        if (d === true && this.autoConfig === true) {
            this.featureType = null;
            delete this.namespaceAlias[this.featureNS];
            delete this.namespaces.feature;
            this.featureNS = null
        }
        if (!this.featureNS && (!(a.prefix in this.namespaces) && a.parentNode.namespaceURI == this.namespaces.gml && this.regExes.featureMember.test(a.parentNode.nodeName))) {
            this.featureType = a.nodeName.split(":").pop();
            this.setNamespace("feature", a.namespaceURI);
            this.featureNS = a.namespaceURI;
            this.autoConfig = true
        }
        return SuperMap.Format.XML.prototype.readNode.apply(this, [a, c])
    },
    readers: {
        gml: {
            featureMember: function(a, c) {
                this.readChildNodes(a, c)
            },
            featureMembers: function(a, c) {
                this.readChildNodes(a, c)
            },
            name: function(a, c) {
                c.name = this.getChildValue(a)
            },
            boundedBy: function(c, d) {
                var a = {};
                this.readChildNodes(c, a);
                if (a.components && a.components.length > 0) {
                    d.bounds = a.components[0]
                }
            },
            Point: function(c, a) {
                var d = {
                    points: []
                };
                this.readChildNodes(c, d);
                if (!a.components) {
                    a.components = []
                }
                a.components.push(d.points[0])
            },
            coordinates: function(f, h) {
                var j = this.getChildValue(f).replace(this.regExes.trimSpace, "");
                j = j.replace(this.regExes.trimComma, ",");
                var a = j.split(this.regExes.splitSpace);
                var g;
                var e = a.length;
                var d = new Array(e);
                for (var c = 0; c < e; ++c) {
                    g = a[c].split(",");
                    if (this.xy) {
                        d[c] = new SuperMap.Geometry.Point(g[0],g[1],g[2])
                    } else {
                        d[c] = new SuperMap.Geometry.Point(g[1],g[0],g[2])
                    }
                }
                h.points = d
            },
            coord: function(a, c) {
                var d = {};
                this.readChildNodes(a, d);
                if (!c.points) {
                    c.points = []
                }
                c.points.push(new SuperMap.Geometry.Point(d.x,d.y,d.z))
            },
            X: function(a, c) {
                c.x = this.getChildValue(a)
            },
            Y: function(a, c) {
                c.y = this.getChildValue(a)
            },
            Z: function(a, c) {
                c.z = this.getChildValue(a)
            },
            MultiPoint: function(c, a) {
                var d = {
                    components: []
                };
                this.readChildNodes(c, d);
                a.components = [new SuperMap.Geometry.MultiPoint(d.components)]
            },
            pointMember: function(a, c) {
                this.readChildNodes(a, c)
            },
            LineString: function(c, a) {
                var d = {};
                this.readChildNodes(c, d);
                if (!a.components) {
                    a.components = []
                }
                a.components.push(new SuperMap.Geometry.LineString(d.points))
            },
            MultiLineString: function(c, a) {
                var d = {
                    components: []
                };
                this.readChildNodes(c, d);
                a.components = [new SuperMap.Geometry.MultiLineString(d.components)]
            },
            lineStringMember: function(a, c) {
                this.readChildNodes(a, c)
            },
            Polygon: function(c, a) {
                var d = {
                    outer: null,
                    inner: []
                };
                this.readChildNodes(c, d);
                d.inner.unshift(d.outer);
                if (!a.components) {
                    a.components = []
                }
                a.components.push(new SuperMap.Geometry.Polygon(d.inner))
            },
            LinearRing: function(c, d) {
                var a = {};
                this.readChildNodes(c, a);
                d.components = [new SuperMap.Geometry.LinearRing(a.points)]
            },
            MultiPolygon: function(c, a) {
                var d = {
                    components: []
                };
                this.readChildNodes(c, d);
                a.components = [new SuperMap.Geometry.MultiPolygon(d.components)]
            },
            polygonMember: function(a, c) {
                this.readChildNodes(a, c)
            },
            GeometryCollection: function(c, a) {
                var d = {
                    components: []
                };
                this.readChildNodes(c, d);
                a.components = [new SuperMap.Geometry.Collection(d.components)]
            },
            geometryMember: function(a, c) {
                this.readChildNodes(a, c)
            }
        },
        feature: {
            "*": function(d, e) {
                var a;
                var c = d.localName || d.nodeName.split(":").pop();
                if (e.features) {
                    if (!this.singleFeatureType && (SuperMap.Util.indexOf(this.featureType, c) !== -1)) {
                        a = "_typeName"
                    } else {
                        if (c === this.featureType) {
                            a = "_typeName"
                        }
                    }
                } else {
                    if (d.childNodes.length == 0 || (d.childNodes.length == 1 && d.firstChild.nodeType == 3)) {
                        if (this.extractAttributes) {
                            a = "_attribute"
                        }
                    } else {
                        a = "_geometry"
                    }
                }
                if (a) {
                    this.readers.feature[a].apply(this, [d, e])
                }
            },
            _typeName: function(d, e) {
                var a = {
                    components: [],
                    attributes: {}
                };
                this.readChildNodes(d, a);
                if (a.name) {
                    a.attributes.name = a.name
                }
                var c = new SuperMap.Feature.Vector(a.components[0],a.attributes);
                if (!this.singleFeatureType) {
                    c.type = d.nodeName.split(":").pop();
                    c.namespace = d.namespaceURI
                }
                var f = d.getAttribute("fid") || this.getAttributeNS(d, this.namespaces.gml, "id");
                if (f) {
                    c.fid = f
                }
                if (this.internalProjection && this.externalProjection && c.geometry) {
                    c.geometry.transform(this.externalProjection, this.internalProjection)
                }
                if (a.bounds) {
                    c.bounds = a.bounds
                }
                e.features.push(c)
            },
            _geometry: function(a, c) {
                if (!this.geometryName) {
                    this.geometryName = a.nodeName.split(":").pop()
                }
                this.readChildNodes(a, c)
            },
            _attribute: function(c, e) {
                var a = c.localName || c.nodeName.split(":").pop();
                var d = this.getChildValue(c);
                e.attributes[a] = d
            }
        },
        wfs: {
            FeatureCollection: function(a, c) {
                this.readChildNodes(a, c)
            }
        }
    },
    write: function(d) {
        var c;
        if (SuperMap.Util.isArray(d)) {
            c = "featureMembers"
        } else {
            c = "featureMember"
        }
        var a = this.writeNode("gml:" + c, d);
        this.setAttributeNS(a, this.namespaces.xsi, "xsi:schemaLocation", this.schemaLocation);
        return SuperMap.Format.XML.prototype.write.apply(this, [a])
    },
    writers: {
        gml: {
            featureMember: function(a) {
                var c = this.createElementNSPlus("gml:featureMember");
                this.writeNode("feature:_typeName", a, c);
                return c
            },
            MultiPoint: function(f) {
                var e = this.createElementNSPlus("gml:MultiPoint");
                var d = f.components || [f];
                for (var a = 0, c = d.length; a < c; ++a) {
                    this.writeNode("pointMember", d[a], e)
                }
                return e
            },
            pointMember: function(c) {
                var a = this.createElementNSPlus("gml:pointMember");
                this.writeNode("Point", c, a);
                return a
            },
            MultiLineString: function(f) {
                var e = this.createElementNSPlus("gml:MultiLineString");
                var d = f.components || [f];
                for (var a = 0, c = d.length; a < c; ++a) {
                    this.writeNode("lineStringMember", d[a], e)
                }
                return e
            },
            lineStringMember: function(c) {
                var a = this.createElementNSPlus("gml:lineStringMember");
                this.writeNode("LineString", c, a);
                return a
            },
            MultiPolygon: function(f) {
                var e = this.createElementNSPlus("gml:MultiPolygon");
                var d = f.components || [f];
                for (var a = 0, c = d.length; a < c; ++a) {
                    this.writeNode("polygonMember", d[a], e)
                }
                return e
            },
            polygonMember: function(c) {
                var a = this.createElementNSPlus("gml:polygonMember");
                this.writeNode("Polygon", c, a);
                return a
            },
            GeometryCollection: function(e) {
                var d = this.createElementNSPlus("gml:GeometryCollection");
                for (var c = 0, a = e.components.length; c < a; ++c) {
                    this.writeNode("geometryMember", e.components[c], d)
                }
                return d
            },
            geometryMember: function(c) {
                var a = this.createElementNSPlus("gml:geometryMember");
                var d = this.writeNode("feature:_geometry", c);
                a.appendChild(d.firstChild);
                return a
            }
        },
        feature: {
            _typeName: function(c) {
                var d = this.createElementNSPlus("feature:" + this.featureType, {
                    attributes: {
                        fid: c.fid
                    }
                });
                if (c.geometry) {
                    this.writeNode("feature:_geometry", c.geometry, d)
                }
                for (var a in c.attributes) {
                    var e = c.attributes[a];
                    if (e != null) {
                        this.writeNode("feature:_attribute", {
                            name: a,
                            value: e
                        }, d)
                    }
                }
                return d
            },
            _geometry: function(d) {
                if (this.externalProjection && this.internalProjection) {
                    d = d.clone().transform(this.internalProjection, this.externalProjection)
                }
                var c = this.createElementNSPlus("feature:" + this.geometryName);
                var a = this.geometryTypes[d.CLASS_NAME];
                var e = this.writeNode("gml:" + a, d, c);
                if (this.srsName) {
                    e.setAttribute("srsName", this.srsName)
                }
                return c
            },
            _attribute: function(a) {
                return this.createElementNSPlus("feature:" + a.name, {
                    value: a.value
                })
            }
        },
        wfs: {
            FeatureCollection: function(d) {
                var e = this.createElementNSPlus("wfs:FeatureCollection");
                for (var c = 0, a = d.length; c < a; ++c) {
                    this.writeNode("gml:featureMember", d[c], e)
                }
                return e
            }
        }
    },
    setGeometryTypes: function() {
        this.geometryTypes = {
            "SuperMap.Geometry.Point": "Point",
            "SuperMap.Geometry.MultiPoint": "MultiPoint",
            "SuperMap.Geometry.LineString": "LineString",
            "SuperMap.Geometry.MultiLineString": "MultiLineString",
            "SuperMap.Geometry.Polygon": "Polygon",
            "SuperMap.Geometry.MultiPolygon": "MultiPolygon",
            "SuperMap.Geometry.Collection": "GeometryCollection"
        }
    },
    CLASS_NAME: "SuperMap.Format.GML.Base"
});
SuperMap.Format.Filter.v1 = SuperMap.Class(SuperMap.Format.XML, {
    namespaces: {
        ogc: "http://www.opengis.net/ogc",
        gml: "http://www.opengis.net/gml",
        xlink: "http://www.w3.org/1999/xlink",
        xsi: "http://www.w3.org/2001/XMLSchema-instance"
    },
    defaultPrefix: "ogc",
    schemaLocation: null,
    initialize: function(a) {
        SuperMap.Format.XML.prototype.initialize.apply(this, [a])
    },
    read: function(a) {
        var c = {};
        this.readers.ogc.Filter.apply(this, [a, c]);
        return c.filter
    },
    readers: {
        ogc: {
            _expression: function(a) {
                var d, c = "";
                for (var e = a.firstChild; e; e = e.nextSibling) {
                    switch (e.nodeType) {
                    case 1:
                        d = this.readNode(e);
                        if (d.property) {
                            c += "${" + d.property + "}"
                        } else {
                            if (d.value !== undefined) {
                                c += d.value
                            }
                        }
                        break;
                    case 3:
                    case 4:
                        c += e.nodeValue
                    }
                }
                return c
            },
            Filter: function(c, a) {
                var d = {
                    fids: [],
                    filters: []
                };
                this.readChildNodes(c, d);
                if (d.fids.length > 0) {
                    a.filter = new SuperMap.Filter.FeatureId({
                        fids: d.fids
                    })
                } else {
                    if (d.filters.length > 0) {
                        a.filter = d.filters[0]
                    }
                }
            },
            FeatureId: function(a, c) {
                var d = a.getAttribute("fid");
                if (d) {
                    c.fids.push(d)
                }
            },
            And: function(c, d) {
                var a = new SuperMap.Filter.Logical({
                    type: SuperMap.Filter.Logical.AND
                });
                this.readChildNodes(c, a);
                d.filters.push(a)
            },
            Or: function(c, d) {
                var a = new SuperMap.Filter.Logical({
                    type: SuperMap.Filter.Logical.OR
                });
                this.readChildNodes(c, a);
                d.filters.push(a)
            },
            Not: function(c, d) {
                var a = new SuperMap.Filter.Logical({
                    type: SuperMap.Filter.Logical.NOT
                });
                this.readChildNodes(c, a);
                d.filters.push(a)
            },
            PropertyIsLessThan: function(c, d) {
                var a = new SuperMap.Filter.Comparison({
                    type: SuperMap.Filter.Comparison.LESS_THAN
                });
                this.readChildNodes(c, a);
                d.filters.push(a)
            },
            PropertyIsGreaterThan: function(c, d) {
                var a = new SuperMap.Filter.Comparison({
                    type: SuperMap.Filter.Comparison.GREATER_THAN
                });
                this.readChildNodes(c, a);
                d.filters.push(a)
            },
            PropertyIsLessThanOrEqualTo: function(c, d) {
                var a = new SuperMap.Filter.Comparison({
                    type: SuperMap.Filter.Comparison.LESS_THAN_OR_EQUAL_TO
                });
                this.readChildNodes(c, a);
                d.filters.push(a)
            },
            PropertyIsGreaterThanOrEqualTo: function(c, d) {
                var a = new SuperMap.Filter.Comparison({
                    type: SuperMap.Filter.Comparison.GREATER_THAN_OR_EQUAL_TO
                });
                this.readChildNodes(c, a);
                d.filters.push(a)
            },
            PropertyIsBetween: function(c, d) {
                var a = new SuperMap.Filter.Comparison({
                    type: SuperMap.Filter.Comparison.BETWEEN
                });
                this.readChildNodes(c, a);
                d.filters.push(a)
            },
            Literal: function(a, c) {
                c.value = SuperMap.String.numericIf(this.getChildValue(a))
            },
            PropertyName: function(c, a) {
                a.property = this.getChildValue(c)
            },
            LowerBoundary: function(c, a) {
                a.lowerBoundary = SuperMap.String.numericIf(this.readers.ogc._expression.call(this, c))
            },
            UpperBoundary: function(c, a) {
                a.upperBoundary = SuperMap.String.numericIf(this.readers.ogc._expression.call(this, c))
            },
            Intersects: function(a, c) {
                this.readSpatial(a, c, SuperMap.Filter.Spatial.INTERSECTS)
            },
            Within: function(a, c) {
                this.readSpatial(a, c, SuperMap.Filter.Spatial.WITHIN)
            },
            Contains: function(a, c) {
                this.readSpatial(a, c, SuperMap.Filter.Spatial.CONTAINS)
            },
            DWithin: function(a, c) {
                this.readSpatial(a, c, SuperMap.Filter.Spatial.DWITHIN)
            },
            Distance: function(a, c) {
                c.distance = parseInt(this.getChildValue(a));
                c.distanceUnits = a.getAttribute("units")
            },
            Function: function(a, c) {
                return
            }
        }
    },
    readSpatial: function(d, e, c) {
        var a = new SuperMap.Filter.Spatial({
            type: c
        });
        this.readChildNodes(d, a);
        a.value = a.components[0];
        delete a.components;
        e.filters.push(a)
    },
    writeOgcExpression: function(c, a) {
        this.writeNode("Literal", c, a);
        return a
    },
    write: function(a) {
        return this.writers.ogc.Filter.apply(this, [a])
    },
    writeFeatureIdNodes: function(d, e) {
        for (var a = 0, c = d.fids.length; a < c; ++a) {
            this.writeNode("FeatureId", d.fids[a], e)
        }
    },
    writers: {
        ogc: {
            Filter: function(a) {
                var c = this.createElementNSPlus("ogc:Filter");
                if (a.type === "FID") {
                    SuperMap.Format.Filter.v1.prototype.writeFeatureIdNodes.call(this, a, c)
                } else {
                    this.writeNode(this.getFilterType(a), a, c)
                }
                return c
            },
            FeatureId: function(a) {
                return this.createElementNSPlus("ogc:FeatureId", {
                    attributes: {
                        fid: a
                    }
                })
            },
            And: function(e) {
                var f = this.createElementNSPlus("ogc:And");
                var d;
                for (var a = 0, c = e.filters.length; a < c; ++a) {
                    d = e.filters[a];
                    if (d.type === "FID") {
                        SuperMap.Format.Filter.v1.prototype.writeFeatureIdNodes.call(this, d, f)
                    } else {
                        this.writeNode(this.getFilterType(d), d, f)
                    }
                }
                return f
            },
            Or: function(e) {
                var f = this.createElementNSPlus("ogc:Or");
                var d;
                for (var a = 0, c = e.filters.length; a < c; ++a) {
                    d = e.filters[a];
                    if (d.type === "FID") {
                        SuperMap.Format.Filter.v1.prototype.writeFeatureIdNodes.call(this, d, f)
                    } else {
                        this.writeNode(this.getFilterType(d), d, f)
                    }
                }
                return f
            },
            Not: function(c) {
                var d = this.createElementNSPlus("ogc:Not");
                var a = c.filters[0];
                if (a.type === "FID") {
                    SuperMap.Format.Filter.v1.prototype.writeFeatureIdNodes.call(this, a, d)
                } else {
                    this.writeNode(this.getFilterType(a), a, d)
                }
                return d
            },
            PropertyIsLessThan: function(a) {
                var c = this.createElementNSPlus("ogc:PropertyIsLessThan");
                this.writeNode("PropertyName", a, c);
                this.writeOgcExpression(a.value, c);
                return c
            },
            PropertyIsGreaterThan: function(a) {
                var c = this.createElementNSPlus("ogc:PropertyIsGreaterThan");
                this.writeNode("PropertyName", a, c);
                this.writeOgcExpression(a.value, c);
                return c
            },
            PropertyIsLessThanOrEqualTo: function(a) {
                var c = this.createElementNSPlus("ogc:PropertyIsLessThanOrEqualTo");
                this.writeNode("PropertyName", a, c);
                this.writeOgcExpression(a.value, c);
                return c
            },
            PropertyIsGreaterThanOrEqualTo: function(a) {
                var c = this.createElementNSPlus("ogc:PropertyIsGreaterThanOrEqualTo");
                this.writeNode("PropertyName", a, c);
                this.writeOgcExpression(a.value, c);
                return c
            },
            PropertyIsBetween: function(a) {
                var c = this.createElementNSPlus("ogc:PropertyIsBetween");
                this.writeNode("PropertyName", a, c);
                this.writeNode("LowerBoundary", a, c);
                this.writeNode("UpperBoundary", a, c);
                return c
            },
            PropertyName: function(a) {
                return this.createElementNSPlus("ogc:PropertyName", {
                    value: a.property
                })
            },
            Literal: function(a) {
                return this.createElementNSPlus("ogc:Literal", {
                    value: a
                })
            },
            LowerBoundary: function(a) {
                var c = this.createElementNSPlus("ogc:LowerBoundary");
                this.writeOgcExpression(a.lowerBoundary, c);
                return c
            },
            UpperBoundary: function(a) {
                var c = this.createElementNSPlus("ogc:UpperBoundary");
                this.writeNode("Literal", a.upperBoundary, c);
                return c
            },
            INTERSECTS: function(a) {
                return this.writeSpatial(a, "Intersects")
            },
            WITHIN: function(a) {
                return this.writeSpatial(a, "Within")
            },
            CONTAINS: function(a) {
                return this.writeSpatial(a, "Contains")
            },
            DWITHIN: function(a) {
                var c = this.writeSpatial(a, "DWithin");
                this.writeNode("Distance", a, c);
                return c
            },
            Distance: function(a) {
                return this.createElementNSPlus("ogc:Distance", {
                    attributes: {
                        units: a.distanceUnits
                    },
                    value: a.distance
                })
            },
            Function: function(d) {
                var e = this.createElementNSPlus("ogc:Function", {
                    attributes: {
                        name: d.name
                    }
                });
                var f = d.params;
                for (var c = 0, a = f.length; c < a; c++) {
                    this.writeOgcExpression(f[c], e)
                }
                return e
            }
        }
    },
    getFilterType: function(a) {
        var c = this.filterMap[a.type];
        if (!c) {
            throw "Filter writing not supported for rule type: " + a.type
        }
        return c
    },
    filterMap: {
        "&&": "And",
        "||": "Or",
        "!": "Not",
        "==": "PropertyIsEqualTo",
        "!=": "PropertyIsNotEqualTo",
        "<": "PropertyIsLessThan",
        ">": "PropertyIsGreaterThan",
        "<=": "PropertyIsLessThanOrEqualTo",
        ">=": "PropertyIsGreaterThanOrEqualTo",
        "..": "PropertyIsBetween",
        "~": "PropertyIsLike",
        BBOX: "BBOX",
        DWITHIN: "DWITHIN",
        WITHIN: "WITHIN",
        CONTAINS: "CONTAINS",
        INTERSECTS: "INTERSECTS",
        FID: "FeatureId"
    },
    CLASS_NAME: "SuperMap.Format.Filter.v1"
});
SuperMap.Format.WFST.v1 = SuperMap.Class(SuperMap.Format.XML, {
    namespaces: {
        xlink: "http://www.w3.org/1999/xlink",
        xsi: "http://www.w3.org/2001/XMLSchema-instance",
        wfs: "http://www.opengis.net/wfs",
        gml: "http://www.opengis.net/gml",
        ogc: "http://www.opengis.net/ogc",
        ows: "http://www.opengis.net/ows"
    },
    defaultPrefix: "wfs",
    version: null,
    schemaLocations: null,
    srsName: null,
    extractAttributes: true,
    xy: true,
    stateName: null,
    initialize: function(a) {
        this.stateName = {};
        this.stateName[SuperMap.State.INSERT] = "wfs:Insert";
        this.stateName[SuperMap.State.UPDATE] = "wfs:Update";
        this.stateName[SuperMap.State.DELETE] = "wfs:Delete";
        SuperMap.Format.XML.prototype.initialize.apply(this, [a])
    },
    getSrsName: function(d, c) {
        var a = c && c.srsName;
        if (!a) {
            if (d && d.layer) {
                a = d.layer.projection.getCode()
            } else {
                a = this.srsName
            }
        }
        return a
    },
    read: function(c, a) {
        a = a || {};
        SuperMap.Util.applyDefaults(a, {
            output: "features"
        });
        if (typeof c == "string") {
            c = SuperMap.Format.XML.prototype.read.apply(this, [c])
        }
        if (c && c.nodeType == 9) {
            c = c.documentElement
        }
        var d = {};
        if (c) {
            this.readNode(c, d, true)
        }
        if (d.features && a.output === "features") {
            d = d.features
        }
        return d
    },
    readers: {
        wfs: {
            FeatureCollection: function(a, c) {
                c.features = [];
                this.readChildNodes(a, c)
            }
        }
    },
    write: function(c, a) {
        var d = this.writeNode("wfs:Transaction", {
            features: c,
            options: a
        });
        var e = this.schemaLocationAttr();
        if (e) {
            this.setAttributeNS(d, this.namespaces.xsi, "xsi:schemaLocation", e)
        }
        return SuperMap.Format.XML.prototype.write.apply(this, [d])
    },
    writers: {
        wfs: {
            GetFeature: function(c) {
                var e = this.createElementNSPlus("wfs:GetFeature", {
                    attributes: {
                        service: "WFS",
                        version: this.version,
                        handle: c && c.handle,
                        outputFormat: c && c.outputFormat,
                        maxFeatures: c && c.maxFeatures,
                        "xsi:schemaLocation": this.schemaLocationAttr(c)
                    }
                });
                if (typeof this.featureType == "string") {
                    this.writeNode("Query", c, e)
                } else {
                    for (var d = 0, a = this.featureType.length; d < a; d++) {
                        c.featureType = this.featureType[d];
                        this.writeNode("Query", c, e)
                    }
                }
                return e
            },
            Transaction: function(j) {
                j = j || {};
                var d = j.options || {};
                var h = this.createElementNSPlus("wfs:Transaction", {
                    attributes: {
                        service: "WFS",
                        version: this.version,
                        handle: d.handle
                    }
                });
                var f, a;
                var g = j.features;
                if (g) {
                    if (d.multi === true) {
                        SuperMap.Util.extend(this.geometryTypes, {
                            "SuperMap.Geometry.Point": "MultiPoint",
                            "SuperMap.Geometry.LineString": (this.multiCurve === true) ? "MultiCurve" : "MultiLineString",
                            "SuperMap.Geometry.Polygon": (this.multiSurface === true) ? "MultiSurface" : "MultiPolygon"
                        })
                    }
                    var c, e;
                    for (f = 0,
                    a = g.length; f < a; ++f) {
                        e = g[f];
                        c = this.stateName[e.state];
                        if (c) {
                            this.writeNode(c, {
                                feature: e,
                                options: d
                            }, h)
                        }
                    }
                    if (d.multi === true) {
                        this.setGeometryTypes()
                    }
                }
                if (d.nativeElements) {
                    for (f = 0,
                    a = d.nativeElements.length; f < a; ++f) {
                        this.writeNode("wfs:Native", d.nativeElements[f], h)
                    }
                }
                return h
            },
            Native: function(c) {
                var a = this.createElementNSPlus("wfs:Native", {
                    attributes: {
                        vendorId: c.vendorId,
                        safeToIgnore: c.safeToIgnore
                    },
                    value: c.value
                });
                return a
            },
            Insert: function(e) {
                var c = e.feature;
                var a = e.options;
                var d = this.createElementNSPlus("wfs:Insert", {
                    attributes: {
                        handle: a && a.handle
                    }
                });
                this.srsName = this.getSrsName(c);
                this.writeNode("feature:_typeName", c, d);
                return d
            },
            Update: function(g) {
                var e = g.feature;
                var c = g.options;
                var f = this.createElementNSPlus("wfs:Update", {
                    attributes: {
                        handle: c && c.handle,
                        typeName: (this.featureNS ? this.featurePrefix + ":" : "") + this.featureType
                    }
                });
                if (this.featureNS) {
                    f.setAttribute("xmlns:" + this.featurePrefix, this.featureNS)
                }
                var a = e.modified;
                if (this.geometryName !== null && (!a || a.geometry !== undefined)) {
                    this.srsName = this.getSrsName(e);
                    this.writeNode("Property", {
                        name: this.geometryName,
                        value: e.geometry
                    }, f)
                }
                for (var d in e.attributes) {
                    if (e.attributes[d] !== undefined && (!a || !a.attributes || (a.attributes && a.attributes[d] !== undefined))) {
                        this.writeNode("Property", {
                            name: d,
                            value: e.attributes[d]
                        }, f)
                    }
                }
                this.writeNode("ogc:Filter", new SuperMap.Filter.FeatureId({
                    fids: [e.fid]
                }), f);
                return f
            },
            Property: function(c) {
                var a = this.createElementNSPlus("wfs:Property");
                this.writeNode("Name", c.name, a);
                if (c.value !== null) {
                    this.writeNode("Value", c.value, a)
                }
                return a
            },
            Name: function(a) {
                return this.createElementNSPlus("wfs:Name", {
                    value: a
                })
            },
            Value: function(d) {
                var c;
                if (d instanceof SuperMap.Geometry) {
                    c = this.createElementNSPlus("wfs:Value");
                    var a = this.writeNode("feature:_geometry", d).firstChild;
                    c.appendChild(a)
                } else {
                    c = this.createElementNSPlus("wfs:Value", {
                        value: d
                    })
                }
                return c
            },
            Delete: function(e) {
                var c = e.feature;
                var a = e.options;
                var d = this.createElementNSPlus("wfs:Delete", {
                    attributes: {
                        handle: a && a.handle,
                        typeName: (this.featureNS ? this.featurePrefix + ":" : "") + this.featureType
                    }
                });
                if (this.featureNS) {
                    d.setAttribute("xmlns:" + this.featurePrefix, this.featureNS)
                }
                this.writeNode("ogc:Filter", new SuperMap.Filter.FeatureId({
                    fids: [c.fid]
                }), d);
                return d
            }
        }
    },
    schemaLocationAttr: function(a) {
        a = SuperMap.Util.extend({
            featurePrefix: this.featurePrefix,
            schema: this.schema
        }, a);
        var g = SuperMap.Util.extend({}, this.schemaLocations);
        if (a.schema) {
            g[a.featurePrefix] = a.schema
        }
        var f = [];
        var d;
        for (var c in g) {
            d = this.namespaces[c];
            if (d) {
                f.push(d + " " + g[c])
            }
        }
        var e = f.join(" ") || undefined;
        return e
    },
    setFilterProperty: function(d) {
        if (d.filters) {
            for (var c = 0, a = d.filters.length; c < a; ++c) {
                SuperMap.Format.WFST.v1.prototype.setFilterProperty.call(this, d.filters[c])
            }
        } else {
            if (d instanceof SuperMap.Filter.Spatial && !d.property) {
                d.property = this.geometryName
            }
        }
    },
    CLASS_NAME: "SuperMap.Format.WFST.v1"
});
SuperMap.Format.GML.v2 = SuperMap.Class(SuperMap.Format.GML.Base, {
    schemaLocation: "http://www.opengis.net/gml http://schemas.opengis.net/gml/2.1.2/feature.xsd",
    initialize: function(a) {
        SuperMap.Format.GML.Base.prototype.initialize.apply(this, [a])
    },
    readers: {
        gml: SuperMap.Util.applyDefaults({
            outerBoundaryIs: function(c, a) {
                var d = {};
                this.readChildNodes(c, d);
                a.outer = d.components[0]
            },
            innerBoundaryIs: function(c, a) {
                var d = {};
                this.readChildNodes(c, d);
                a.inner.push(d.components[0])
            },
            Box: function(e, c) {
                var f = {};
                this.readChildNodes(e, f);
                if (!c.components) {
                    c.components = []
                }
                var d = f.points[0];
                var a = f.points[1];
                c.components.push(new SuperMap.Bounds(d.x,d.y,a.x,a.y))
            }
        }, SuperMap.Format.GML.Base.prototype.readers.gml),
        feature: SuperMap.Format.GML.Base.prototype.readers.feature,
        wfs: SuperMap.Format.GML.Base.prototype.readers.wfs
    },
    write: function(d) {
        var c;
        if (SuperMap.Util.isArray(d)) {
            c = "wfs:FeatureCollection"
        } else {
            c = "gml:featureMember"
        }
        var a = this.writeNode(c, d);
        this.setAttributeNS(a, this.namespaces.xsi, "xsi:schemaLocation", this.schemaLocation);
        return SuperMap.Format.XML.prototype.write.apply(this, [a])
    },
    writers: {
        gml: SuperMap.Util.applyDefaults({
            Point: function(c) {
                var a = this.createElementNSPlus("gml:Point");
                this.writeNode("coordinates", [c], a);
                return a
            },
            coordinates: function(e) {
                var d = e.length;
                var f = new Array(d);
                var a;
                for (var c = 0; c < d; ++c) {
                    a = e[c];
                    if (this.xy) {
                        f[c] = a.x + "," + a.y
                    } else {
                        f[c] = a.y + "," + a.x
                    }
                    if (a.z != undefined) {
                        f[c] += "," + a.z
                    }
                }
                return this.createElementNSPlus("gml:coordinates", {
                    attributes: {
                        decimal: ".",
                        cs: ",",
                        ts: " "
                    },
                    value: (d == 1) ? f[0] : f.join(" ")
                })
            },
            LineString: function(c) {
                var a = this.createElementNSPlus("gml:LineString");
                this.writeNode("coordinates", c.components, a);
                return a
            },
            Polygon: function(d) {
                var c = this.createElementNSPlus("gml:Polygon");
                this.writeNode("outerBoundaryIs", d.components[0], c);
                for (var a = 1; a < d.components.length; ++a) {
                    this.writeNode("innerBoundaryIs", d.components[a], c)
                }
                return c
            },
            outerBoundaryIs: function(a) {
                var c = this.createElementNSPlus("gml:outerBoundaryIs");
                this.writeNode("LinearRing", a, c);
                return c
            },
            innerBoundaryIs: function(a) {
                var c = this.createElementNSPlus("gml:innerBoundaryIs");
                this.writeNode("LinearRing", a, c);
                return c
            },
            LinearRing: function(a) {
                var c = this.createElementNSPlus("gml:LinearRing");
                this.writeNode("coordinates", a.components, c);
                return c
            },
            Box: function(c) {
                var a = this.createElementNSPlus("gml:Box");
                this.writeNode("coordinates", [{
                    x: c.left,
                    y: c.bottom
                }, {
                    x: c.right,
                    y: c.top
                }], a);
                if (this.srsName) {
                    a.setAttribute("srsName", this.srsName)
                }
                return a
            }
        }, SuperMap.Format.GML.Base.prototype.writers.gml),
        feature: SuperMap.Format.GML.Base.prototype.writers.feature,
        wfs: SuperMap.Format.GML.Base.prototype.writers.wfs
    },
    CLASS_NAME: "SuperMap.Format.GML.v2"
});
SuperMap.Format.Filter.v1_0_0 = SuperMap.Class(SuperMap.Format.GML.v2, SuperMap.Format.Filter.v1, {
    VERSION: "1.0.0",
    schemaLocation: "http://www.opengis.net/ogc/filter/1.0.0/filter.xsd",
    initialize: function(a) {
        SuperMap.Format.GML.v2.prototype.initialize.apply(this, [a])
    },
    readers: {
        ogc: SuperMap.Util.applyDefaults({
            PropertyIsEqualTo: function(c, d) {
                var a = new SuperMap.Filter.Comparison({
                    type: SuperMap.Filter.Comparison.EQUAL_TO
                });
                this.readChildNodes(c, a);
                d.filters.push(a)
            },
            PropertyIsNotEqualTo: function(c, d) {
                var a = new SuperMap.Filter.Comparison({
                    type: SuperMap.Filter.Comparison.NOT_EQUAL_TO
                });
                this.readChildNodes(c, a);
                d.filters.push(a)
            },
            PropertyIsLike: function(e, f) {
                var d = new SuperMap.Filter.Comparison({
                    type: SuperMap.Filter.Comparison.LIKE
                });
                this.readChildNodes(e, d);
                var g = e.getAttribute("wildCard");
                var c = e.getAttribute("singleChar");
                var a = e.getAttribute("escape");
                d.value2regex(g, c, a);
                f.filters.push(d)
            }
        }, SuperMap.Format.Filter.v1.prototype.readers.ogc),
        gml: SuperMap.Format.GML.v2.prototype.readers.gml,
        feature: SuperMap.Format.GML.v2.prototype.readers.feature
    },
    writers: {
        ogc: SuperMap.Util.applyDefaults({
            PropertyIsEqualTo: function(a) {
                var c = this.createElementNSPlus("ogc:PropertyIsEqualTo");
                this.writeNode("PropertyName", a, c);
                this.writeOgcExpression(a.value, c);
                return c
            },
            PropertyIsNotEqualTo: function(a) {
                var c = this.createElementNSPlus("ogc:PropertyIsNotEqualTo");
                this.writeNode("PropertyName", a, c);
                this.writeOgcExpression(a.value, c);
                return c
            },
            PropertyIsLike: function(a) {
                var c = this.createElementNSPlus("ogc:PropertyIsLike", {
                    attributes: {
                        wildCard: "*",
                        singleChar: ".",
                        escape: "!"
                    }
                });
                this.writeNode("PropertyName", a, c);
                this.writeNode("Literal", a.regex2value(), c);
                return c
            },
            BBOX: function(a) {
                var d = this.createElementNSPlus("ogc:BBOX");
                a.property && this.writeNode("PropertyName", a, d);
                var c = this.writeNode("gml:Box", a.value, d);
                if (a.projection) {
                    c.setAttribute("srsName", a.projection)
                }
                return d
            }
        }, SuperMap.Format.Filter.v1.prototype.writers.ogc),
        gml: SuperMap.Format.GML.v2.prototype.writers.gml,
        feature: SuperMap.Format.GML.v2.prototype.writers.feature
    },
    writeSpatial: function(c, a) {
        var d = this.createElementNSPlus("ogc:" + a);
        this.writeNode("PropertyName", c, d);
        var e;
        if (c.value instanceof SuperMap.Geometry) {
            e = this.writeNode("feature:_geometry", c.value).firstChild
        } else {
            e = this.writeNode("gml:Box", c.value)
        }
        if (c.projection) {
            e.setAttribute("srsName", c.projection)
        }
        d.appendChild(e);
        return d
    },
    CLASS_NAME: "SuperMap.Format.Filter.v1_0_0"
});
SuperMap.Format.WFST.v1_0_0 = SuperMap.Class(SuperMap.Format.Filter.v1_0_0, SuperMap.Format.WFST.v1, {
    version: "1.0.0",
    srsNameInQuery: false,
    schemaLocations: {
        wfs: "http://schemas.opengis.net/wfs/1.0.0/WFS-transaction.xsd"
    },
    initialize: function(a) {
        SuperMap.Format.Filter.v1_0_0.prototype.initialize.apply(this, [a]);
        SuperMap.Format.WFST.v1.prototype.initialize.apply(this, [a])
    },
    readNode: function(a, c, d) {
        return SuperMap.Format.GML.v2.prototype.readNode.apply(this, [a, c])
    },
    readers: {
        wfs: SuperMap.Util.applyDefaults({
            WFS_TransactionResponse: function(a, c) {
                c.insertIds = [];
                c.success = false;
                this.readChildNodes(a, c)
            },
            InsertResult: function(c, a) {
                var d = {
                    fids: []
                };
                this.readChildNodes(c, d);
                a.insertIds.push(d.fids[0])
            },
            TransactionResult: function(a, c) {
                this.readChildNodes(a, c)
            },
            Status: function(a, c) {
                this.readChildNodes(a, c)
            },
            SUCCESS: function(a, c) {
                c.success = true
            }
        }, SuperMap.Format.WFST.v1.prototype.readers.wfs),
        gml: SuperMap.Format.GML.v2.prototype.readers.gml,
        feature: SuperMap.Format.GML.v2.prototype.readers.feature,
        ogc: SuperMap.Format.Filter.v1_0_0.prototype.readers.ogc
    },
    writers: {
        wfs: SuperMap.Util.applyDefaults({
            Query: function(c) {
                c = SuperMap.Util.extend({
                    featureNS: this.featureNS,
                    featurePrefix: this.featurePrefix,
                    featureType: this.featureType,
                    srsName: this.srsName,
                    srsNameInQuery: this.srsNameInQuery
                }, c);
                var f = c.featurePrefix;
                var e = this.createElementNSPlus("wfs:Query", {
                    attributes: {
                        typeName: (f ? f + ":" : "") + c.featureType
                    }
                });
                if (c.srsNameInQuery && c.srsName) {
                    e.setAttribute("srsName", c.srsName)
                }
                if (c.featureNS) {
                    e.setAttribute("xmlns:" + f, c.featureNS)
                }
                if (c.propertyNames) {
                    for (var d = 0, a = c.propertyNames.length; d < a; d++) {
                        this.writeNode("ogc:PropertyName", {
                            property: c.propertyNames[d]
                        }, e)
                    }
                }
                if (c.filter) {
                    this.setFilterProperty(c.filter);
                    this.writeNode("ogc:Filter", c.filter, e)
                }
                return e
            }
        }, SuperMap.Format.WFST.v1.prototype.writers.wfs),
        gml: SuperMap.Format.GML.v2.prototype.writers.gml,
        feature: SuperMap.Format.GML.v2.prototype.writers.feature,
        ogc: SuperMap.Format.Filter.v1_0_0.prototype.writers.ogc
    },
    CLASS_NAME: "SuperMap.Format.WFST.v1_0_0"
});
SuperMap.Format.OGCExceptionReport = SuperMap.Class(SuperMap.Format.XML, {
    namespaces: {
        ogc: "http://www.opengis.net/ogc"
    },
    regExes: {
        trimSpace: (/^\s*|\s*$/g),
        removeSpace: (/\s*/g),
        splitSpace: (/\s+/),
        trimComma: (/\s*,\s*/g)
    },
    defaultPrefix: "ogc",
    read: function(d) {
        var a;
        if (typeof d == "string") {
            d = SuperMap.Format.XML.prototype.read.apply(this, [d])
        }
        var c = d.documentElement;
        var e = {
            exceptionReport: null
        };
        if (c) {
            this.readChildNodes(d, e);
            if (e.exceptionReport === null) {
                e = new SuperMap.Format.OWSCommon().read(d)
            }
        }
        return e
    },
    readers: {
        ogc: {
            ServiceExceptionReport: function(a, c) {
                c.exceptionReport = {
                    exceptions: []
                };
                this.readChildNodes(a, c.exceptionReport)
            },
            ServiceException: function(c, d) {
                var a = {
                    code: c.getAttribute("code"),
                    locator: c.getAttribute("locator"),
                    text: this.getChildValue(c)
                };
                d.exceptions.push(a)
            }
        }
    },
    CLASS_NAME: "SuperMap.Format.OGCExceptionReport"
});
SuperMap.Protocol = SuperMap.Class({
    format: null,
    options: null,
    autoDestroy: true,
    defaultFilter: null,
    initialize: function(a) {
        a = a || {};
        SuperMap.Util.extend(this, a);
        this.options = a
    },
    mergeWithDefaultFilter: function(c) {
        var a;
        if (c && this.defaultFilter) {
            a = new SuperMap.Filter.Logical({
                type: SuperMap.Filter.Logical.AND,
                filters: [this.defaultFilter, c]
            })
        } else {
            a = c || this.defaultFilter || undefined
        }
        return a
    },
    destroy: function() {
        this.options = null;
        this.format = null
    },
    read: function(a) {
        a = a || {};
        a.filter = this.mergeWithDefaultFilter(a.filter)
    },
    create: function() {},
    update: function() {},
    "delete": function() {},
    commit: function() {},
    abort: function(a) {},
    createCallback: function(d, a, c) {
        return SuperMap.Function.bind(function() {
            d.apply(this, [a, c])
        }, this)
    },
    CLASS_NAME: "SuperMap.Protocol"
});
SuperMap.Protocol.Response = SuperMap.Class({
    code: null,
    requestType: null,
    last: true,
    features: null,
    data: null,
    reqFeatures: null,
    priv: null,
    error: null,
    initialize: function(a) {
        SuperMap.Util.extend(this, a)
    },
    success: function() {
        return this.code > 0
    },
    CLASS_NAME: "SuperMap.Protocol.Response"
});
SuperMap.Protocol.Response.SUCCESS = 1;
SuperMap.Protocol.Response.FAILURE = 0;
SuperMap.Protocol.WFS = function(c) {
    c = SuperMap.Util.applyDefaults(c, SuperMap.Protocol.WFS.DEFAULTS);
    var a = SuperMap.Protocol.WFS["v" + c.version.replace(/\./g, "_")];
    if (!a) {
        throw "Unsupported WFS version: " + c.version
    }
    return new a(c)
}
;
SuperMap.Protocol.WFS.fromWMSLayer = function(e, d) {
    var a, f;
    var h = e.params.LAYERS;
    var g = (SuperMap.Util.isArray(h) ? h[0] : h).split(":");
    if (g.length > 1) {
        f = g[0]
    }
    a = g.pop();
    var c = {
        url: e.url,
        featureType: a,
        featurePrefix: f,
        srsName: e.projection && e.projection.getCode() || e.map && e.map.getProjectionObject().getCode(),
        version: "1.1.0"
    };
    return new SuperMap.Protocol.WFS(SuperMap.Util.applyDefaults(d, c))
}
;
SuperMap.Protocol.WFS.DEFAULTS = {
    version: "1.0.0"
};
SuperMap.Protocol.WFS.v1 = SuperMap.Class(SuperMap.Protocol, {
    version: null,
    srsName: "EPSG:4326",
    featureType: null,
    featureNS: null,
    geometryName: "the_geom",
    schema: null,
    featurePrefix: "feature",
    formatOptions: null,
    readFormat: null,
    readOptions: null,
    initialize: function(a) {
        SuperMap.Protocol.prototype.initialize.apply(this, [a]);
        if (!a.format) {
            this.format = SuperMap.Format.WFST(SuperMap.Util.extend({
                version: this.version,
                featureType: this.featureType,
                featureNS: this.featureNS,
                featurePrefix: this.featurePrefix,
                geometryName: this.geometryName,
                srsName: this.srsName,
                schema: this.schema
            }, this.formatOptions))
        }
        if (!a.geometryName && parseFloat(this.format.version) > 1) {
            this.setGeometryName(null)
        }
    },
    destroy: function() {
        if (this.options && !this.options.format) {
            this.format.destroy()
        }
        this.format = null;
        SuperMap.Protocol.prototype.destroy.apply(this)
    },
    read: function(c) {
        SuperMap.Protocol.prototype.read.apply(this, arguments);
        c = SuperMap.Util.extend({}, c);
        SuperMap.Util.applyDefaults(c, this.options || {});
        var a = new SuperMap.Protocol.Response({
            requestType: "read"
        });
        var d = SuperMap.Format.XML.prototype.write.apply(this.format, [this.format.writeNode("wfs:GetFeature", c)]);
        if (SuperMap.Credential.CREDENTIAL) {
            c.url += c.url.indexOf("?") > -1 ? "&" : "?";
            c.url += SuperMap.Credential.CREDENTIAL.getUrlParameters()
        }
        a.priv = SuperMap.Request.POST({
            url: c.url,
            callback: this.createCallback(this.handleRead, a, c),
            params: c.params,
            headers: c.headers,
            data: d
        });
        return a
    },
    setFeatureType: function(a) {
        this.featureType = a;
        this.format.featureType = a
    },
    setGeometryName: function(a) {
        this.geometryName = a;
        this.format.geometryName = a
    },
    handleRead: function(c, d) {
        d = SuperMap.Util.extend({}, d);
        SuperMap.Util.applyDefaults(d, this.options);
        if (d.callback) {
            var e = c.priv;
            if (e.status >= 200 && e.status < 300) {
                var a = this.parseResponse(e, d.readOptions);
                if (a && a.success !== false) {
                    if (d.readOptions && d.readOptions.output == "object") {
                        SuperMap.Util.extend(c, a)
                    } else {
                        c.features = a
                    }
                    c.code = SuperMap.Protocol.Response.SUCCESS
                } else {
                    c.code = SuperMap.Protocol.Response.FAILURE;
                    c.error = a
                }
            } else {
                c.code = SuperMap.Protocol.Response.FAILURE
            }
            d.callback.call(d.scope, c)
        }
    },
    parseResponse: function(d, c) {
        var f = d.responseXML;
        if (!f || !f.documentElement) {
            f = d.responseText
        }
        if (!f || f.length <= 0) {
            return null
        }
        var a = (this.readFormat !== null) ? this.readFormat.read(f) : this.format.read(f, c);
        if (!this.featureNS) {
            var e = this.readFormat || this.format;
            this.featureNS = e.featureNS;
            e.autoConfig = false;
            if (!this.geometryName) {
                this.setGeometryName(e.geometryName)
            }
        }
        return a
    },
    commit: function(d, c) {
        c = SuperMap.Util.extend({}, c);
        SuperMap.Util.applyDefaults(c, this.options);
        var a = new SuperMap.Protocol.Response({
            requestType: "commit",
            reqFeatures: d
        });
        a.priv = SuperMap.Request.POST({
            url: c.url,
            headers: c.headers,
            data: this.format.write(d, c),
            callback: this.createCallback(this.handleCommit, a, c)
        });
        return a
    },
    handleCommit: function(a, c) {
        if (c.callback) {
            var d = a.priv;
            var e = d.responseXML;
            if (!e || !e.documentElement) {
                e = d.responseText
            }
            var f = this.format.read(e) || {};
            a.insertIds = f.insertIds || [];
            if (f.success) {
                a.code = SuperMap.Protocol.Response.SUCCESS
            } else {
                a.code = SuperMap.Protocol.Response.FAILURE;
                a.error = f
            }
            c.callback.call(c.scope, a)
        }
    },
    filterDelete: function(f, d) {
        d = SuperMap.Util.extend({}, d);
        SuperMap.Util.applyDefaults(d, this.options);
        var c = new SuperMap.Protocol.Response({
            requestType: "commit"
        });
        var a = this.format.createElementNSPlus("wfs:Transaction", {
            attributes: {
                service: "WFS",
                version: this.version
            }
        });
        var e = this.format.createElementNSPlus("wfs:Delete", {
            attributes: {
                typeName: (d.featureNS ? this.featurePrefix + ":" : "") + d.featureType
            }
        });
        if (d.featureNS) {
            e.setAttribute("xmlns:" + this.featurePrefix, d.featureNS)
        }
        var h = this.format.writeNode("ogc:Filter", f);
        e.appendChild(h);
        a.appendChild(e);
        var g = SuperMap.Format.XML.prototype.write.apply(this.format, [a]);
        return SuperMap.Request.POST({
            url: this.url,
            callback: d.callback || function() {}
            ,
            data: g
        })
    },
    abort: function(a) {
        if (a) {
            a.priv.abort()
        }
    },
    CLASS_NAME: "SuperMap.Protocol.WFS.v1"
});
SuperMap.Protocol.WFS.v1_0_0 = SuperMap.Class(SuperMap.Protocol.WFS.v1, {
    version: "1.0.0",
    CLASS_NAME: "SuperMap.Protocol.WFS.v1_0_0"
});
SuperMap.Strategy = SuperMap.Class({
    layer: null,
    options: null,
    active: null,
    autoActivate: true,
    autoDestroy: true,
    initialize: function(a) {
        SuperMap.Util.extend(this, a);
        this.options = a;
        this.active = false
    },
    destroy: function() {
        this.deactivate();
        this.layer = null;
        this.options = null
    },
    setLayer: function(a) {
        this.layer = a
    },
    activate: function() {
        if (!this.active) {
            this.active = true;
            return true
        }
        return false
    },
    deactivate: function() {
        if (this.active) {
            this.active = false;
            return true
        }
        return false
    },
    CLASS_NAME: "SuperMap.Strategy"
});
SuperMap.Strategy.BBOX = SuperMap.Class(SuperMap.Strategy, {
    bounds: null,
    resolution: null,
    ratio: 2,
    resFactor: null,
    response: null,
    activate: function() {
        var a = SuperMap.Strategy.prototype.activate.call(this);
        if (a) {
            this.layer.events.on({
                moveend: this.update,
                refresh: this.update,
                visibilitychanged: this.update,
                scope: this
            });
            this.update()
        }
        return a
    },
    deactivate: function() {
        var a = SuperMap.Strategy.prototype.deactivate.call(this);
        if (a) {
            this.layer.events.un({
                moveend: this.update,
                refresh: this.update,
                visibilitychanged: this.update,
                scope: this
            })
        }
        return a
    },
    update: function(c) {
        var a = this.getMapBounds();
        if (a !== null && ((c && c.force) || (this.layer.visibility && this.layer.calculateInRange() && this.invalidBounds(a)))) {
            this.calculateBounds(a);
            this.resolution = this.layer.map.getResolution();
            this.triggerRead(c)
        }
    },
    getMapBounds: function() {
        if (this.layer.map === null) {
            return null
        }
        var a = this.layer.map.getExtent();
        if (a && !this.layer.projection.equals(this.layer.map.getProjectionObject())) {
            a = a.clone().transform(this.layer.map.getProjectionObject(), this.layer.projection)
        }
        return a
    },
    invalidBounds: function(a) {
        if (!a) {
            a = this.getMapBounds()
        }
        var d = !this.bounds || !this.bounds.containsBounds(a);
        if (!d && this.resFactor) {
            var c = this.resolution / this.layer.map.getResolution();
            d = (c >= this.resFactor || c <= (1 / this.resFactor))
        }
        return d
    },
    calculateBounds: function(c) {
        if (!c) {
            c = this.getMapBounds()
        }
        var a = c.getCenterLonLat();
        var e = c.getWidth() * this.ratio;
        var d = c.getHeight() * this.ratio;
        this.bounds = new SuperMap.Bounds(a.lon - (e / 2),a.lat - (d / 2),a.lon + (e / 2),a.lat + (d / 2))
    },
    triggerRead: function(a) {
        if (this.response && !(a && a.noAbort === true)) {
            this.layer.protocol.abort(this.response);
            this.layer.events.triggerEvent("loadend")
        }
        this.layer.events.triggerEvent("loadstart");
        this.response = this.layer.protocol.read(SuperMap.Util.applyDefaults({
            filter: this.createFilter(),
            callback: this.merge,
            scope: this
        }, a))
    },
    createFilter: function() {
        var a = new SuperMap.Filter.Spatial({
            type: SuperMap.Filter.Spatial.BBOX,
            value: this.bounds,
            projection: this.layer.projection
        });
        if (this.layer.filter) {
            a = new SuperMap.Filter.Logical({
                type: SuperMap.Filter.Logical.AND,
                filters: [this.layer.filter, a]
            })
        }
        return a
    },
    merge: function(h) {
        this.layer.destroyFeatures();
        var f = h.features;
        if (f && f.length > 0) {
            var g = this.layer.projection;
            var e = this.layer.map.getProjectionObject();
            if (!e.equals(g)) {
                var d;
                for (var c = 0, a = f.length; c < a; ++c) {
                    d = f[c].geometry;
                    if (d) {
                        d.transform(g, e)
                    }
                }
            }
            this.layer.addFeatures(f)
        }
        this.response = null;
        this.layer.events.triggerEvent("loadend")
    },
    CLASS_NAME: "SuperMap.Strategy.BBOX"
});
SuperMap.Control.Panel = SuperMap.Class(SuperMap.Control, {
    controls: null,
    autoActivate: true,
    defaultControl: null,
    saveState: false,
    allowDepress: false,
    activeState: null,
    initialize: function(a) {
        SuperMap.Control.prototype.initialize.apply(this, [a]);
        this.controls = [];
        this.activeState = {}
    },
    destroy: function() {
        SuperMap.Control.prototype.destroy.apply(this, arguments);
        for (var a, c = this.controls.length - 1; c >= 0; c--) {
            a = this.controls[c];
            if (a.events) {
                a.events.un({
                    activate: this.iconOn,
                    deactivate: this.iconOff
                })
            }
            SuperMap.Event.stopObservingElement(a.panel_div);
            a.panel_div = null
        }
        this.activeState = null
    },
    activate: function() {
        if (SuperMap.Control.prototype.activate.apply(this, arguments)) {
            var d;
            for (var c = 0, a = this.controls.length; c < a; c++) {
                d = this.controls[c];
                if (d === this.defaultControl || (this.saveState && this.activeState[d.id])) {
                    d.activate()
                }
            }
            if (this.saveState === true) {
                this.defaultControl = null
            }
            this.redraw();
            return true
        } else {
            return false
        }
    },
    deactivate: function() {
        if (SuperMap.Control.prototype.deactivate.apply(this, arguments)) {
            var d;
            for (var c = 0, a = this.controls.length; c < a; c++) {
                d = this.controls[c];
                this.activeState[d.id] = d.deactivate()
            }
            this.redraw();
            return true
        } else {
            return false
        }
    },
    draw: function() {
        SuperMap.Control.prototype.draw.apply(this, arguments);
        this.addControlsToMap(this.controls);
        return this.div
    },
    redraw: function() {
        for (var c = this.div.childNodes.length, d = c - 1; d >= 0; d--) {
            this.div.removeChild(this.div.childNodes[d])
        }
        this.div.innerHTML = "";
        if (this.active) {
            for (var d = 0, a = this.controls.length; d < a; d++) {
                this.div.appendChild(this.controls[d].panel_div)
            }
        }
    },
    activateControl: function(e) {
        if (!this.active) {
            return false
        }
        if (e.type == SuperMap.Control.TYPE_BUTTON) {
            e.trigger();
            return
        }
        if (e.type == SuperMap.Control.TYPE_TOGGLE) {
            if (e.active) {
                e.deactivate()
            } else {
                e.activate()
            }
            return
        }
        if (this.allowDepress && e.active) {
            e.deactivate()
        } else {
            var f;
            for (var d = 0, a = this.controls.length; d < a; d++) {
                f = this.controls[d];
                if (f != e && (f.type === SuperMap.Control.TYPE_TOOL || f.type == null)) {
                    f.deactivate()
                }
            }
            e.activate()
        }
    },
    addControls: function(c) {
        if (!(SuperMap.Util.isArray(c))) {
            c = [c]
        }
        this.controls = this.controls.concat(c);
        for (var e = 0, a = c.length; e < a; e++) {
            var d = document.createElement("div");
            d.className = c[e].displayClass + "ItemInactive";
            c[e].panel_div = d;
            if (c[e].title != "") {
                c[e].panel_div.title = c[e].title
            }
            SuperMap.Event.observe(c[e].panel_div, "click", SuperMap.Function.bind(this.onClick, this, c[e]));
            SuperMap.Event.observe(c[e].panel_div, "dblclick", SuperMap.Function.bind(this.onDoubleClick, this, c[e]));
            SuperMap.Event.observe(c[e].panel_div, "mousedown", SuperMap.Function.bindAsEventListener(SuperMap.Event.stop))
        }
        if (this.map) {
            this.addControlsToMap(c);
            this.redraw()
        }
    },
    addControlsToMap: function(c) {
        var e;
        for (var d = 0, a = c.length; d < a; d++) {
            e = c[d];
            if (e.autoActivate === true) {
                e.autoActivate = false;
                this.map.addControl(e);
                e.autoActivate = true
            } else {
                this.map.addControl(e);
                e.deactivate()
            }
            e.events.on({
                activate: this.iconOn,
                deactivate: this.iconOff
            })
        }
    },
    iconOn: function() {
        var a = this.panel_div;
        a.className = a.className.replace(/ItemInactive$/, "ItemActive")
    },
    iconOff: function() {
        var a = this.panel_div;
        a.className = a.className.replace(/ItemActive$/, "ItemInactive")
    },
    onClick: function(c, a) {
        SuperMap.Event.stop(a ? a : window.event);
        this.activateControl(c)
    },
    onDoubleClick: function(c, a) {
        SuperMap.Event.stop(a ? a : window.event)
    },
    getControlsBy: function(d, a) {
        var e = (typeof a.test == "function");
        var c = SuperMap.Array.filter(this.controls, function(f) {
            return f[d] == a || (e && a.test(f[d]))
        });
        return c
    },
    getControlsByName: function(a) {
        return this.getControlsBy("name", a)
    },
    getControlsByClass: function(a) {
        return this.getControlsBy("CLASS_NAME", a)
    },
    CLASS_NAME: "SuperMap.Control.Panel"
});
SuperMap.Control.SelectFeature = SuperMap.Class(SuperMap.Control, {
    multipleKey: null,
    toggleKey: null,
    multiple: false,
    clickout: true,
    toggle: false,
    repeat: false,
    hover: false,
    highlightOnly: false,
    box: false,
    onBeforeSelect: function() {},
    onSelect: function() {},
    onUnselect: function() {},
    scope: null,
    geometryTypes: null,
    layer: null,
    layers: null,
    callbacks: null,
    selectStyle: null,
    renderIntent: "select",
    handlers: null,
    initialize: function(d, a) {
        SuperMap.Control.prototype.initialize.apply(this, [a]);
        if (this.scope === null) {
            this.scope = this
        }
        this.initLayer(d);
        var c = {
            click: this.clickFeature,
            clickout: this.clickoutFeature
        };
        if (this.hover) {
            c.over = this.overFeature;
            c.out = this.outFeature
        }
        this.callbacks = SuperMap.Util.extend(c, this.callbacks);
        this.handlers = {
            feature: new SuperMap.Handler.Feature(this,this.layer,this.callbacks,{
                geometryTypes: this.geometryTypes
            })
        };
        if (this.box) {
            this.handlers.box = new SuperMap.Handler.Box(this,{
                done: this.selectBox
            },{
                boxDivClassName: "smHandlerBoxSelectFeature"
            })
        }
    },
    initLayer: function(a) {
        if (SuperMap.Util.isArray(a)) {
            this.layers = a;
            this.layer = new SuperMap.Layer.Vector.RootContainer(this.id + "_container",{
                layers: a
            })
        } else {
            this.layer = a
        }
    },
    destroy: function() {
        if (this.active && this.layers) {
            this.map.removeLayer(this.layer)
        }
        SuperMap.Control.prototype.destroy.apply(this, arguments);
        if (this.layers) {
            this.layer.destroy()
        }
    },
    activate: function() {
        if (!this.active) {
            if (this.layers) {
                this.map.addLayer(this.layer)
            }
            this.handlers.feature.activate();
            if (this.box && this.handlers.box) {
                this.handlers.box.activate()
            }
        }
        return SuperMap.Control.prototype.activate.apply(this, arguments)
    },
    deactivate: function() {
        if (this.active) {
            this.handlers.feature.deactivate();
            if (this.handlers.box) {
                this.handlers.box.deactivate()
            }
            if (this.layers) {
                this.map.removeLayer(this.layer)
            }
        }
        return SuperMap.Control.prototype.deactivate.apply(this, arguments)
    },
    unselectAll: function(c) {
        var g = this.layers || [this.layer];
        var f, e;
        for (var a = 0; a < g.length; ++a) {
            f = g[a];
            for (var d = f.selectedFeatures.length - 1; d >= 0; --d) {
                e = f.selectedFeatures[d];
                if (!c || c.except != e) {
                    this.unselect(e)
                }
            }
        }
    },
    clickFeature: function(a) {
        if (!this.hover) {
            var c = (SuperMap.Util.indexOf(a.layer.selectedFeatures, a) > -1);
            if (c) {
                if (this.toggleSelect()) {
                    this.unselect(a)
                } else {
                    if (!this.multipleSelect()) {
                        this.unselectAll({
                            except: a
                        });
                        if (this.repeat) {
                            this.onSelect.call(this.scope, a)
                        }
                    }
                }
            } else {
                if (!this.multipleSelect()) {
                    this.unselectAll({
                        except: a
                    })
                }
                this.select(a)
            }
        }
    },
    multipleSelect: function() {
        return this.multiple || (this.handlers.feature.evt && this.handlers.feature.evt[this.multipleKey])
    },
    toggleSelect: function() {
        return this.toggle || (this.handlers.feature.evt && this.handlers.feature.evt[this.toggleKey])
    },
    clickoutFeature: function(a) {
        if (!this.hover && this.clickout) {
            this.unselectAll()
        }
    },
    overFeature: function(c) {
        var a = c.layer;
        if (this.hover) {
            if (this.highlightOnly) {
                this.highlight(c)
            } else {
                if (SuperMap.Util.indexOf(a.selectedFeatures, c) == -1) {
                    this.select(c)
                }
            }
        }
    },
    outFeature: function(a) {
        if (this.hover) {
            if (this.highlightOnly) {
                if (a._lastHighlighter == this.id) {
                    if (a._prevHighlighter && a._prevHighlighter != this.id) {
                        delete a._lastHighlighter;
                        var c = this.map.getControl(a._prevHighlighter);
                        if (c) {
                            c.highlight(a)
                        }
                    } else {
                        this.unhighlight(a)
                    }
                }
            } else {
                this.unselect(a)
            }
        }
    },
    highlight: function(d) {
        var c = d.layer;
        var a = this.events.triggerEvent("beforefeaturehighlighted", {
            feature: d
        });
        if (a !== false) {
            d._prevHighlighter = d._lastHighlighter;
            d._lastHighlighter = this.id;
            var e = this.selectStyle || this.renderIntent;
            if (!e.label) {
                if (d.style.label) {
                    e.label = d.style.label
                }
            }
            c.drawFeature(d, e, {
                isSelected: true
            });
            this.events.triggerEvent("featurehighlighted", {
                feature: d
            })
        }
    },
    unhighlight: function(c) {
        var a = c.layer;
        if (c._prevHighlighter == undefined) {
            delete c._lastHighlighter
        } else {
            if (c._prevHighlighter == this.id) {
                delete c._prevHighlighter
            } else {
                c._lastHighlighter = c._prevHighlighter;
                delete c._prevHighlighter
            }
        }
        a.drawFeature(c, c.style || c.layer.style || "default", {
            isSelected: true
        });
        this.events.triggerEvent("featureunhighlighted", {
            feature: c
        })
    },
    select: function(d) {
        var a = this.onBeforeSelect.call(this.scope, d);
        var c = d.layer;
        if (a !== false) {
            a = c.events.triggerEvent("beforefeatureselected", {
                feature: d
            });
            if (a !== false) {
                c.selectedFeatures.push(d);
                this.highlight(d);
                if (!this.handlers.feature.lastFeature) {
                    this.handlers.feature.lastFeature = c.selectedFeatures[0]
                }
                c.events.triggerEvent("featureselected", {
                    feature: d
                });
                this.onSelect.call(this.scope, d)
            }
        }
    },
    unselect: function(c) {
        var a = c.layer;
        this.unhighlight(c);
        SuperMap.Util.removeItem(a.selectedFeatures, c);
        a.events.triggerEvent("featureunselected", {
            feature: c
        });
        this.onUnselect.call(this.scope, c)
    },
    selectBox: function(f) {
        if (f instanceof SuperMap.Bounds) {
            var j = this.map.getLonLatFromPixel({
                x: f.left,
                y: f.bottom
            });
            var m = this.map.getLonLatFromPixel({
                x: f.right,
                y: f.top
            });
            var a = new SuperMap.Bounds(j.lon,j.lat,m.lon,m.lat);
            if (!this.multipleSelect()) {
                this.unselectAll()
            }
            var k = this.multiple;
            this.multiple = true;
            var e = this.layers || [this.layer];
            var g;
            for (var c = 0; c < e.length; ++c) {
                g = e[c];
                for (var d = 0, h = g.features.length; d < h; ++d) {
                    var n = g.features[d];
                    if (!n.getVisibility()) {
                        continue
                    }
                    if (this.geometryTypes == null || SuperMap.Util.indexOf(this.geometryTypes, n.geometry.CLASS_NAME) > -1) {
                        if (a.toGeometry().intersects(n.geometry)) {
                            if (SuperMap.Util.indexOf(g.selectedFeatures, n) == -1) {
                                this.select(n)
                            }
                        }
                    }
                }
            }
            this.multiple = k
        }
    },
    setMap: function(a) {
        this.handlers.feature.setMap(a);
        if (this.box) {
            this.handlers.box.setMap(a)
        }
        SuperMap.Control.prototype.setMap.apply(this, arguments)
    },
    setLayer: function(c) {
        var a = this.active;
        this.unselectAll();
        this.deactivate();
        if (this.layers) {
            this.layer.destroy();
            this.layers = null
        }
        this.initLayer(c);
        this.handlers.feature.layer = this.layer;
        if (a) {
            this.activate()
        }
    },
    CLASS_NAME: "SuperMap.Control.SelectFeature"
});
SuperMap.Control.Measure = SuperMap.Class(SuperMap.Control, {
    EVENT_TYPES: ["measure", "measurepartial"],
    handlerOptions: null,
    callbacks: null,
    displaySystem: "metric",
    geodesic: false,
    displaySystemUnits: {
        geographic: ["dd"],
        english: ["mi", "ft", "in"],
        metric: ["km", "m"]
    },
    partialDelay: 300,
    delayedTrigger: null,
    persist: false,
    immediate: false,
    initialize: function(c, a) {
        this.EVENT_TYPES = SuperMap.Control.Measure.prototype.EVENT_TYPES.concat(SuperMap.Control.prototype.EVENT_TYPES);
        SuperMap.Control.prototype.initialize.apply(this, [a]);
        var d = {
            done: this.measureComplete,
            point: this.measurePartial
        };
        if (this.immediate) {
            d.modify = this.measureImmediate
        }
        this.callbacks = SuperMap.Util.extend(d, this.callbacks);
        this.handlerOptions = SuperMap.Util.extend({
            persist: this.persist
        }, this.handlerOptions);
        this.handler = new c(this,this.callbacks,this.handlerOptions)
    },
    deactivate: function() {
        this.cancelDelay();
        return SuperMap.Control.prototype.deactivate.apply(this, arguments)
    },
    cancel: function() {
        this.cancelDelay();
        this.handler.cancel()
    },
    setImmediate: function(a) {
        this.immediate = a;
        if (this.immediate) {
            this.callbacks.modify = this.measureImmediate
        } else {
            delete this.callbacks.modify
        }
    },
    updateHandler: function(c, a) {
        var d = this.active;
        if (d) {
            this.deactivate()
        }
        this.handler = new c(this,this.callbacks,a);
        if (d) {
            this.activate()
        }
    },
    measureComplete: function(a) {
        this.cancelDelay();
        this.measure(a, "measure")
    },
    measurePartial: function(a, c) {
        this.cancelDelay();
        c = c.clone();
        if (this.handler.freehandMode(this.handler.evt)) {
            this.measure(c, "measurepartial")
        } else {
            this.delayedTrigger = window.setTimeout(SuperMap.Function.bind(function() {
                this.delayedTrigger = null;
                this.measure(c, "measurepartial")
            }, this), this.partialDelay)
        }
    },
    measureImmediate: function(a, d, c) {
        if (c && this.delayedTrigger === null && !this.handler.freehandMode(this.handler.evt)) {
            this.measure(d.geometry, "measurepartial")
        }
    },
    cancelDelay: function() {
        if (this.delayedTrigger !== null) {
            window.clearTimeout(this.delayedTrigger);
            this.delayedTrigger = null
        }
    },
    measure: function(e, c) {
        var d, a;
        if (e.CLASS_NAME.indexOf("LineString") > -1) {
            d = this.getBestLength(e);
            a = 1
        } else {
            d = this.getBestArea(e);
            a = 2
        }
        this.events.triggerEvent(c, {
            measure: d[0],
            units: d[1],
            order: a,
            geometry: e
        })
    },
    getBestArea: function(g) {
        var c = this.displaySystemUnits[this.displaySystem];
        var f, e;
        for (var d = 0, a = c.length; d < a; ++d) {
            f = c[d];
            e = this.getArea(g, f);
            if (e > 1) {
                break
            }
        }
        return [e, f]
    },
    getArea: function(g, a) {
        var c, d;
        if (this.geodesic) {
            c = g.getGeodesicArea(this.map.getProjectionObject());
            d = "m"
        } else {
            c = g.getArea();
            d = this.map.getUnits()
        }
        var f = SuperMap.INCHES_PER_UNIT[a];
        if (f) {
            var e = SuperMap.INCHES_PER_UNIT[d];
            c *= Math.pow((e / f), 2)
        }
        return c
    },
    getBestLength: function(g) {
        var c = this.displaySystemUnits[this.displaySystem];
        var f, e;
        for (var d = 0, a = c.length; d < a; ++d) {
            f = c[d];
            e = this.getLength(g, f);
            if (e > 1) {
                break
            }
        }
        return [e, f]
    },
    getLength: function(g, a) {
        var c, d;
        if (this.geodesic) {
            c = g.getGeodesicLength(this.map.getProjectionObject());
            d = "m"
        } else {
            c = g.getLength();
            d = this.map.getUnits()
        }
        var f = SuperMap.INCHES_PER_UNIT[a];
        if (f) {
            var e = SuperMap.INCHES_PER_UNIT[d];
            c *= (e / f)
        }
        return c
    },
    CLASS_NAME: "SuperMap.Control.Measure"
});
SuperMap.Control.Geolocate = SuperMap.Class(SuperMap.Control, {
    EVENT_TYPES: ["locationupdated", "locationfailed", "locationuncapable"],
    geolocation: navigator.geolocation,
    bind: true,
    watch: false,
    geolocationOptions: null,
    initialize: function(a) {
        this.EVENT_TYPES = SuperMap.Control.Geolocate.prototype.EVENT_TYPES.concat(SuperMap.Control.prototype.EVENT_TYPES);
        this.geolocationOptions = {};
        SuperMap.Control.prototype.initialize.apply(this, [a])
    },
    destroy: function() {
        this.deactivate();
        SuperMap.Control.prototype.destroy.apply(this, arguments)
    },
    activate: function() {
        if (!this.geolocation) {
            this.events.triggerEvent("locationuncapable");
            return false
        }
        if (SuperMap.Control.prototype.activate.apply(this, arguments)) {
            if (this.watch) {
                this.watchId = this.geolocation.watchPosition(SuperMap.Function.bind(this.geolocate, this), SuperMap.Function.bind(this.failure, this), this.geolocationOptions)
            } else {
                this.getCurrentLocation()
            }
            return true
        }
        return false
    },
    deactivate: function() {
        if (this.active && this.watchId !== null) {
            this.geolocation.clearWatch(this.watchId)
        }
        return SuperMap.Control.prototype.deactivate.apply(this, arguments)
    },
    geolocate: function(c) {
        var a = new SuperMap.LonLat(c.coords.longitude,c.coords.latitude).transform(new SuperMap.Projection("EPSG:4326"), this.map.getProjectionObject());
        if (this.bind) {
            this.map.setCenter(a)
        }
        this.events.triggerEvent("locationupdated", {
            position: c,
            point: new SuperMap.Geometry.Point(a.lon,a.lat)
        })
    },
    getCurrentLocation: function() {
        if (!this.active || this.watch) {
            return false
        }
        this.geolocation.getCurrentPosition(SuperMap.Function.bind(this.geolocate, this), SuperMap.Function.bind(this.failure, this), this.geolocationOptions);
        return true
    },
    failure: function(a) {
        this.events.triggerEvent("locationfailed", {
            error: a
        })
    },
    CLASS_NAME: "SuperMap.Control.Geolocate"
});
SuperMap.Control.SelectCluster = SuperMap.Class(SuperMap.Control.SelectFeature, {
    hover: true,
    initialize: function() {
        SuperMap.Control.SelectFeature.prototype.initialize.apply(this, arguments)
    },
    clickCluster: function(c) {
        var a = c.layer;
        a.clickCluster(c);
        a.events.triggerEvent("clickCluster", c)
    },
    clickoutCluster: function(c) {
        var a = c.layer;
        a.clickoutCluster(c);
        a.events.triggerEvent("clickout", c)
    },
    selectEvent: function(c, a) {
        if (c.isPoint) {
            if (a) {
                c.layer.events.triggerEvent("clickFeature", c)
            } else {
                c.layer.events.triggerEvent("mouseoverFeature", c)
            }
        } else {
            if (c.isCluster) {
                if (a) {
                    this.clickCluster(c)
                } else {
                    c.layer.events.triggerEvent("mouseoverCluster", c)
                }
            }
        }
    },
    unselectEvent: function(c, a) {
        if (c.isPoint) {
            if (a) {
                this.clickoutCluster(c)
            } else {
                c.layer.events.triggerEvent("mouseoutFeature", c)
            }
        } else {
            if (c.isCluster) {
                if (a) {
                    this.clickoutCluster(c)
                } else {
                    c.layer.events.triggerEvent("mouseoutCluster", c)
                }
            }
        }
    },
    clickFeature: function(a) {
        var c = (SuperMap.Util.indexOf(a.layer.selectedFeatures, a) > -1);
        c = false;
        if (c) {
            if (this.toggleSelect()) {
                this.unselect(a, "click")
            } else {
                if (!this.multipleSelect()) {
                    this.unselectAll({
                        except: a
                    });
                    if (this.repeat) {
                        this.selectEvent(a);
                        this.onSelect.call(this.scope, a)
                    }
                }
            }
        } else {
            if (!this.multipleSelect()) {
                this.unselectAll({
                    except: a
                })
            }
            this.select(a, "click")
        }
    },
    select: function(d, e) {
        var a = this.onBeforeSelect.call(this.scope, d);
        var c = d.layer;
        if (a !== false) {
            a = c.events.triggerEvent("beforefeatureselected", {
                feature: d
            });
            if (a !== false) {
                c.selectedFeatures.push(d);
                this.highlight(d);
                if (!this.handlers.feature.lastFeature) {
                    this.handlers.feature.lastFeature = c.selectedFeatures[0]
                }
                this.selectEvent(d, e);
                c.events.triggerEvent("featureselected", {
                    feature: d,
                    action: e
                });
                this.onSelect.call(this.scope, d, e)
            }
        }
    },
    unselect: function(c, d) {
        var a = c.layer;
        this.unhighlight(c);
        SuperMap.Util.removeItem(a.selectedFeatures, c);
        this.unselectEvent(c, d);
        a.events.triggerEvent("featureunselected", {
            feature: c,
            action: d
        });
        this.onUnselect.call(this.scope, c)
    },
    clickoutFeature: function(a) {
        try {
            if (!this.hover && this.clickout) {
                this.unselectAll()
            }
        } catch (c) {}
        this.unselectEvent(a, "click");
        this.onUnselect(a, "click")
    },
    CLASS_NAME: "SuperMap.Control.SelectCluster"
});
SuperMap.Symbolizer = SuperMap.Class({
    zIndex: 0,
    initialize: function(a) {
        SuperMap.Util.extend(this, a)
    },
    clone: function() {
        var Type = eval(this.CLASS_NAME);
        return new Type(SuperMap.Util.extend({}, this))
    },
    CLASS_NAME: "SuperMap.Symbolizer"
});
SuperMap.Symbolizer.Point = SuperMap.Class(SuperMap.Symbolizer, {
    initialize: function(a) {
        SuperMap.Symbolizer.prototype.initialize.apply(this, arguments)
    },
    CLASS_NAME: "SuperMap.Symbolizer.Point"
});
SuperMap.Symbolizer.Line = SuperMap.Class(SuperMap.Symbolizer, {
    initialize: function(a) {
        SuperMap.Symbolizer.prototype.initialize.apply(this, arguments)
    },
    CLASS_NAME: "SuperMap.Symbolizer.Line"
});
SuperMap.Symbolizer.Polygon = SuperMap.Class(SuperMap.Symbolizer, {
    initialize: function(a) {
        SuperMap.Symbolizer.prototype.initialize.apply(this, arguments)
    },
    CLASS_NAME: "SuperMap.Symbolizer.Polygon"
});
SuperMap.Symbolizer.Raster = SuperMap.Class(SuperMap.Symbolizer, {
    initialize: function(a) {
        SuperMap.Symbolizer.prototype.initialize.apply(this, arguments)
    },
    CLASS_NAME: "SuperMap.Symbolizer.Raster"
});
SuperMap.Symbolizer.Text = SuperMap.Class(SuperMap.Symbolizer, {
    initialize: function(a) {
        SuperMap.Symbolizer.prototype.initialize.apply(this, arguments)
    },
    CLASS_NAME: "SuperMap.Symbolizer.Text"
});
SuperMap.Lang = {
    code: null,
    defaultCode: "en",
    getCode: function() {
        if (!SuperMap.Lang.code) {
            SuperMap.Lang.setCode()
        }
        return SuperMap.Lang.code
    },
    setCode: function(c) {
        var e;
        if (!c) {
            c = (SuperMap.Browser.name == "msie") ? navigator.userLanguage : navigator.language
        }
        var d = c.split("-");
        d[0] = d[0].toLowerCase();
        if (typeof SuperMap.Lang[d[0]] == "object") {
            e = d[0]
        }
        if (d[1]) {
            var a = d[0] + "-" + d[1].toUpperCase();
            if (typeof SuperMap.Lang[a] == "object") {
                e = a
            }
        }
        if (!e) {
            e = SuperMap.Lang.defaultCode
        }
        SuperMap.Lang.code = e
    },
    translate: function(c, a) {
        var e = SuperMap.Lang[SuperMap.Lang.getCode()];
        var d = e && e[c];
        if (!d) {
            d = c
        }
        if (a) {
            d = SuperMap.String.format(d, a)
        }
        return d
    }
};
SuperMap.i18n = SuperMap.Lang.translate;
SuperMap.ServiceBase = SuperMap.Class({
    url: null,
    isInTheSameDomain: null,
    initialize: function(a) {
        if (!a) {
            return false
        }
        var c = this;
        c.url = a;
        c.isInTheSameDomain = SuperMap.Util.isInTheSameDomain(c.url)
    },
    destroy: function() {
        var a = this;
        a.url = null;
        a.isInTheSameDomain = null
    },
    request: function(c) {
        var d = this;
        c.url = c.url || d.url;
        if (SuperMap.Credential.CREDENTIAL) {
            var a = c.url.substring(c.url.length - 1, c.url.length);
            if (c.url.indexOf("?") > -1 && a === "?") {
                c.url += SuperMap.Credential.CREDENTIAL.getUrlParameters()
            } else {
                if (c.url.indexOf("?") > -1 && a !== "?") {
                    c.url += "&" + SuperMap.Credential.CREDENTIAL.getUrlParameters()
                } else {
                    c.url += "?" + SuperMap.Credential.CREDENTIAL.getUrlParameters()
                }
            }
        }
        c.isInTheSameDomain = d.isInTheSameDomain;
        SuperMap.Util.committer(c)
    },
    CLASS_NAME: "SuperMap.ServiceBase"
});
SuperMap.ServiceEventArgs = SuperMap.Class({
    originResult: null,
    initialize: function(a) {
        this.originResult = a
    },
    destroy: function() {
        this.originResult = null
    },
    CLASS_NAME: "SuperMap.ServiceEventArgs"
});
SuperMap.ServiceException = SuperMap.Class({
    code: null,
    errorMsg: null,
    initialize: function(d, c) {
        var a = this;
        a.code = d;
        a.errorMsg = c
    },
    destroy: function() {
        var a = this;
        a.code = null;
        a.errorMsg = null
    },
    CLASS_NAME: "SuperMap.ServiceException"
});
SuperMap.ServiceException.fromJson = function(a) {
    if (!a) {
        return
    }
    return new SuperMap.ServiceException(a.code,a.errorMsg)
}
;
SuperMap.ServiceFailedEventArgs = SuperMap.Class(SuperMap.ServiceEventArgs, {
    error: null,
    initialize: function(a, d) {
        SuperMap.ServiceEventArgs.prototype.initialize.apply(this, [d]);
        var c = this;
        c.error = a
    },
    destroy: function() {
        SuperMap.ServiceEventArgs.prototype.destroy.apply(this);
        var a = this;
        if (a.error) {
            a.error.destroy();
            a.error = null
        }
    },
    CLASS_NAME: "SuperMap.ServiceFailedEventArgs"
});
SuperMap.REST.ServerGeometry = SuperMap.Class({
    id: 0,
    style: null,
    parts: null,
    points: null,
    type: null,
    initialize: function(a) {
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        var a = this;
        a.id = null;
        a.style = null;
        a.parts = null;
        a.points = null;
        a.type = null
    },
    toGeometry: function() {
        var c = this
          , a = c.type;
        switch (a) {
        case SuperMap.REST.GeometryType.POINT:
            return c.toGeoPoint();
        case SuperMap.REST.GeometryType.LINE:
            return c.toGeoLine();
        case SuperMap.REST.GeometryType.LINEM:
            return c.toGeoLinem();
        case SuperMap.REST.GeometryType.REGION:
            return c.toGeoRegion()
        }
    },
    toGeoPoint: function() {
        var f = this
          , g = f.parts || []
          , d = f.points || []
          , c = g.length;
        if (c > 0) {
            if (c === 1) {
                return new SuperMap.Geometry.Point(d[0].x,d[0].y)
            } else {
                for (var e = 0, a = []; e < c; e++) {
                    a.push(new SuperMap.Geometry.Point(d[e].x,d[e].y))
                }
                return new SuperMap.Geometry.MultiPoint(a)
            }
        } else {
            return null
        }
    },
    toGeoLine: function() {
        var g = this
          , h = g.parts || []
          , d = g.points || []
          , c = h.length;
        if (c > 0) {
            if (c === 1) {
                for (var f = 0, a = []; f < h[0]; f++) {
                    a.push(new SuperMap.Geometry.Point(d[f].x,d[f].y))
                }
                if (a[0].equals(a[h[0] - 1])) {
                    return new SuperMap.Geometry.LinearRing(a)
                } else {
                    return new SuperMap.Geometry.LineString(a)
                }
            } else {
                for (var f = 0, k = []; f < c; f++) {
                    for (var e = 0, a = []; e < h[f]; e++) {
                        a.push(new SuperMap.Geometry.Point(d[e].x,d[e].y))
                    }
                    k.push(new SuperMap.Geometry.LineString(a));
                    d.splice(0, h[f])
                }
                return new SuperMap.Geometry.MultiLineString(k)
            }
        } else {
            return null
        }
    },
    toGeoLinem: function() {
        var a = this;
        return new SuperMap.REST.Route.fromJson(a)
    },
    toGeoRegion: function() {
        var h = this
          , e = h.parts || []
          , k = h.points || []
          , g = e.length;
        if (g > 0) {
            var c = new Array();
            for (var f = 0, l = 0, a = []; f < g; f++) {
                for (var d = 0; d < e[f]; d++) {
                    a.push(new SuperMap.Geometry.Point(k[l + d].x,k[l + d].y))
                }
                l += e[f];
                c.push(new SuperMap.Geometry.LinearRing(a));
                a = []
            }
            return new SuperMap.Geometry.Polygon(c)
        } else {
            return null
        }
    },
    CLASS_NAME: "SuperMap.REST.ServerGeometry"
});
SuperMap.REST.ServerGeometry.fromJson = function(a) {
    if (!a) {
        return
    }
    return new SuperMap.REST.ServerGeometry({
        id: a.id,
        style: SuperMap.REST.ServerStyle.fromJson(a.style),
        parts: a.parts,
        points: a.points,
        type: a.type
    })
}
;
SuperMap.REST.ServerGeometry.fromGeometry = function(p) {
    if (!p) {
        return
    }
    var a = 0
      , h = []
      , r = []
      , o = null
      , t = p.components
      , n = p.CLASS_NAME;
    if (!isNaN(p.id)) {
        a = p.id
    }
    if (n === "SuperMap.Geometry.MultiPoint" || n === "SuperMap.Geometry.MultiLineString") {
        var d = t.length;
        for (var l = 0; l < d; l++) {
            var s = t[l].getVertices().length;
            h.push(s);
            for (var g = 0; g < s; g++) {
                r.push(new SuperMap.Geometry.Point(t[l].getVertices()[g].x,t[l].getVertices()[g].y))
            }
        }
        o = (n === "SuperMap.Geometry.MultiPoint") ? SuperMap.REST.GeometryType.POINT : SuperMap.REST.GeometryType.LINE
    } else {
        if (n === "SuperMap.Geometry.MultiPolygon") {
            var d = t.length;
            for (var l = 0; l < d; l++) {
                var q = t[l]
                  , m = q.components
                  , c = m.length;
                for (var g = 0; g < c; g++) {
                    var s = m[g].getVertices().length + 1;
                    h.push(s);
                    for (var f = 0; f < s - 1; f++) {
                        r.push(new SuperMap.Geometry.Point(m[g].getVertices()[f].x,m[g].getVertices()[f].y))
                    }
                    r.push(new SuperMap.Geometry.Point(m[g].getVertices()[0].x,m[g].getVertices()[0].y))
                }
            }
            o = SuperMap.REST.GeometryType.REGION
        } else {
            if (n === "SuperMap.Geometry.Polygon") {
                var d = t.length;
                for (var l = 0; l < d; l++) {
                    var s = t[l].getVertices().length + 1;
                    h.push(s);
                    for (var g = 0; g < s - 1; g++) {
                        r.push(new SuperMap.Geometry.Point(t[l].getVertices()[g].x,t[l].getVertices()[g].y))
                    }
                    r.push(new SuperMap.Geometry.Point(t[l].getVertices()[0].x,t[l].getVertices()[0].y))
                }
                o = SuperMap.REST.GeometryType.REGION
            } else {
                var e = p.getVertices().length;
                for (var g = 0; g < e; g++) {
                    r.push(new SuperMap.Geometry.Point(p.getVertices()[g].x,p.getVertices()[g].y))
                }
                if (n === "SuperMap.Geometry.LinearRing") {
                    r.push(new SuperMap.Geometry.Point(p.getVertices()[0].x,p.getVertices()[0].y));
                    e++
                }
                h.push(e);
                o = (n === "SuperMap.Geometry.Point") ? SuperMap.REST.GeometryType.POINT : SuperMap.REST.GeometryType.LINE
            }
        }
    }
    return new SuperMap.REST.ServerGeometry({
        id: a,
        style: null,
        parts: h,
        points: r,
        type: o
    })
}
;
SuperMap.REST.ServerFeature = SuperMap.Class({
    fieldNames: null,
    fieldValues: null,
    geometry: null,
    initialize: function(a) {
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        var a = this;
        a.fieldNames = null;
        a.fieldValues = null;
        if (a.geometry) {
            a.geometry.destroy();
            a.geometry = null
        }
    },
    toFeature: function() {
        var j, c, f, h, a = {}, g = this, e;
        f = SuperMap.Util.extend({}, SuperMap.Feature.Vector.style["default"]);
        j = g.fieldNames;
        c = g.fieldValues;
        for (var d in j) {
            a[j[d]] = c[d]
        }
        if (g.geometry) {
            h = g.geometry.toGeometry()
        }
        e = new SuperMap.Feature.Vector(h,a,f);
        if (g.geometry && g.geometry.id) {
            e.fid = g.geometry.id
        }
        return e
    },
    CLASS_NAME: "SuperMap.REST.ServerFeature"
});
SuperMap.REST.ServerFeature.fromJson = function(a) {
    var c = this
      , d = null;
    if (!a) {
        return
    }
    d = a.geometry;
    if (d) {
        d = SuperMap.REST.ServerGeometry.fromJson(d)
    }
    return new SuperMap.REST.ServerFeature({
        fieldNames: a.fieldNames,
        fieldValues: a.fieldValues,
        geometry: d
    })
}
;
SuperMap.REST.DatasourceConnectionInfo = SuperMap.Class({
    alias: null,
    connect: null,
    dataBase: null,
    driver: null,
    engineType: null,
    exclusive: null,
    OpenLinkTable: null,
    password: null,
    readOnly: null,
    server: null,
    user: null,
    initialize: function(a) {
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        var a = this;
        a.alias = null;
        a.connect = null;
        a.dataBase = null;
        a.driver = null;
        a.engineType = null;
        a.exclusive = null;
        a.OpenLinkTable = null;
        a.password = null;
        a.readOnly = null;
        a.server = null;
        a.user = null
    },
    CLASS_NAME: "SuperMap.REST.DatasourceConnectionInfo"
});
SuperMap.REST.JoinItem = SuperMap.Class({
    foreignTableName: null,
    joinFilter: null,
    joinType: null,
    initialize: function(a) {
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        var a = this;
        a.foreignTableName = null;
        a.joinFilter = null;
        a.joinType = null
    },
    toServerJSONObject: function() {
        var a = {};
        a = SuperMap.Util.copyAttributes(a, this);
        return a
    },
    CLASS_NAME: "SuperMap.REST.JoinItem"
});
SuperMap.REST.LinkItem = SuperMap.Class({
    datasourceConnectionInfo: null,
    foreignKeys: null,
    foreignTable: null,
    linkFields: null,
    linkFilter: null,
    name: null,
    primaryKeys: null,
    initialize: function(a) {
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        var a = this;
        if (a.datasourceConnectionInfo) {
            a.datasourceConnectionInfo.destroy();
            a.datasourceConnectionInfo = null
        }
        a.foreignKeys = null;
        a.foreignTable = null;
        a.linkFields = null;
        a.linkFilter = null;
        a.name = null;
        a.primaryKeys = null
    },
    CLASS_NAME: "SuperMap.REST.LinkItem"
});
SuperMap.REST.MeasureEventArgs = SuperMap.Class(SuperMap.ServiceEventArgs, {
    result: null,
    initialize: function(a, d) {
        SuperMap.ServiceEventArgs.prototype.initialize.apply(this, [d]);
        var c = this;
        c.result = a
    },
    destroy: function() {
        SuperMap.ServiceEventArgs.prototype.destroy.apply(this);
        var a = this;
        if (a.result) {
            a.result.destroy();
            a.result = null
        }
    },
    CLASS_NAME: "SuperMap.REST.MeasureEventArgs"
});
SuperMap.REST.MeasureParameters = SuperMap.Class({
    geometry: null,
    unit: SuperMap.REST.Unit.METER,
    initialize: function(c, a) {
        if (!c) {
            return
        }
        this.geometry = c;
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        var a = this;
        a.geometry = null;
        a.unit = null
    },
    CLASS_NAME: "SuperMap.REST.MeasureParameters"
});
SuperMap.REST.MeasureResult = SuperMap.Class({
    area: null,
    distance: null,
    unit: null,
    initialize: function(a) {
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        var a = this;
        a.area = null;
        a.distance = null;
        a.unit = null
    },
    CLASS_NAME: "SuperMap.REST.MeasureResult"
});
SuperMap.REST.MeasureResult.fromJson = function(a) {
    if (!a) {
        return
    }
    return new SuperMap.REST.MeasureResult({
        area: a.area,
        distance: a.distance,
        unit: a.unit
    })
}
;
SuperMap.REST.MeasureService = SuperMap.Class(SuperMap.ServiceBase, {
    EVENT_TYPES: ["processCompleted", "processFailed"],
    events: null,
    eventListeners: null,
    lastResult: null,
    measureMode: SuperMap.REST.MeasureMode.DISTANCE,
    initialize: function(c, a) {
        SuperMap.ServiceBase.prototype.initialize.apply(this, [c]);
        if (a) {
            SuperMap.Util.extend(this, a)
        }
        var d = this;
        d.events = new SuperMap.Events(d,null,d.EVENT_TYPES,true);
        if (d.eventListeners instanceof Object) {
            d.events.on(d.eventListeners)
        }
    },
    destroy: function() {
        SuperMap.ServiceBase.prototype.destroy.apply(this, arguments);
        var a = this;
        a.EVENT_TYPES = null;
        if (a.events) {
            a.events.destroy();
            a.events = null
        }
        if (a.eventListeners) {
            a.eventListeners = null
        }
        if (a.lastResult) {
            a.lastResult.destroy();
            a.lastResult = null
        }
        a.measureMode = null
    },
    processAsync: function(i) {
        if (!i) {
            return
        }
        var g = this
          , h = i.geometry
          , e = 0
          , d = null
          , a = null
          , c = null;
        if (!h) {
            return
        }
        c = g.url.substr(g.url.length - 1, 1);
        if (g.measureMode == SuperMap.REST.MeasureMode.AREA) {
            if (g.isInTheSameDomain) {
                g.url += ((c == "/") ? "area.json?" : "/area.json?")
            } else {
                g.url += ((c == "/") ? "area.jsonp?" : "/area.jsonp?")
            }
        } else {
            if (g.isInTheSameDomain) {
                g.url += ((c == "/") ? "distance.json?" : "/distance.json?")
            } else {
                g.url += ((c == "/") ? "distance.jsonp?" : "/distance.jsonp?")
            }
        }
        var f = SuperMap.REST.ServerGeometry.fromGeometry(h);
        if (!f) {
            return
        }
        e = f.parts[0];
        d = f.points.splice(0, e);
        g.request({
            method: "GET",
            params: {
                point2Ds: SuperMap.Util.toJSON(d),
                unit: i.unit
            },
            scope: g,
            success: g.measureComplete,
            failure: g.measureError
        })
    },
    measureComplete: function(c) {
        var e = this
          , d = null
          , a = null;
        c = SuperMap.Util.transformResult(c);
        a = SuperMap.REST.MeasureResult.fromJson(c);
        e.lastResult = a;
        d = new SuperMap.REST.MeasureEventArgs(a,c);
        e.events.triggerEvent("processCompleted", d)
    },
    measureError: function(c) {
        var f = this
          , e = null
          , a = null
          , d = null;
        c = SuperMap.Util.transformResult(c);
        e = c.error;
        if (!e) {
            return
        }
        a = SuperMap.ServiceException.fromJson(e);
        d = new SuperMap.ServiceFailedEventArgs(a,c);
        f.events.triggerEvent("processFailed", d)
    },
    CLASS_NAME: "SuperMap.REST.MeasureService"
});
SuperMap.REST.MapServiceResult = SuperMap.Class({
    scale: null,
    bounds: null,
    viewBounds: null,
    viewer: null,
    coordUnit: null,
    datumAxis: null,
    initialize: function(a) {
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        var a = this;
        a.scale = null;
        a.bounds = null;
        a.viewBounds = null;
        a.viewer = null;
        a.coordUnit = null;
        a.datumAxis = null
    },
    CLASS_NAME: "SuperMap.REST.MapServiceResult"
});
SuperMap.REST.MapServiceResult.fromJson = function(a) {
    if (!a) {
        return
    }
    if (!a.prjCoordSys.coordSystem) {
        datumAxis = null
    } else {
        var c = a.prjCoordSys.coordSystem;
        datumAxis = c.datum.spheroid.axis
    }
    return new SuperMap.REST.MapServiceResult({
        scale: a.scale,
        bounds: a.bounds,
        viewBounds: a.viewBounds,
        viewer: a.viewer,
        coordUnit: a.prjCoordSys.coordUnit,
        datumAxis: datumAxis
    })
}
;
SuperMap.REST.MapServiceEventArgs = SuperMap.Class(SuperMap.ServiceEventArgs, {
    result: null,
    initialize: function(a, d) {
        SuperMap.ServiceEventArgs.prototype.initialize.apply(this, [d]);
        var c = this;
        c.result = a
    },
    destroy: function() {
        SuperMap.ServiceEventArgs.prototype.destroy.apply(this);
        var a = this;
        if (a.result) {
            a.result.destroy();
            a.result = null
        }
    },
    CLASS_NAME: "SuperMap.REST.MapServiceEventArgs"
});
SuperMap.REST.MapService = SuperMap.Class(SuperMap.ServiceBase, {
    EVENT_TYPES: ["processCompleted", "processFailed"],
    events: null,
    eventListeners: null,
    projection: null,
    lastResult: null,
    initialize: function(d, c) {
        SuperMap.ServiceBase.prototype.initialize.apply(this, arguments);
        if (c) {
            SuperMap.Util.extend(this, c)
        }
        var e = this;
        e.events = new SuperMap.Events(e,null,e.EVENT_TYPES,true);
        e.eventListeners && e.events.on(e.eventListeners);
        e.url += e.isInTheSameDomain ? ".json" : ".jsonp";
        if (e.projection) {
            if (typeof e.projection == "string") {
                e.projection = new SuperMap.Projection(e.projection)
            }
            var a = e.projection.getCode().split(":");
            if (a instanceof Array && a.length == 2) {
                e.url += '?prjCoordSys={"epsgCode":' + a[1] + "}"
            }
        }
    },
    destroy: function() {
        SuperMap.ServiceBase.prototype.destroy.apply(this, arguments);
        var a = this;
        a.EVENT_TYPES = null;
        if (a.events) {
            a.events.un(a.eventListeners);
            a.events.listeners = null;
            a.events.destroy();
            a.events = null;
            a.eventListeners = null
        }
        if (a.lastResult) {
            a.lastResult.destroy();
            a.lastResult = null
        }
    },
    processAsync: function() {
        var c = this;
        if (typeof Windows === "undefined") {
            var a = {
                method: "GET",
                scope: c,
                success: c.getMapStatusCompleted,
                failure: c.getMapStatusError
            };
            c.request(a)
        } else {
            c.url = c.url.replace(/.jsonp/, ".json");
            var d = c.url;
            if (SuperMap.Credential.CREDENTIAL) {
                d += d.indexOf("?") > -1 ? "&" : "?";
                d += SuperMap.Credential.CREDENTIAL.getUrlParameters()
            }
            WinJS.xhr({
                url: d,
                type: "GET"
            }).then(function(e) {
                c.getMapStatusCompleted(e)
            }, function(e) {
                c.getMapStatusError(e)
            })
        }
    },
    getMapStatusCompleted: function(a) {
        var e = this
          , d = null;
        a = SuperMap.Util.transformResult(a);
        var c = SuperMap.REST.MapServiceResult.fromJson(a);
        e.lastResult = c;
        d = new SuperMap.REST.MapServiceEventArgs(c,a);
        e.events && e.events.triggerEvent("processCompleted", d)
    },
    getMapStatusError: function(c) {
        var f = this
          , e = null
          , a = null
          , d = null;
        c = SuperMap.Util.transformResult(c);
        e = c.error;
        if (!e) {
            return
        }
        a = SuperMap.ServiceException.fromJson(e);
        d = new SuperMap.ServiceFailedEventArgs(a,c);
        f.events.triggerEvent("processFailed", d)
    },
    CLASS_NAME: "SuperMap.REST.MapService"
});
SuperMap.REST.QueryParameters = SuperMap.Class({
    customParams: null,
    expectCount: 100000,
    networkType: SuperMap.REST.GeometryType.LINE,
    queryOption: SuperMap.REST.QueryOption.ATTRIBUTEANDGEOMETRY,
    queryParams: null,
    startRecord: 0,
    holdTime: 10,
    returnCustomResult: false,
    initialize: function(a) {
        if (!a) {
            return
        }
        SuperMap.Util.extend(this, a)
    },
    destroy: function() {
        var d = this;
        d.customParams = null;
        d.expectCount = null;
        d.networkType = null;
        d.queryOption = null;
        if (d.queryParams) {
            for (var c = 0, e = d.queryParams, a = e.length; c < a; c++) {
                e[c].destroy()
            }
            d.queryParams = null
        }
        d.startRecord = null;
        d.holdTime = null;
        d.returnCustomResult = null
    },
    CLASS_NAME: "SuperMap.REST.QueryParameters"
});
SuperMap.REST.FilterParameter = SuperMap.Class({
    attributeFilter: null,
    name: null,
    joinItems: null,
    linkItems: null,
    ids: null,
    orderBy: null,
    groupBy: null,
    fields: null,
    initialize: function(a) {
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        var f = this;
        f.attributeFilter = null;
        f.name = null;
        if (f.joinItems) {
            for (var d = 0, e = f.joinItems, a = e.length; d < a; d++) {
                e[d].destroy()
            }
            f.joinItems = null
        }
        if (f.linkItems) {
            for (var d = 0, c = f.linkItems, a = c.length; d < a; d++) {
                c[d].destroy()
            }
            f.linkItems = null
        }
        f.ids = null;
        f.orderBy = null;
        f.groupBy = null;
        f.fields = null
    },
    CLASS_NAME: "SuperMap.REST.FilterParameter"
});
SuperMap.REST.QueryBySQLParameters = SuperMap.Class(SuperMap.REST.QueryParameters, {
    returnContent: true,
    initialize: function(a) {
        SuperMap.REST.QueryParameters.prototype.initialize.apply(this, arguments);
        if (!a) {
            return
        }
        SuperMap.Util.extend(this, a)
    },
    destroy: function() {
        SuperMap.REST.QueryParameters.prototype.destroy.apply(this, arguments);
        var a = this;
        a.returnContent = null
    },
    CLASS_NAME: "SuperMap.REST.QueryBySQLParameters"
});
SuperMap.REST.QueryByBoundsParameters = SuperMap.Class(SuperMap.REST.QueryParameters, {
    returnContent: true,
    bounds: null,
    initialize: function(a) {
        SuperMap.REST.QueryParameters.prototype.initialize.apply(this, arguments);
        if (!a) {
            return
        }
        SuperMap.Util.extend(this, a)
    },
    destroy: function() {
        SuperMap.REST.QueryParameters.prototype.destroy.apply(this, arguments);
        var a = this;
        a.returnContent = null;
        if (a.bounds) {
            a.bounds = null
        }
    },
    CLASS_NAME: "SuperMap.REST.QueryByBoundsParameters"
});
SuperMap.REST.Recordset = SuperMap.Class({
    datasetName: null,
    fieldCaptions: null,
    fields: null,
    fieldTypes: null,
    features: null,
    initialize: function(a) {
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        var e = this;
        e.datasetName = null;
        e.fieldCaptions = null;
        e.fields = null;
        e.fieldTypes = null;
        if (e.features) {
            for (var c = 0, d = e.features, a = d.length; c < a; c++) {
                d[c].destroy()
            }
            e.features = null
        }
    },
    CLASS_NAME: "SuperMap.REST.Recordset"
});
SuperMap.REST.Recordset.fromJson = function(f) {
    if (!f) {
        return
    }
    var e = null
      , g = null;
    if (f.features) {
        g = [];
        for (var d = 0, c = f.features, a = c.length; d < a; d++) {
            e = SuperMap.REST.ServerFeature.fromJson(c[d]).toFeature();
            g.push(e)
        }
    }
    return new SuperMap.REST.Recordset({
        datasetName: f.datasetName,
        fieldCaptions: f.fieldCaptions,
        fields: f.fields,
        fieldTypes: f.fieldTypes,
        features: g
    })
}
;
SuperMap.REST.ResourceInfo = SuperMap.Class({
    succeed: null,
    newResourceLocation: null,
    id: null,
    initialize: function(a) {
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        var a = this;
        a.succeed = null;
        a.newResourceLocation = null;
        a.id = null
    },
    CLASS_NAME: "SuperMap.REST.ResourceInfo"
});
SuperMap.REST.ResourceInfo.fromJson = function(a) {
    if (!a) {
        return
    }
    return new SuperMap.REST.ResourceInfo({
        succeed: a.succeed,
        newResourceLocation: a.newResourceLocation,
        id: a.newResourceID
    })
}
;
SuperMap.REST.QueryResult = SuperMap.Class({
    totalCount: null,
    currentCount: null,
    customResponse: null,
    recordsets: null,
    resourceInfo: null,
    initialize: function(a) {
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        var e = this;
        e.totalCount = null;
        e.currentCount = null;
        e.customResponse = null;
        if (e.recordsets) {
            for (var d = 0, c = e.recordsets, a = c.length; d < a; d++) {
                c[d].destroy()
            }
            e.recordsets = null
        }
        if (e.resourceInfo) {
            e.resourceInfo.destroy();
            e.resourceInfo = null
        }
    },
    CLASS_NAME: "SuperMap.REST.QueryResult"
});
SuperMap.REST.QueryResult.fromJson = function(e) {
    if (!e) {
        return
    }
    var c = null;
    if (e.recordsets) {
        c = [];
        for (var d = 0, f = e.recordsets, a = f.length; d < a; d++) {
            c.push(SuperMap.REST.Recordset.fromJson(f[d]))
        }
    }
    return new SuperMap.REST.QueryResult({
        totalCount: e.totalCount,
        currentCount: e.currentCount,
        customResponse: e.customResponse,
        recordsets: c,
        resourceInfo: e.resourceInfo
    })
}
;
SuperMap.REST.QueryEventArgs = SuperMap.Class(SuperMap.ServiceEventArgs, {
    result: null,
    initialize: function(a, d) {
        SuperMap.ServiceEventArgs.prototype.initialize.apply(this, [d]);
        var c = this;
        c.result = a
    },
    destroy: function() {
        SuperMap.ServiceEventArgs.prototype.destroy.apply(this);
        var a = this;
        if (a.result) {
            a.result.destroy();
            a.result = null
        }
    },
    CLASS_NAME: "SuperMap.REST.QueryEventArgs"
});
SuperMap.REST.QueryService = SuperMap.Class(SuperMap.ServiceBase, {
    EVENT_TYPES: ["processCompleted", "processFailed"],
    events: null,
    eventListeners: null,
    lastResult: null,
    returnContent: false,
    initialize: function(d, c) {
        SuperMap.ServiceBase.prototype.initialize.apply(this, [d]);
        if (c) {
            SuperMap.Util.extend(this, c)
        }
        var e = this, a;
        e.events = new SuperMap.Events(e,null,e.EVENT_TYPES,true);
        if (e.eventListeners instanceof Object) {
            e.events.on(e.eventListeners)
        }
        a = e.url.substr(e.url.length - 1, 1);
        if (e.isInTheSameDomain) {
            e.url += (a == "/") ? "queryResults.json?" : "/queryResults.json?"
        } else {
            e.url += (a == "/") ? "queryResults.jsonp?" : "/queryResults.jsonp?"
        }
    },
    destroy: function() {
        SuperMap.ServiceBase.prototype.destroy.apply(this, arguments);
        var a = this;
        a.EVENT_TYPES = null;
        if (a.events) {
            a.events.destroy();
            a.events = null
        }
        if (a.eventListeners) {
            a.eventListeners = null
        }
        if (a.lastResult) {
            a.lastResult.destroy();
            a.lastResult = null
        }
        a.returnContent = null
    },
    processAsync: function(e) {
        if (!e) {
            return
        }
        var c = this
          , a = null
          , d = null;
        c.returnContent = e.returnContent;
        d = c.getJsonParameters(e);
        if (c.returnContent) {
            c.url += "returnContent=" + c.returnContent
        } else {
            a = e.returnCustomResult;
            if (a) {
                c.url += "returnCustomResult=" + a
            }
        }
        c.request({
            method: "POST",
            data: d,
            scope: c,
            success: c.queryComplete,
            failure: c.queryError
        })
    },
    queryComplete: function(a) {
        var d = this
          , c = null
          , e = null;
        a = SuperMap.Util.transformResult(a);
        if (d.returnContent) {
            e = SuperMap.REST.QueryResult.fromJson(a)
        } else {
            e = new SuperMap.REST.QueryResult();
            if (a.customResult) {
                e.customResponse = new SuperMap.Bounds(a.customResult.left,a.customResult.bottom,a.customResult.right,a.customResult.top)
            }
            e.resourceInfo = SuperMap.REST.ResourceInfo.fromJson(a)
        }
        d.lastResult = e;
        c = new SuperMap.REST.QueryEventArgs(e,a);
        d.events.triggerEvent("processCompleted", c)
    },
    queryError: function(c) {
        var f = this
          , e = null
          , a = null
          , d = null;
        c = SuperMap.Util.transformResult(c);
        e = c.error;
        if (!e) {
            return
        }
        a = SuperMap.ServiceException.fromJson(e);
        d = new SuperMap.ServiceFailedEventArgs(a,c);
        f.events.triggerEvent("processFailed", d)
    },
    getQueryParameters: function(a) {
        return new SuperMap.REST.QueryParameters({
            customParams: a.customParams,
            expectCount: a.expectCount,
            networkType: a.networkType,
            queryOption: a.queryOption,
            queryParams: a.queryParams,
            startRecord: a.startRecord,
            holdTime: a.holdTime
        })
    },
    CLASS_NAME: "SuperMap.REST.QueryService"
});
SuperMap.REST.QueryBySQLService = SuperMap.Class(SuperMap.REST.QueryService, {
    initialize: function(c, a) {
        SuperMap.REST.QueryService.prototype.initialize.apply(this, arguments)
    },
    destroy: function() {
        SuperMap.REST.QueryService.prototype.destroy.apply(this, arguments)
    },
    getJsonParameters: function(e) {
        var c = this
          , d = ""
          , a = null;
        a = c.getQueryParameters(e);
        d += "'queryMode':'SqlQuery','queryParameters':";
        d += SuperMap.Util.toJSON(a);
        d = "{" + d + "}";
        return d
    },
    CLASS_NAME: "SuperMap.REST.QueryBySQLService"
});
SuperMap.REST.QueryByBoundsService = SuperMap.Class(SuperMap.REST.QueryService, {
    initialize: function(c, a) {
        SuperMap.REST.QueryService.prototype.initialize.apply(this, arguments)
    },
    destroy: function() {
        SuperMap.REST.QueryService.prototype.destroy.apply(this, arguments)
    },
    getJsonParameters: function(f) {
        var d = this
          , e = ""
          , a = null
          , c = f.bounds;
        a = d.getQueryParameters(f);
        e += "'queryMode':'BoundsQuery','queryParameters':";
        e += SuperMap.Util.toJSON(a);
        e += ",'bounds': {'rightTop':{'y':" + c.top + ",'x':" + c.right + "},'leftBottom':{'y':" + c.bottom + ",'x':" + c.left + "}}";
        e = "{" + e + "}";
        return e
    },
    CLASS_NAME: "SuperMap.REST.QueryByBoundsService"
});
SuperMap.REST.QueryByGeometryParameters = SuperMap.Class(SuperMap.REST.QueryParameters, {
    returnContent: true,
    geometry: null,
    spatialQueryMode: SuperMap.REST.SpatialQueryMode.INTERSECT,
    initialize: function(a) {
        SuperMap.REST.QueryParameters.prototype.initialize.apply(this, arguments);
        if (!a) {
            return
        }
        SuperMap.Util.extend(this, a)
    },
    destroy: function() {
        var a = this;
        SuperMap.REST.QueryParameters.prototype.destroy.apply(a, arguments);
        a.returnContent = null;
        a.geometry = null;
        a.spatialQueryMode = null
    },
    CLASS_NAME: "SuperMap.REST.QueryByGeometryParameters"
});
SuperMap.REST.QueryByGeometryService = SuperMap.Class(SuperMap.REST.QueryService, {
    initialize: function(c, a) {
        SuperMap.REST.QueryService.prototype.initialize.apply(this, arguments)
    },
    destroy: function() {
        SuperMap.REST.QueryService.prototype.destroy.apply(this, arguments)
    },
    getJsonParameters: function(e) {
        var c = this
          , d = ""
          , a = null;
        geometry = e.geometry;
        sg = SuperMap.REST.ServerGeometry.fromGeometry(geometry);
        a = c.getQueryParameters(e);
        d += "'queryMode':'SpatialQuery','queryParameters':";
        d += SuperMap.Util.toJSON(a) + ",'geometry':" + SuperMap.Util.toJSON(sg) + ",'spatialQueryMode':" + SuperMap.Util.toJSON(e.spatialQueryMode);
        d = "{" + d + "}";
        return d
    },
    CLASS_NAME: "SuperMap.REST.QueryByGeometryService"
});
SuperMap.REST.QueryByDistanceParameters = SuperMap.Class(SuperMap.REST.QueryParameters, {
    distance: 0,
    geometry: null,
    isNearest: null,
    returnContent: true,
    initialize: function(a) {
        SuperMap.REST.QueryParameters.prototype.initialize.apply(this, arguments);
        if (!a) {
            return
        }
        SuperMap.Util.extend(this, a)
    },
    destroy: function() {
        SuperMap.REST.QueryParameters.prototype.destroy.apply(this, arguments);
        var a = this;
        a.returnContent = null;
        a.distance = null;
        a.isNearest = null;
        if (a.geometry) {
            a.geometry.destroy();
            a.geometry = null
        }
    },
    CLASS_NAME: "SuperMap.REST.QueryByDistanceParameters"
});
SuperMap.REST.QueryByDistanceService = SuperMap.Class(SuperMap.REST.QueryService, {
    initialize: function(c, a) {
        SuperMap.REST.QueryService.prototype.initialize.apply(this, arguments)
    },
    destroy: function() {
        SuperMap.REST.QueryService.prototype.destroy.apply(this, arguments)
    },
    getJsonParameters: function(f) {
        var d = this
          , e = ""
          , a = null
          , a = d.getQueryParameters(f);
        var c = SuperMap.REST.ServerGeometry.fromGeometry(f.geometry);
        e += f.isNearest ? "'queryMode':'FindNearest','queryParameters':" : "'queryMode':'DistanceQuery','queryParameters':";
        e += SuperMap.Util.toJSON(a);
        e += ",'geometry':" + SuperMap.Util.toJSON(c) + ",'distance':" + f.distance;
        e = "{" + e + "}";
        return e
    },
    CLASS_NAME: "SuperMap.REST.QueryByDistanceService"
});
SuperMap.REST.ChartQueryFilterParameter = SuperMap.Class({
    isQueryPoint: null,
    isQueryLine: null,
    isQueryRegion: null,
    attributeFilter: null,
    chartFeatureInfoSpecCode: null,
    initialize: function(a) {
        if (!a) {
            return
        }
        SuperMap.Util.extend(this, a)
    },
    destroy: function() {
        var a = this;
        a.isQueryPoint = null;
        a.isQueryLine = null;
        a.isQueryRegion = null;
        a.attributeFilter = null;
        a.chartFeatureInfoSpecCode = null
    },
    toJson: function() {
        var a = "";
        a += '"isQueryPoint":' + this.isQueryPoint + ",";
        a += '"isQueryLine":' + this.isQueryLine + ",";
        a += '"isQueryRegion":' + this.isQueryRegion + ",";
        if (this.attributeFilter) {
            a += '"attributeFilter": "' + this.attributeFilter + '",'
        }
        a += '"chartFeatureInfoSpecCode":' + this.chartFeatureInfoSpecCode;
        a = "{" + a + "}";
        return a
    },
    CLASS_NAME: "SuperMap.REST.ChartQueryFilterParameter"
});
SuperMap.REST.ChartQueryParameters = SuperMap.Class({
    queryMode: null,
    bounds: null,
    chartLayerNames: null,
    chartQueryFilterParameters: null,
    returnContent: true,
    startRecord: 0,
    expectCount: null,
    initialize: function(a) {
        if (!a) {
            return
        }
        SuperMap.Util.extend(this, a)
    },
    destroy: function() {
        var a = this;
        a.queryMode = null;
        a.bounds = null;
        a.chartLayerNames = null;
        a.chartQueryFilterParameters = null;
        a.returnContent = true;
        a.startRecord = 0;
        a.expectCount = null
    },
    getVariablesJson: function() {
        var m = "";
        m += '"queryMode":"' + this.queryMode + '",';
        if (this.chartLayerNames && this.chartLayerNames.length) {
            var k = [];
            var a = this.chartLayerNames.length;
            for (var d = 0; d < a; d++) {
                k.push('"' + this.chartLayerNames[d] + '"')
            }
            var h = "[" + k.join(",") + "]";
            m += '"chartLayerNames":' + h + ","
        }
        if (this.queryMode == "ChartBoundsQuery" && this.bounds) {
            m += '"bounds":{"leftBottom":{"x":' + this.bounds.left + ',"y":' + this.bounds.bottom + '},"rightTop":{"x":' + this.bounds.right + ',"y":' + this.bounds.top + "}},"
        }
        if (this.chartQueryFilterParameters && this.chartQueryFilterParameters.length) {
            var g = [];
            var f = this.chartQueryFilterParameters.length;
            for (var c = 0; c < f; c++) {
                var l = new SuperMap.REST.ChartQueryFilterParameter();
                l = this.chartQueryFilterParameters[c];
                g.push(l.toJson())
            }
            var e = "[" + g.join(",") + "]";
            e = '"chartQueryParams":' + e + ",";
            e += '"startRecord":' + this.startRecord + ",";
            e += '"expectCount":' + this.expectCount;
            e = "{" + e + "}";
            m += '"chartQueryParameters":' + e
        }
        m = "{" + m + "}";
        return m
    },
    CLASS_NAME: "SuperMap.REST.ChartQueryParameters"
});
SuperMap.REST.ChartQueryService = SuperMap.Class(SuperMap.ServiceBase, {
    EVENT_TYPES: ["processCompleted", "processFailed"],
    events: null,
    eventListeners: null,
    lastResult: null,
    returnContent: null,
    initialize: function(d, c) {
        SuperMap.ServiceBase.prototype.initialize.apply(this, [d]);
        if (c) {
            SuperMap.Util.extend(this, c)
        }
        var e = this, a;
        e.events = new SuperMap.Events(e,null,e.EVENT_TYPES,true);
        if (e.eventListeners instanceof Object) {
            e.events.on(e.eventListeners)
        }
        a = e.url.substr(e.url.length - 1, 1);
        if (e.isInTheSameDomain) {
            e.url += (a == "/") ? "queryResults.json?" : "/queryResults.json?"
        } else {
            e.url += (a == "/") ? "queryResults.jsonp?" : "/queryResults.jsonp?"
        }
    },
    destroy: function() {
        SuperMap.ServiceBase.prototype.destroy.apply(this, arguments);
        var a = this;
        a.EVENT_TYPES = null;
        if (a.events) {
            a.events.destroy();
            a.events = null
        }
        if (a.eventListeners) {
            a.eventListeners = null
        }
        if (a.lastResult) {
            a.lastResult.destroy();
            a.lastResult = null
        }
        a.returnContent = null
    },
    processAsync: function(d) {
        if (!d) {
            return
        }
        var a = this, c;
        a.returnContent = d.returnContent;
        c = d.getVariablesJson();
        if (a.returnContent) {
            a.url += "returnContent=" + a.returnContent
        }
        a.request({
            method: "POST",
            data: c,
            scope: a,
            success: a.queryComplete,
            failure: a.queryError
        })
    },
    queryComplete: function(a) {
        var d = this
          , c = null
          , e = null;
        a = SuperMap.Util.transformResult(a);
        if (d.returnContent) {
            e = SuperMap.REST.QueryResult.fromJson(a)
        } else {
            e = new SuperMap.REST.QueryResult();
            if (a.customResult) {
                e.customResponse = new SuperMap.Bounds(a.customResult.left,a.customResult.bottom,a.customResult.right,a.customResult.top)
            }
            e.resourceInfo = SuperMap.REST.ResourceInfo.fromJson(a)
        }
        d.lastResult = e;
        c = new SuperMap.REST.QueryEventArgs(e,a);
        d.events.triggerEvent("processCompleted", c)
    },
    queryError: function(c) {
        var f = this
          , e = null
          , a = null
          , d = null;
        c = SuperMap.Util.transformResult(c);
        e = c.error;
        if (!e) {
            return
        }
        a = SuperMap.ServiceException.fromJson(e);
        d = new SuperMap.ServiceFailedEventArgs(a,c);
        f.events.triggerEvent("processFailed", d)
    },
    getQueryParameters: function(a) {
        return new SuperMap.REST.QueryParameters({
            queryMode: a.queryMode,
            bounds: a.bounds,
            chartLayerNames: a.chartLayerNames,
            chartQueryFilterParameters: a.chartQueryFilterParameters,
            returnContent: a.returnContent
        })
    },
    CLASS_NAME: "SuperMap.REST.ChartQueryService"
});
SuperMap.REST.ServerColor = SuperMap.Class({
    red: 255,
    green: 0,
    blue: 0,
    initialize: function(d, c, a) {
        if (!d && d != 0) {
            this.red = 255
        } else {
            this.red = d
        }
        if (!c && c != 0) {
            this.green = 0
        } else {
            this.green = c
        }
        if (!a && a != 0) {
            this.blue = 0
        } else {
            this.blue = a
        }
    },
    destroy: function() {
        var a = this;
        a.red = null;
        a.green = null;
        a.blue = null
    },
    CLASS_NAME: "SuperMap.REST.ServerColor"
});
SuperMap.REST.ServerColor.fromJson = function(d) {
    if (!d) {
        return
    }
    var c = new SuperMap.REST.ServerColor();
    var f = 255;
    if (d.red !== null) {
        f = Number(d.red)
    }
    c.red = f;
    var e = 0;
    if (d.green !== null) {
        e = Number(d.green)
    }
    c.green = e;
    var a = 0;
    if (d.blue !== null) {
        a = Number(d.blue)
    }
    c.blue = a;
    return c
}
;
SuperMap.REST.ServerStyle = SuperMap.Class({
    fillBackColor: null,
    fillBackOpaque: false,
    fillForeColor: null,
    fillGradientMode: null,
    fillGradientAngle: 0,
    fillGradientOffsetRatioX: 0,
    fillGradientOffsetRatioY: 0,
    fillOpaqueRate: 100,
    fillSymbolID: 0,
    lineColor: null,
    lineSymbolID: 0,
    lineWidth: 1,
    markerAngle: 0,
    markerSize: 1,
    markerSymbolID: -1,
    initialize: function(a) {
        var c = this;
        c.fillBackColor = new SuperMap.REST.ServerColor(255,255,255);
        c.fillForeColor = new SuperMap.REST.ServerColor(255,0,0);
        c.lineColor = new SuperMap.REST.ServerColor(0,0,0);
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        var a = this;
        if (a.fillBackColor) {
            a.fillBackColor.destroy();
            a.fillBackColor = null
        }
        a.fillBackOpaque = null;
        if (a.fillForeColor) {
            a.fillForeColor.destroy();
            a.fillForeColor = null
        }
        a.fillGradientMode = null;
        a.fillGradientAngle = null;
        a.fillGradientOffsetRatioX = null;
        a.fillGradientOffsetRatioY = null;
        a.fillOpaqueRate = null;
        a.fillSymbolID = null;
        if (a.lineColor) {
            a.lineColor.destroy();
            a.lineColor = null
        }
        a.lineSymbolID = null;
        a.lineWidth = null;
        a.markerAngle = null;
        a.markerSize = null;
        a.markerSymbolID = null
    },
    toServerJSONObject: function() {
        var a = {};
        a = SuperMap.Util.copyAttributes(a, this);
        return a
    },
    CLASS_NAME: "SuperMap.REST.ServerStyle"
});
SuperMap.REST.ServerStyle.fromJson = function(a) {
    if (!a) {
        return
    }
    return new SuperMap.REST.ServerStyle({
        fillBackColor: SuperMap.REST.ServerColor.fromJson(a.fillBackColor),
        fillBackOpaque: a.fillBackOpaque,
        fillForeColor: SuperMap.REST.ServerColor.fromJson(a.fillForeColor),
        fillGradientMode: a.fillGradientMode,
        fillGradientAngle: a.fillGradientAngle,
        fillGradientOffsetRatioX: a.fillGradientOffsetRatioX,
        fillGradientOffsetRatioY: a.fillGradientOffsetRatioY,
        fillOpaqueRate: a.fillOpaqueRate,
        fillSymbolID: a.fillSymbolID,
        lineColor: SuperMap.REST.ServerColor.fromJson(a.lineColor),
        lineSymbolID: a.lineSymbolID,
        lineWidth: a.lineWidth,
        markerAngle: a.markerAngle,
        markerSize: a.markerSize,
        markerSymbolID: a.markerSymbolID
    })
}
;
SuperMap.REST.ServerTextStyle = SuperMap.Class({
    align: SuperMap.REST.TextAlignment.BASELINECENTER,
    backColor: null,
    foreColor: null,
    backOpaque: false,
    sizeFixed: true,
    fontHeight: 6,
    fontWidth: 0,
    fontWeight: 400,
    fontName: "Times New Roman",
    bold: false,
    italic: false,
    italicAngle: 0,
    shadow: false,
    strikeout: false,
    outline: false,
    opaqueRate: 0,
    underline: false,
    rotation: 0,
    initialize: function(a) {
        var c = this;
        c.backColor = new SuperMap.REST.ServerColor(255,255,255);
        c.foreColor = new SuperMap.REST.ServerColor(0,0,0);
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        var a = this;
        a.align = null;
        if (a.backColor) {
            a.backColor.destroy();
            a.backColor = null
        }
        if (a.foreColor) {
            a.foreColor.destroy();
            a.foreColor = null
        }
        a.backOpaque = null;
        a.sizeFixed = null;
        a.fontHeight = null;
        a.fontWidth = null;
        a.fontWeight = null;
        a.fontName = null;
        a.bold = null;
        a.italic = null;
        a.italicAngle = null;
        a.shadow = null;
        a.strikeout = null;
        a.outline = null;
        a.opaqueRate = null;
        a.underline = null;
        a.rotation = null
    },
    CLASS_NAME: "SuperMap.REST.ServerTextStyle"
});
SuperMap.REST.ServerTextStyle.fromObj = function(c) {
    var a = new SuperMap.REST.ServerTextStyle(c);
    SuperMap.Util.copy(a, c);
    a.backColor = SuperMap.REST.ServerColor.fromJson(c.backColor);
    a.foreColor = SuperMap.REST.ServerColor.fromJson(c.foreColor);
    return a
}
;
SuperMap.REST.Theme = SuperMap.Class({
    memoryData: null,
    type: null,
    initialize: function(c, a) {
        if (!c) {
            return false
        }
        this.type = c;
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        var a = this;
        if (a.memoryData) {
            a.memoryData.destroy();
            a.memoryData = null
        }
        a.type = null
    },
    toServerJSONObject: function() {
        return
    },
    CLASS_NAME: "SuperMap.REST.Theme"
});
SuperMap.REST.ThemeFlow = SuperMap.Class({
    flowEnabled: false,
    leaderLineDisplayed: false,
    leaderLineStyle: null,
    initialize: function(a) {
        var c = this;
        c.leaderLineStyle = new SuperMap.REST.ServerStyle();
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        var a = this;
        a.flowEnabled = null;
        a.leaderLineDisplayed = null;
        if (a.leaderLineStyle) {
            a.leaderLineStyle.destroy();
            a.leaderLineStyle = null
        }
    },
    CLASS_NAME: "SuperMap.REST.ThemeFlow"
});
SuperMap.REST.ThemeFlow.fromObj = function(c) {
    if (!c) {
        return
    }
    var a = new SuperMap.REST.ThemeFlow();
    SuperMap.Util.copy(a, c);
    a.leaderLineStyle = SuperMap.REST.ServerStyle.fromJson(c.leaderLineStyle);
    return a
}
;
SuperMap.REST.ThemeGraphAxes = SuperMap.Class({
    axesColor: null,
    axesDisplayed: false,
    axesGridDisplayed: false,
    axesTextDisplayed: false,
    axesTextStyle: null,
    initialize: function(a) {
        var c = this;
        c.axesColor = new SuperMap.REST.ServerColor(0,0,0);
        c.axesTextStyle = new SuperMap.REST.ServerTextStyle();
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        var a = this;
        if (a.axesColor) {
            a.axesColor.destroy();
            a.axesColor = null
        }
        a.axesDisplayed = null;
        a.axesGridDisplayed = null;
        a.axesTextDisplayed = null;
        if (a.axesTextStyle) {
            a.axesTextStyle.destroy();
            a.axesTextStyle = null
        }
    },
    CLASS_NAME: "SuperMap.REST.ThemeGraphAxes"
});
SuperMap.REST.ThemeGraphAxes.fromObj = function(c) {
    if (!c) {
        return
    }
    var a = new SuperMap.REST.ThemeGraphAxes();
    SuperMap.Util.copy(a, c);
    a.axesColor = SuperMap.REST.ServerColor.fromJson(c.axesColor);
    a.axesTextStyle = SuperMap.REST.ServerTextStyle.fromObj(c.axesTextStyle);
    return a
}
;
SuperMap.REST.ThemeGraphSize = SuperMap.Class({
    maxGraphSize: 0,
    minGraphSize: 0,
    initialize: function(a) {
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        var a = this;
        a.maxGraphSize = null;
        a.minGraphSize = null
    },
    CLASS_NAME: "SuperMap.REST.ThemeGraphSize"
});
SuperMap.REST.ThemeGraphSize.fromObj = function(c) {
    var a = new SuperMap.REST.ThemeGraphSize();
    SuperMap.Util.copy(a, c);
    return a
}
;
SuperMap.REST.ThemeGraphText = SuperMap.Class({
    graphTextDisplayed: false,
    graphTextFormat: SuperMap.REST.ThemeGraphTextFormat.CAPTION,
    graphTextStyle: null,
    initialize: function(a) {
        var c = this;
        c.graphTextStyle = new SuperMap.REST.ServerTextStyle();
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        var a = this;
        a.graphTextDisplayed = null;
        a.graphTextFormat = null;
        if (a.graphTextStyle) {
            a.graphTextStyle.destroy();
            a.graphTextStyle = null
        }
    },
    CLASS_NAME: "SuperMap.REST.ThemeGraphText"
});
SuperMap.REST.ThemeGraphText.fromObj = function(c) {
    var a = new SuperMap.REST.ThemeGraphText();
    SuperMap.Util.copy(a, c);
    a.graphTextStyle = SuperMap.REST.ServerTextStyle.fromObj(c.graphTextStyle);
    return a
}
;
SuperMap.REST.ThemeGraphItem = SuperMap.Class({
    caption: null,
    graphExpression: null,
    memoryDoubleValues: null,
    uniformStyle: null,
    initialize: function(a) {
        var c = this;
        c.uniformStyle = new SuperMap.REST.ServerStyle();
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        var a = this;
        a.caption = null;
        a.graphExpression = null;
        a.memoryDoubleValues = null;
        a.uniformStyle = null
    },
    CLASS_NAME: "SuperMap.REST.ThemeGraphItem"
});
SuperMap.REST.ThemeGraphItem.fromObj = function(c) {
    if (!c) {
        return
    }
    var a = new SuperMap.REST.ThemeGraphItem();
    SuperMap.Util.copy(a, c);
    a.uniformStyle = SuperMap.REST.ServerStyle.fromJson(c.uniformStyle);
    return a
}
;
SuperMap.REST.ThemeOffset = SuperMap.Class({
    offsetFixed: false,
    offsetX: "0.0",
    offsetY: "0.0",
    initialize: function(a) {
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        var a = this;
        a.offsetFixed = null;
        a.offsetX = null;
        a.offsetY = null
    },
    CLASS_NAME: "SuperMap.REST.ThemeOffset"
});
SuperMap.REST.ThemeOffset.fromObj = function(c) {
    if (!c) {
        return
    }
    var a = new SuperMap.REST.ThemeOffset();
    SuperMap.Util.copy(a, c);
    return a
}
;
SuperMap.REST.ThemeGraph = SuperMap.Class(SuperMap.REST.Theme, {
    barWidth: 0,
    flow: null,
    graduatedMode: SuperMap.REST.GraduatedMode.Constant,
    graphAxes: null,
    graphSize: null,
    graphSizeFixed: false,
    graphText: null,
    graphType: SuperMap.REST.ThemeGraphType.AREA,
    items: null,
    memoryKeys: null,
    negativeDisplayed: false,
    offset: null,
    overlapAvoided: true,
    roseAngle: 0,
    startAngle: 0,
    initialize: function(a) {
        var c = this;
        c.flow = new SuperMap.REST.ThemeFlow();
        c.graphAxes = new SuperMap.REST.ThemeGraphAxes();
        c.graphSize = new SuperMap.REST.ThemeGraphSize();
        c.graphText = new SuperMap.REST.ThemeGraphText();
        c.offset = new SuperMap.REST.ThemeOffset();
        SuperMap.REST.Theme.prototype.initialize.apply(this, ["GRAPH", a]);
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        SuperMap.REST.Theme.prototype.destroy.apply(this, arguments);
        var e = this;
        e.barWidth = null;
        if (e.flow) {
            e.flow.destroy();
            e.flow = null
        }
        e.graduatedMode = null;
        if (e.graphAxes) {
            e.graphAxes.destroy();
            e.graphAxes = null
        }
        if (e.graphSize) {
            e.graphSize.destroy();
            e.graphSize = null
        }
        e.graphSizeFixed = null;
        if (e.graphText) {
            e.graphText.destroy();
            e.graphText = null
        }
        e.graphType = null;
        if (e.items) {
            for (var d = 0, c = e.items, a = c.length; d < a; d++) {
                c[d].destroy()
            }
            e.items = null
        }
        e.memoryKeys = null;
        e.negativeDisplayed = null;
        if (e.offset) {
            e.offset.destroy();
            e.offset = null
        }
        e.overlapAvoided = null;
        e.roseAngle = null;
        e.startAngle = null
    },
    toJSON: function() {
        return SuperMap.Util.toJSON(this.toServerJSONObject())
    },
    toServerJSONObject: function() {
        var a = new Object();
        a.type = this.type;
        if (this.graphText) {
            a.graphTextDisplayed = this.graphText.graphTextDisplayed;
            a.graphTextFormat = this.graphText.graphTextFormat;
            a.graphTextStyle = this.graphText.graphTextStyle
        }
        if (this.flow) {
            a.flowEnabled = this.flow.flowEnabled;
            a.leaderLineDisplayed = this.flow.leaderLineDisplayed;
            a.leaderLineStyle = this.flow.leaderLineStyle
        }
        if (this.graphAxes) {
            a.axesColor = this.graphAxes.axesColor;
            a.axesDisplayed = this.graphAxes.axesDisplayed;
            a.axesGridDisplayed = this.graphAxes.axesGridDisplayed;
            a.axesTextDisplayed = this.graphAxes.axesTextDisplayed;
            a.axesTextStyle = this.graphAxes.axesTextStyle
        }
        if (this.graphSize) {
            a.maxGraphSize = this.graphSize.maxGraphSize;
            a.minGraphSize = this.graphSize.minGraphSize
        }
        if (this.offset) {
            a.offsetFixed = this.offset.offsetFixed;
            a.offsetX = this.offset.offsetX;
            a.offsetY = this.offset.offsetY
        }
        a.barWidth = this.barWidth;
        a.graduatedMode = this.graduatedMode;
        a.graphSizeFixed = this.graphSizeFixed;
        a.graphType = this.graphType;
        a.items = this.items;
        a.memoryKeys = this.memoryKeys;
        a.negativeDisplayed = this.negativeDisplayed;
        a.overlapAvoided = this.overlapAvoided;
        a.roseAngle = this.roseAngle;
        a.startAngle = this.startAngle;
        return a
    },
    CLASS_NAME: "SuperMap.REST.ThemeGraph"
});
SuperMap.REST.ThemeGraph.fromObj = function(f) {
    var e = new SuperMap.REST.ThemeGraph();
    var c = f.items;
    var a = c ? c.length : 0;
    SuperMap.Util.copy(e, f);
    e.items = [];
    e.flow = SuperMap.REST.ThemeFlow.fromObj(f);
    e.graphAxes = SuperMap.REST.ThemeGraphAxes.fromObj(f);
    e.graphSize = SuperMap.REST.ThemeGraphSize.fromObj(f);
    e.graphText = SuperMap.REST.ThemeGraphText.fromObj(f);
    e.offset = SuperMap.REST.ThemeOffset.fromObj(f);
    for (var d = 0; d < a; d++) {
        e.items.push(SuperMap.REST.ThemeGraphItem.fromObj(c[d]))
    }
    return e
}
;
SuperMap.REST.ThemeRangeItem = SuperMap.Class({
    caption: null,
    end: 0,
    start: 0,
    style: null,
    visible: true,
    initialize: function(a) {
        var c = this;
        c.style = new SuperMap.REST.ServerStyle();
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        var a = this;
        a.caption = null;
        a.end = null;
        a.start = null;
        if (a.style) {
            a.style.destroy();
            a.style = null
        }
        a.visible = null
    },
    toServerJSONObject: function() {
        var a = {};
        a = SuperMap.Util.copyAttributes(a, this);
        if (a.style) {
            if (a.style.toServerJSONObject) {
                a.style = a.style.toServerJSONObject()
            }
        }
        return a
    },
    CLASS_NAME: "SuperMap.REST.ThemeRangeItem"
});
SuperMap.REST.ThemeRangeItem.fromObj = function(c) {
    if (!c) {
        return
    }
    var a = new SuperMap.REST.ThemeRangeItem();
    SuperMap.Util.copy(a, c);
    a.style = SuperMap.REST.ServerStyle.fromJson(c.style);
    return a
}
;
SuperMap.REST.ThemeRange = SuperMap.Class(SuperMap.REST.Theme, {
    precision: "1.0E-12",
    items: null,
    rangeExpression: null,
    rangeMode: SuperMap.REST.RangeMode.EQUALINTERVAL,
    rangeParameter: 0,
    colorGradientType: SuperMap.REST.ColorGradientType.YELLOW_RED,
    initialize: function(a) {
        SuperMap.REST.Theme.prototype.initialize.apply(this, ["RANGE", a]);
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        SuperMap.REST.Theme.prototype.destroy.apply(this, arguments);
        var c = this;
        if (c.items) {
            if (c.items.length > 0) {
                for (var a in c.items) {
                    c.items[a].destroy();
                    c.items[a] = null
                }
            }
            c.items = null
        }
        c.rangeExpression = null;
        c.rangeMode = null;
        c.rangeParameter = null;
        c.colorGradientType = null
    },
    CLASS_NAME: "SuperMap.REST.ThemeRange"
});
SuperMap.REST.ThemeRange.fromObj = function(f) {
    if (!f) {
        return
    }
    var e = new SuperMap.REST.ThemeRange();
    SuperMap.Util.copy(e, f);
    var c = f.items;
    var a = c ? c.length : 0;
    e.items = [];
    for (var d = 0; d < a; d++) {
        e.items.push(SuperMap.REST.ThemeRangeItem.fromObj(c[d]))
    }
    return e
}
;
SuperMap.REST.ThemeGridRangeItem = SuperMap.Class({
    caption: null,
    color: null,
    end: 0,
    start: 0,
    visible: true,
    initialize: function(a) {
        var c = this;
        c.color = new SuperMap.REST.ServerColor();
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        var a = this;
        a.caption = null;
        a.end = null;
        a.start = null;
        if (a.color) {
            a.color.destroy();
            a.color = null
        }
        a.visible = null
    },
    toServerJSONObject: function() {
        var a = {};
        a = SuperMap.Util.copyAttributes(a, this);
        if (a.color) {
            if (a.color.toServerJSONObject) {
                a.color = a.color.toServerJSONObject()
            }
        }
        return a
    },
    CLASS_NAME: "SuperMap.REST.ThemeGridRangeItem"
});
SuperMap.REST.ThemeGridRangeItem.fromObj = function(c) {
    if (!c) {
        return
    }
    var a = new SuperMap.REST.ThemeGridRangeItem();
    SuperMap.Util.copy(a, c);
    a.color = SuperMap.REST.ServerColor.fromJson(c.color);
    return a
}
;
SuperMap.REST.ThemeGridRange = SuperMap.Class(SuperMap.REST.Theme, {
    items: null,
    rangeMode: SuperMap.REST.RangeMode.EQUALINTERVAL,
    rangeParameter: 0,
    colorGradientType: SuperMap.REST.ColorGradientType.YELLOW_RED,
    reverseColor: false,
    initialize: function(a) {
        SuperMap.REST.Theme.prototype.initialize.apply(this, ["GRIDRANGE", a]);
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        SuperMap.REST.Theme.prototype.destroy.apply(this, arguments);
        var c = this;
        if (c.items) {
            if (c.items.length > 0) {
                for (var a in c.items) {
                    c.items[a].destroy();
                    c.items[a] = null
                }
            }
            c.items = null
        }
        c.reverseColor = null;
        c.rangeMode = null;
        c.rangeParameter = null;
        c.colorGradientType = null
    },
    CLASS_NAME: "SuperMap.REST.ThemeGridRange"
});
SuperMap.REST.ThemeGridRange.fromObj = function(f) {
    if (!f) {
        return
    }
    var e = new SuperMap.REST.ThemeGridRange();
    SuperMap.Util.copy(e, f);
    var c = f.items;
    var a = c ? c.length : 0;
    e.items = [];
    for (var d = 0; d < a; d++) {
        e.items.push(SuperMap.REST.ThemeGridRangeItem.fromObj(c[d]))
    }
    return e
}
;
SuperMap.REST.ThemeUniqueItem = SuperMap.Class({
    caption: null,
    style: null,
    unique: null,
    visible: true,
    initialize: function(a) {
        var c = this;
        c.style = new SuperMap.REST.ServerStyle();
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        var a = this;
        a.caption = null;
        a.unique = null;
        if (a.style) {
            a.style.destroy();
            a.style = null
        }
        a.visible = null
    },
    toServerJSONObject: function() {
        var a = {};
        a = SuperMap.Util.copyAttributes(a, this);
        if (a.style) {
            if (a.style.toServerJSONObject) {
                a.style = a.style.toServerJSONObject()
            }
        }
        return a
    },
    CLASS_NAME: "SuperMap.REST.ThemeUniqueItem"
});
SuperMap.REST.ThemeUniqueItem.fromObj = function(c) {
    var a = new SuperMap.REST.ThemeUniqueItem();
    SuperMap.Util.copy(a, c);
    a.style = SuperMap.REST.ServerStyle.fromJson(c.style);
    return a
}
;
SuperMap.REST.ThemeUnique = SuperMap.Class(SuperMap.REST.Theme, {
    defaultStyle: null,
    items: null,
    uniqueExpression: null,
    colorGradientType: SuperMap.REST.ColorGradientType.YELLOW_RED,
    initialize: function(a) {
        var c = this;
        c.defaultStyle = new SuperMap.REST.ServerStyle();
        SuperMap.REST.Theme.prototype.initialize.apply(this, ["UNIQUE", a]);
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        SuperMap.REST.Theme.prototype.destroy.apply(this, arguments);
        var c = this;
        c.uniqueExpression = null;
        c.colorGradientType = null;
        if (c.items) {
            if (c.items.length > 0) {
                for (var a in c.items) {
                    c.items[a].destroy();
                    c.items[a] = null
                }
            }
            c.items = null
        }
        if (c.defaultStyle) {
            c.defaultStyle.destroy();
            c.defaultStyle = null
        }
    },
    toServerJSONObject: function() {
        var e = {};
        e = SuperMap.Util.copyAttributes(e, this);
        if (e.defaultStyle) {
            if (e.defaultStyle.toServerJSONObject) {
                e.defaultStyle = e.defaultStyle.toServerJSONObject()
            }
        }
        if (e.items) {
            var c = []
              , a = e.items.length;
            for (var d = 0; d < a; d++) {
                c.push(e.items[d].toServerJSONObject())
            }
            e.items = c
        }
        return e
    },
    CLASS_NAME: "SuperMap.REST.ThemeUnique"
});
SuperMap.REST.ThemeUnique.fromObj = function(f) {
    var e = new SuperMap.REST.ThemeUnique();
    var c = f.items;
    var a = c ? c.length : 0;
    SuperMap.Util.extend(e, f);
    e.items = [];
    e.defaultStyle = new SuperMap.REST.ServerStyle.fromJson(f.defaultStyle);
    for (var d = 0; d < a; d++) {
        e.items.push(new SuperMap.REST.ThemeUniqueItem.fromObj(c[d]))
    }
    return e
}
;
SuperMap.REST.ThemeGridUniqueItem = SuperMap.Class({
    caption: null,
    color: null,
    unique: null,
    visible: true,
    initialize: function(a) {
        var c = this;
        c.color = new SuperMap.REST.ServerColor();
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        var a = this;
        a.caption = null;
        a.unique = null;
        if (a.color) {
            a.color.destroy();
            a.color = null
        }
        a.visible = null
    },
    toServerJSONObject: function() {
        var a = {};
        a = SuperMap.Util.copyAttributes(a, this);
        if (a.color) {
            if (a.color.toServerJSONObject) {
                a.color = a.color.toServerJSONObject()
            }
        }
        return a
    },
    CLASS_NAME: "SuperMap.REST.ThemeGridUniqueItem"
});
SuperMap.REST.ThemeGridUniqueItem.fromObj = function(c) {
    var a = new SuperMap.REST.ThemeGridUniqueItem();
    SuperMap.Util.copy(a, c);
    a.color = SuperMap.REST.ServerColor.fromJson(c.color);
    return a
}
;
SuperMap.REST.ThemeGridUnique = SuperMap.Class(SuperMap.REST.Theme, {
    defaultcolor: null,
    items: null,
    initialize: function(a) {
        var c = this;
        c.defaultcolor = new SuperMap.REST.ServerColor();
        SuperMap.REST.Theme.prototype.initialize.apply(this, ["GRIDUNIQUE", a]);
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        SuperMap.REST.Theme.prototype.destroy.apply(this, arguments);
        var c = this;
        if (c.items) {
            if (c.items.length > 0) {
                for (var a in c.items) {
                    c.items[a].destroy();
                    c.items[a] = null
                }
            }
            c.items = null
        }
        if (c.defaultcolor) {
            c.defaultcolor.destroy();
            c.defaultcolor = null
        }
    },
    toServerJSONObject: function() {
        var e = {};
        e = SuperMap.Util.copyAttributes(e, this);
        if (e.defaultcolor) {
            if (e.defaultcolor.toServerJSONObject) {
                e.defaultcolor = e.defaultcolor.toServerJSONObject()
            }
        }
        if (e.items) {
            var c = []
              , a = e.items.length;
            for (var d = 0; d < a; d++) {
                c.push(e.items[d].toServerJSONObject())
            }
            e.items = c
        }
        return e
    },
    CLASS_NAME: "SuperMap.REST.ThemeGridUnique"
});
SuperMap.REST.ThemeGridUnique.fromObj = function(f) {
    var e = new SuperMap.REST.ThemeGridUnique();
    var c = f.items;
    var a = c ? c.length : 0;
    SuperMap.Util.extend(e, f);
    e.items = [];
    e.defaultcolor = new SuperMap.REST.ServerColor.fromJson(f.defaultcolor);
    for (var d = 0; d < a; d++) {
        e.items.push(new SuperMap.REST.ThemeGridUniqueItem.fromObj(c[d]))
    }
    return e
}
;
SuperMap.REST.LabelMatrixCell = SuperMap.Class({
    CLASS_NAME: "SuperMap.REST.LabelMatrixCell"
});
SuperMap.REST.ThemeLabelText = SuperMap.Class({
    maxTextHeight: 0,
    maxTextWidth: 0,
    minTextHeight: 0,
    minTextWidth: 0,
    uniformStyle: null,
    uniformMixedStyle: null,
    initialize: function(a) {
        var c = this;
        c.uniformStyle = new SuperMap.REST.ServerTextStyle();
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        var a = this;
        a.maxTextHeight = null;
        a.maxTextWidth = null;
        a.minTextHeight = null;
        a.minTextWidth = null;
        if (a.uniformStyle) {
            a.uniformStyle.destroy();
            a.uniformStyle = null
        }
        if (a.uniformMixedStyle) {
            a.uniformMixedStyle.destroy();
            a.uniformMixedStyle = null
        }
    },
    CLASS_NAME: "SuperMap.REST.ThemeLabelText"
});
SuperMap.REST.ThemeLabelText.fromObj = function(c) {
    if (!c) {
        return
    }
    var a = new SuperMap.REST.ThemeLabelText();
    SuperMap.Util.copy(a, c);
    a.uniformStyle = SuperMap.REST.ServerTextStyle.fromObj(c.uniformStyle);
    a.uniformMixedStyle = SuperMap.REST.LabelMixedTextStyle.fromObj(c.uniformMixedStyle);
    return a
}
;
SuperMap.REST.ThemeLabelItem = SuperMap.Class({
    caption: null,
    end: 0,
    start: 0,
    visible: true,
    style: null,
    initialize: function(a) {
        var c = this;
        c.style = new SuperMap.REST.ServerTextStyle();
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        var a = this;
        a.caption = null;
        a.end = null;
        a.start = null;
        if (a.style) {
            a.style.destroy();
            a.style = null
        }
        a.visible = null
    },
    CLASS_NAME: "SuperMap.REST.ThemeLabelItem"
});
SuperMap.REST.ThemeLabelItem.fromObj = function(c) {
    if (!c) {
        return
    }
    var a = new SuperMap.REST.ThemeLabelItem();
    SuperMap.Util.copy(a, c);
    return a
}
;
SuperMap.REST.ThemeLabelBackground = SuperMap.Class({
    labelBackShape: SuperMap.REST.LabelBackShape.NONE,
    backStyle: null,
    initialize: function(a) {
        var c = this;
        c.backStyle = new SuperMap.REST.ServerStyle();
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        var a = this;
        a.labelBackShape = null;
        if (a.backStyle) {
            a.backStyle.destroy();
            a.backStyle = null
        }
    },
    CLASS_NAME: "SuperMap.REST.ThemeLabelBackground"
});
SuperMap.REST.ThemeLabelBackground.fromObj = function(c) {
    if (!c) {
        return
    }
    var a = new SuperMap.REST.ThemeLabelBackground();
    a.labelBackShape = c.labelBackShape;
    a.backStyle = SuperMap.REST.ServerStyle.fromJson(c.backStyle);
    return a
}
;
SuperMap.REST.ThemeLabelAlongLine = SuperMap.Class({
    isAlongLine: true,
    alongLineDirection: SuperMap.REST.AlongLineDirection.LB_TO_RT,
    angleFixed: false,
    repeatedLabelAvoided: false,
    repeatIntervalFixed: false,
    labelRepeatInterval: 0,
    initialize: function(a) {
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        var a = this;
        a.isAlongLine = null;
        a.alongLineDirection = null;
        a.angleFixed = null;
        a.repeatedLabelAvoided = null;
        a.repeatIntervalFixed = null;
        a.labelRepeatInterval = null
    },
    CLASS_NAME: "SuperMap.REST.ThemeLabelAlongLine"
});
SuperMap.REST.ThemeLabelAlongLine.fromObj = function(c) {
    if (!c) {
        return
    }
    var a = new SuperMap.REST.ThemeLabelAlongLine();
    SuperMap.Util.copy(a, c);
    return a
}
;
SuperMap.REST.LabelThemeCell = SuperMap.Class(SuperMap.REST.LabelMatrixCell, {
    themeLabel: null,
    type: "THEME",
    initialize: function(a) {
        var c = this;
        c.themeLabel = new SuperMap.REST.ThemeLabel();
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        var a = this;
        if (a.themeLabel) {
            a.themeLabel.destroy();
            a.themeLabel = null
        }
    },
    CLASS_NAME: "SuperMap.REST.LabelThemeCell"
});
SuperMap.REST.LabelSymbolCell = SuperMap.Class(SuperMap.REST.LabelMatrixCell, {
    style: null,
    symbolIDField: null,
    type: "SYMBOL",
    initialize: function(a) {
        var c = this;
        c.style = new SuperMap.REST.ServerStyle();
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        var a = this;
        if (a.style) {
            a.style.destroy();
            a.style = null
        }
        a.symbolIDField = null
    },
    CLASS_NAME: "SuperMap.REST.LabelSymbolCell"
});
SuperMap.REST.LabelMixedTextStyle = SuperMap.Class({
    defaultStyle: null,
    separator: null,
    separatorEnabled: false,
    splitIndexes: null,
    styles: null,
    initialize: function(a) {
        var c = this;
        c.defaultStyle = new SuperMap.REST.ServerTextStyle();
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        var e = this;
        if (e.defaultStyle) {
            e.defaultStyle.destroy();
            e.defaultStyle = null
        }
        e.separator = null;
        e.separatorEnabled = null;
        if (e.splitIndexes) {
            e.splitIndexes = null
        }
        if (e.styles) {
            for (var c = 0, d = e.styles, a = d.length; c < a; c++) {
                d[c].destroy()
            }
            e.styles = null
        }
    },
    CLASS_NAME: "SuperMap.REST.LabelMixedTextStyle"
});
SuperMap.REST.LabelMixedTextStyle.fromObj = function(e) {
    if (!e) {
        return
    }
    var d = new SuperMap.REST.LabelMixedTextStyle();
    var f = e.styles;
    SuperMap.Util.copy(d, e);
    d.defaultStyle = new SuperMap.REST.ServerTextStyle(e.defaultStyle);
    if (f) {
        d.styles = [];
        for (var c = 0, a = f.length; c < a; c++) {
            d.styles.push(new SuperMap.REST.ServerTextStyle(f[c]))
        }
    }
    return d
}
;
SuperMap.REST.LabelImageCell = SuperMap.Class(SuperMap.REST.LabelMatrixCell, {
    height: 0,
    pathField: null,
    rotation: 0,
    width: 0,
    sizeFixed: false,
    type: "IMAGE",
    initialize: function(a) {
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        var a = this;
        a.height = null;
        a.pathField = null;
        a.rotation = null;
        a.width = null;
        a.sizeFixed = null
    },
    CLASS_NAME: "SuperMap.REST.LabelImageCell"
});
SuperMap.REST.ThemeLabel = SuperMap.Class(SuperMap.REST.Theme, {
    alongLine: null,
    background: null,
    flow: null,
    items: null,
    labelExpression: null,
    labelOverLengthMode: SuperMap.REST.LabelOverLengthMode.NONE,
    matrixCells: null,
    maxLabelLength: 256,
    numericPrecision: 0,
    offset: null,
    overlapAvoided: true,
    rangeExpression: null,
    smallGeometryLabeled: false,
    text: null,
    initialize: function(a) {
        var c = this;
        c.alongLine = new SuperMap.REST.ThemeLabelAlongLine();
        c.background = new SuperMap.REST.ThemeLabelBackground();
        c.flow = new SuperMap.REST.ThemeFlow();
        c.offset = new SuperMap.REST.ThemeOffset();
        c.text = new SuperMap.REST.ThemeLabelText();
        SuperMap.REST.Theme.prototype.initialize.apply(this, ["LABEL", a]);
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        SuperMap.REST.Theme.prototype.destroy.apply(this, arguments);
        var e = this;
        e.alongLine = null;
        if (e.background) {
            e.background.destroy();
            e.background = null
        }
        e.flow = null;
        if (e.items) {
            for (var d = 0, c = e.items, a = c.length; d < a; d++) {
                c[d].destroy()
            }
            e.items = null
        }
        e.labelExpression = null;
        e.labelOverLengthMode = null;
        e.matrixCells = null;
        e.maxLabelLength = null;
        e.numericPrecision = null;
        e.overlapAvoided = null;
        e.rangeExpression = null;
        if (e.offset) {
            e.offset.destroy();
            e.offset = null
        }
        e.overlapAvoided = null;
        e.smallGeometryLabeled = null;
        if (e.text) {
            e.text.destroy();
            e.text = null
        }
    },
    toJSON: function() {
        return SuperMap.Util.toJSON(this.toServerJSONObject())
    },
    toServerJSONObject: function() {
        var a = new Object();
        a.type = this.type;
        a.memoryData = this.memoryData;
        if (this.alongLine) {
            a.alongLine = this.alongLine.isAlongLine;
            a.alongLineDirection = this.alongLine.alongLineDirection;
            a.angleFixed = this.alongLine.angleFixed;
            a.isLabelRepeated = this.alongLine.isLabelRepeated;
            a.labelRepeatInterval = this.alongLine.labelRepeatInterval;
            a.repeatedLabelAvoided = this.alongLine.repeatedLabelAvoided;
            a.repeatIntervalFixed = this.alongLine.repeatIntervalFixed
        }
        if (this.offset) {
            a.offsetFixed = this.offset.offsetFixed;
            a.offsetX = this.offset.offsetX;
            a.offsetY = this.offset.offsetY
        }
        if (this.flow) {
            a.flowEnabled = this.flow.flowEnabled;
            a.leaderLineDisplayed = this.flow.leaderLineDisplayed;
            a.leaderLineStyle = this.flow.leaderLineStyle
        }
        if (this.text) {
            a.maxTextHeight = this.text.maxTextHeight;
            a.maxTextWidth = this.text.maxTextWidth;
            a.minTextHeight = this.text.minTextHeight;
            a.minTextWidth = this.text.minTextWidth;
            a.uniformStyle = this.text.uniformStyle;
            a.uniformMixedStyle = this.text.uniformMixedStyle
        }
        if (this.background) {
            a.labelBackShape = this.background.labelBackShape;
            a.backStyle = this.background.backStyle
        }
        a.labelOverLengthMode = this.labelOverLengthMode;
        a.maxLabelLength = this.maxLabelLength;
        a.smallGeometryLabeled = this.smallGeometryLabeled;
        a.rangeExpression = this.rangeExpression;
        a.numericPrecision = this.numericPrecision;
        a.items = this.items;
        a.labelExpression = this.labelExpression;
        a.overlapAvoided = this.overlapAvoided;
        a.matrixCells = this.matrixCells;
        return a
    },
    CLASS_NAME: "SuperMap.REST.ThemeLabel"
});
SuperMap.REST.ThemeLabel.fromObj = function(g) {
    if (!g) {
        return
    }
    var e = new SuperMap.REST.ThemeLabel();
    var f = g.items
      , c = g.matrixCells;
    g.matrixCells = null;
    SuperMap.Util.copy(e, g);
    e.alongLine = SuperMap.REST.ThemeLabelAlongLine.fromObj(g);
    e.background = SuperMap.REST.ThemeLabelBackground.fromObj(g);
    e.flow = new SuperMap.REST.ThemeFlow({
        flowEnabled: g.flowEnabled,
        leaderLineDisplayed: g.leaderLineDisplayed,
        leaderLineStyle: g.leaderLineStyle
    });
    if (f) {
        e.items = [];
        for (var d = 0, a = f.length; d < a; d++) {
            e.items.push(SuperMap.REST.ThemeLabelItem.fromObj(f[d]))
        }
    }
    if (c) {
        e.matrixCells = [];
        for (var d = 0, a = c.length; d < a; d++) {}
    }
    e.offset = SuperMap.REST.ThemeOffset.fromObj(g);
    e.text = SuperMap.REST.ThemeLabelText.fromObj(g);
    return e
}
;
SuperMap.REST.ThemeMemoryData = SuperMap.Class({
    srcData: null,
    targetData: null,
    initialize: function(c, a) {
        if (c) {
            this.srcData = c
        }
        if (a) {
            this.targetData = a
        }
    },
    destroy: function() {
        var a = this;
        a.srcData = null;
        a.targetData = null
    },
    toJSON: function() {
        if (this.srcData && this.targetData) {
            var d = "";
            var c = Math.min(this.srcData.length, this.targetData.length);
            for (var a = 0; a < c; a++) {
                d += "'" + this.srcData[a] + "':'" + this.targetData[a] + "',"
            }
            if (a > 0) {
                d = d.substring(0, d.length - 1)
            }
            return "{" + d + "}"
        } else {
            return null
        }
    },
    CLASS_NAME: "SuperMap.REST.ThemeMemoryData"
});
SuperMap.REST.ThemeResult = SuperMap.Class({
    resourceInfo: null,
    initialize: function(a) {
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        var a = this;
        if (a.resourceInfo) {
            a.resourceInfo.destroy();
            a.resourceInfo = null
        }
    },
    CLASS_NAME: "SuperMap.REST.ThemeResult"
});
SuperMap.REST.ThemeEventArgs = SuperMap.Class(SuperMap.ServiceEventArgs, {
    result: null,
    initialize: function(a, d) {
        SuperMap.ServiceEventArgs.prototype.initialize.apply(this, [d]);
        var c = this;
        c.result = a
    },
    destroy: function() {
        SuperMap.ServiceEventArgs.prototype.destroy.apply(this);
        var a = this;
        if (a.result) {
            a.result.destroy();
            a.result = null
        }
    },
    CLASS_NAME: "SuperMap.REST.ThemeEventArgs"
});
SuperMap.REST.ThemeParameters = SuperMap.Class({
    datasetNames: null,
    dataSourceNames: null,
    joinItems: null,
    themes: null,
    displayFilters: null,
    displayOrderBys: null,
    initialize: function(a) {
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        var f = this;
        f.datasetNames = null;
        f.dataSourceNames = null;
        if (f.joinItems) {
            for (var d = 0, e = f.joinItems, c = e.length; d < c; d++) {
                e[d].destroy()
            }
            f.joinItems = null
        }
        if (f.themes) {
            for (var d = 0, a = f.themes, c = a.length; d < c; d++) {
                a[d].destroy()
            }
            f.themes = null
        }
    },
    CLASS_NAME: "SuperMap.REST.ThemeParameters"
});
SuperMap.REST.ThemeService = SuperMap.Class(SuperMap.ServiceBase, {
    EVENT_TYPES: ["processCompleted", "processFailed"],
    events: null,
    eventListeners: null,
    lastResult: null,
    initialize: function(d, c) {
        SuperMap.ServiceBase.prototype.initialize.apply(this, [d]);
        if (c) {
            SuperMap.Util.extend(this, c)
        }
        var a, e = this;
        e.events = new SuperMap.Events(e,null,e.EVENT_TYPES,true);
        if (e.eventListeners instanceof Object) {
            e.events.on(e.eventListeners)
        }
        a = e.url.substr(e.url.length - 1, 1);
        if (e.isInTheSameDomain) {
            e.url += (a == "/") ? "tempLayersSet.json?" : "/tempLayersSet.json?"
        } else {
            e.url += (a == "/") ? "tempLayersSet.jsonp?" : "/tempLayersSet.jsonp?"
        }
    },
    destroy: function() {
        SuperMap.ServiceBase.prototype.destroy.apply(this, arguments);
        var a = this;
        a.EVENT_TYPES = null;
        if (a.events) {
            a.events.destroy();
            a.events = null
        }
        if (a.eventListeners) {
            a.eventListeners = null
        }
        if (a.lastResult) {
            a.lastResult.destroy();
            a.lastResult = null
        }
    },
    processAsync: function(d) {
        if (!d) {
            return
        }
        var a = this
          , c = null;
        c = a.getJsonParameters(d);
        a.request({
            method: "POST",
            data: c,
            scope: a,
            success: a.themeComplete,
            failure: a.themeError
        })
    },
    themeComplete: function(a) {
        var e = this
          , c = null
          , d = null;
        a = SuperMap.Util.transformResult(a);
        d = new SuperMap.REST.ThemeResult();
        d.resourceInfo = SuperMap.REST.ResourceInfo.fromJson(a);
        e.lastResult = d;
        c = new SuperMap.REST.ThemeEventArgs(d,a);
        e.events.triggerEvent("processCompleted", c)
    },
    themeError: function(c) {
        var f = this
          , e = null
          , a = null
          , d = null;
        c = SuperMap.Util.transformResult(c);
        e = c.error;
        if (!e) {
            return
        }
        a = SuperMap.ServiceException.fromJson(e);
        d = new SuperMap.ServiceFailedEventArgs(a,c);
        f.events.triggerEvent("processFailed", d)
    },
    getJsonParameters: function(j) {
        var i = ""
          , a = ""
          , d = null
          , c = null
          , f = null;
        i += "[{'type': 'UGC','subLayers': {'layers': [";
        for (var e in j.themes) {
            d = j.themes[e];
            var h = SuperMap.Util.toJSON(d);
            h = h.slice(0, -1);
            i += "{'theme': " + h + "},'type': 'UGC','ugcLayerType': 'THEME',";
            c = j.displayFilters;
            if (c && c.length > 0) {
                if (c.length === 1) {
                    i += "'displayFilter':\"" + c[0] + '",'
                } else {
                    i += "'displayFilter':\"" + c[e] + '",'
                }
            }
            f = j.displayOrderBys;
            if (f && f.length > 0) {
                if (f.length === 1) {
                    i += "'displayOrderBy':'" + f[0] + "',"
                } else {
                    i += "'displayOrderBy':'" + f[e] + "',"
                }
            }
            if (j.joinItems && j.joinItems.length > 0 && j.joinItems[e]) {
                i += "'joinItems':[" + SuperMap.Util.toJSON(j.joinItems[e]) + "],"
            }
            if (j.datasetNames && j.dataSourceNames) {
                var m = j.datasetNames[e] ? e : (j.datasetNames.length - 1);
                var k = j.dataSourceNames[e] ? e : (j.dataSourceNames.length - 1);
                i += "'datasetInfo': {'name': '" + j.datasetNames[m] + "','dataSourceName': '" + j.dataSourceNames[k] + "'}},"
            } else {
                i += "},"
            }
        }
        if (j.themes && j.themes.length > 0) {
            i = i.substring(0, i.length - 1)
        }
        i += "]},";
        var g = this.url.split("/");
        var l = g[g.length - 2];
        i += "'name': '" + l + "'}]";
        return i
    },
    CLASS_NAME: "SuperMap.REST.ThemeService"
});
SuperMap.REST.ThemeDotDensity = SuperMap.Class(SuperMap.REST.Theme, {
    dotExpression: null,
    style: null,
    value: null,
    initialize: function(a) {
        var c = this;
        c.style = new SuperMap.REST.ServerStyle();
        SuperMap.REST.Theme.prototype.initialize.apply(this, ["DOTDENSITY", a]);
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        var a = this;
        a.dotExpression = null;
        a.value = null;
        if (a.style) {
            a.style.destroy();
            a.style = null
        }
    },
    toServerJSONObject: function() {
        var a = {};
        a = SuperMap.Util.copyAttributes(a, this);
        if (a.style) {
            if (a.style.toServerJSONObject) {
                a.style = a.style.toServerJSONObject()
            }
        }
        return a
    },
    CLASS_NAME: "SuperMap.REST.ThemeDotDensity"
});
SuperMap.REST.ThemeDotDensity.fromObj = function(c) {
    if (!c) {
        return
    }
    var a = new SuperMap.REST.ThemeDotDensity();
    SuperMap.Util.copy(a, c);
    a.style = SuperMap.REST.ServerStyle.fromJson(c.style);
    return a
}
;
SuperMap.REST.ThemeGraduatedSymbolStyle = SuperMap.Class({
    negativeDisplayed: false,
    negativeStyle: null,
    positiveStyle: null,
    zeroDisplayed: false,
    zeroStyle: null,
    initialize: function(a) {
        var c = this;
        c.negativeStyle = new SuperMap.REST.ServerStyle();
        c.positiveStyle = new SuperMap.REST.ServerStyle();
        c.zeroStyle = new SuperMap.REST.ServerStyle();
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        var a = this;
        a.negativeDisplayed = null;
        a.negativeStyle = null;
        a.positiveStyle = null;
        a.zeroDisplayed = null;
        a.zeroStyle = null
    },
    CLASS_NAME: "SuperMap.REST.ThemeGraduatedSymbolStyle"
});
SuperMap.REST.ThemeGraduatedSymbolStyle.fromObj = function(c) {
    if (!c) {
        return
    }
    var a = new SuperMap.REST.ThemeGraduatedSymbolStyle();
    SuperMap.Util.copy(a, c);
    a.negativeStyle = SuperMap.REST.ServerStyle.fromJson(c.negativeStyle);
    a.positiveStyle = SuperMap.REST.ServerStyle.fromJson(c.positiveStyle);
    a.zeroStyle = SuperMap.REST.ServerStyle.fromJson(c.zeroStyle);
    return a
}
;
SuperMap.REST.ThemeGraduatedSymbol = SuperMap.Class(SuperMap.REST.Theme, {
    baseValue: 0,
    expression: null,
    flow: null,
    graduatedMode: SuperMap.REST.GraduatedMode.CONSTANT,
    offset: null,
    style: null,
    initialize: function(a) {
        SuperMap.REST.Theme.prototype.initialize.apply(this, ["GRADUATEDSYMBOL", a]);
        var c = this;
        c.flow = new SuperMap.REST.ThemeFlow();
        c.offset = new SuperMap.REST.ThemeOffset();
        c.style = new SuperMap.REST.ThemeGraduatedSymbolStyle();
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        SuperMap.REST.Theme.prototype.destroy.apply(this, arguments);
        var a = this;
        a.expression = null;
        if (a.flow) {
            a.flow.destroy();
            a.flow = null
        }
        a.graduatedMode = SuperMap.REST.GraduatedMode.CONSTANT;
        if (a.offset) {
            a.offset.destroy();
            a.offset = null
        }
        if (a.style) {
            a.style.destroy();
            a.style = null
        }
    },
    toJSON: function() {
        return SuperMap.Util.toJSON(this.toServerJSONObject())
    },
    toServerJSONObject: function() {
        var a = new Object();
        a.type = this.type;
        a.memoryData = this.memoryData;
        a.baseValue = this.baseValue;
        a.expression = this.expression;
        a.graduatedMode = this.graduatedMode;
        if (this.flow) {
            a.flowEnabled = this.flow.flowEnabled;
            a.leaderLineDisplayed = this.flow.leaderLineDisplayed;
            a.leaderLineStyle = this.flow.leaderLineStyle
        }
        if (this.offset) {
            a.offsetFixed = this.offset.offsetFixed;
            a.offsetX = this.offset.offsetX;
            a.offsetY = this.offset.offsetY
        }
        if (this.style) {
            a.negativeStyle = this.style.negativeStyle;
            a.negativeDisplayed = this.style.negativeDisplayed;
            a.positiveStyle = this.style.positiveStyle;
            a.zeroDisplayed = this.style.zeroDisplayed;
            a.zeroStyle = this.style.zeroStyle
        }
        return a
    },
    CLASS_NAME: "SuperMap.REST.ThemeGraduatedSymbol"
});
SuperMap.REST.ThemeGraduatedSymbol.fromObj = function(c) {
    if (!c) {
        return
    }
    var a = new SuperMap.REST.ThemeGraduatedSymbol();
    SuperMap.Util.copy(a, c);
    a.flow = SuperMap.REST.ThemeFlow.fromObj(c);
    a.offset = SuperMap.REST.ThemeOffset.fromObj(c);
    a.style = SuperMap.REST.ThemeGraduatedSymbolStyle.fromObj(c);
    return a
}
;
SuperMap.REST.BufferDistance = SuperMap.Class({
    exp: null,
    value: 100,
    initialize: function(a) {
        if (!a) {
            return
        }
        SuperMap.Util.extend(this, a)
    },
    destroy: function() {
        var a = this;
        a.exp = null;
        a.value = null
    },
    CLASS_NAME: "SuperMap.REST.BufferDistance"
});
SuperMap.REST.BufferSetting = SuperMap.Class({
    endType: SuperMap.REST.BufferEndType.FLAT,
    leftDistance: null,
    rightDistance: null,
    semicircleLineSegment: 4,
    initialize: function(a) {
        var c = this;
        c.leftDistance = new SuperMap.REST.BufferDistance();
        c.rightDistance = new SuperMap.REST.BufferDistance();
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        var a = this;
        a.endType = null;
        if (a.leftDistance) {
            a.leftDistance.destroy();
            a.leftDistance = null
        }
        if (a.rightDistance) {
            a.rightDistance.destroy();
            a.rightDistance = null
        }
        a.semicircleLineSegment = null
    },
    CLASS_NAME: "SuperMap.REST.BufferSetting"
});
SuperMap.REST.BufferAnalystParameters = SuperMap.Class({
    bufferSetting: null,
    initialize: function(a) {
        var c = this;
        c.bufferSetting = new SuperMap.REST.BufferSetting();
        if (!a) {
            return
        }
        SuperMap.Util.extend(this, a)
    },
    destroy: function() {
        var a = this;
        if (a.bufferSetting) {
            a.bufferSetting.destroy();
            a.bufferSetting = null
        }
    },
    CLASS_NAME: "SuperMap.REST.BufferAnalystParameters"
});
SuperMap.REST.DatasetBufferAnalystParameters = SuperMap.Class(SuperMap.REST.BufferAnalystParameters, {
    dataset: null,
    filterQueryParameter: null,
    resultSetting: null,
    isAttributeRetained: true,
    isUnion: false,
    initialize: function(a) {
        var c = this;
        c.filterQueryParameter = new SuperMap.REST.FilterParameter();
        c.resultSetting = new SuperMap.REST.DataReturnOption();
        SuperMap.REST.BufferAnalystParameters.prototype.initialize.apply(this, arguments);
        if (!a) {
            return
        }
        SuperMap.Util.extend(this, a)
    },
    destroy: function() {
        SuperMap.REST.BufferAnalystParameters.prototype.destroy.apply(this, arguments);
        var a = this;
        a.dataset = null;
        if (a.filterQueryParameter) {
            a.filterQueryParameter.destroy();
            a.filterQueryParameter = null
        }
        if (a.resultSetting) {
            a.resultSetting.destroy();
            a.resultSetting = null
        }
        a.isAttributeRetained = null;
        a.isUnion = null
    },
    CLASS_NAME: "SuperMap.REST.DatasetBufferAnalystParameters"
});
SuperMap.REST.DatasetBufferAnalystParameters.toObject = function(d, a) {
    for (var c in d) {
        if (c == "bufferSetting") {
            a.bufferAnalystParameter = d.bufferSetting
        } else {
            if (c == "resultSetting") {
                a.dataReturnOption = d.resultSetting
            } else {
                if (c == "dataset") {} else {
                    a[c] = d[c]
                }
            }
        }
    }
}
;
SuperMap.REST.GeometryBufferAnalystParameters = SuperMap.Class(SuperMap.REST.BufferAnalystParameters, {
    sourceGeometry: null,
    initialize: function(a) {
        SuperMap.REST.BufferAnalystParameters.prototype.initialize.apply(this, arguments);
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        SuperMap.REST.BufferAnalystParameters.prototype.destroy.apply(this, arguments);
        var a = this;
        if (a.sourceGeometry) {
            a.sourceGeometry.destroy();
            a.sourceGeometry = null
        }
    },
    CLASS_NAME: "SuperMap.REST.GeometryBufferAnalystParameters"
});
SuperMap.REST.GeometryBufferAnalystParameters.toObject = function(d, a) {
    for (var c in d) {
        if (c == "bufferSetting") {
            a.analystParameter = d.bufferSetting
        } else {
            if (c == "sourceGeometry") {
                a.sourceGeometry = SuperMap.REST.ServerGeometry.fromGeometry(d.sourceGeometry)
            } else {
                a[c] = d[c]
            }
        }
    }
}
;
SuperMap.REST.SpatialAnalystResult = SuperMap.Class({
    succeed: null,
    initialize: function(a) {
        if (!a) {
            return
        }
        SuperMap.Util.extend(this, a)
    },
    destroy: function() {
        var a = this;
        a.succeed = null
    },
    CLASS_NAME: "SuperMap.REST.SpatialAnalystResult"
});
SuperMap.REST.DatasetBufferAnalystResult = SuperMap.Class(SuperMap.REST.SpatialAnalystResult, {
    recordset: null,
    dataset: null,
    initialize: function(a) {
        SuperMap.REST.SpatialAnalystResult.prototype.initialize.apply(this, arguments);
        if (!a) {
            return
        }
        SuperMap.Util.extend(this, a)
    },
    destroy: function() {
        SuperMap.REST.SpatialAnalystResult.prototype.destroy.apply(this, arguments);
        var a = this;
        if (a.recordset) {
            a.recordset.destroy();
            a.recordset = null
        }
        a.dataset = null
    },
    CLASS_NAME: "SuperMap.REST.DatasetBufferAnalystResult"
});
SuperMap.REST.DatasetBufferAnalystResult.fromJson = function(c) {
    if (!c) {
        return
    }
    var a = new SuperMap.REST.DatasetBufferAnalystResult();
    if (c.succeed) {
        a.succeed = c.succeed
    }
    if (c.recordset) {
        a.recordset = SuperMap.REST.Recordset.fromJson(c.recordset)
    }
    if (c.dataset) {
        a.dataset = c.dataset
    }
    return a
}
;
SuperMap.REST.GeometryBufferAnalystResult = SuperMap.Class(SuperMap.REST.SpatialAnalystResult, {
    resultGeometry: null,
    initialize: function(a) {
        SuperMap.REST.SpatialAnalystResult.prototype.initialize.apply(this, arguments);
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        SuperMap.REST.SpatialAnalystResult.prototype.destroy.apply(this, arguments);
        var a = this;
        if (a.resultGeometry) {
            a.resultGeometry.destroy();
            a.resultGeometry = null
        }
    },
    CLASS_NAME: "SuperMap.REST.GeometryBufferAnalystResult"
});
SuperMap.REST.GeometryBufferAnalystResult.fromJson = function(c) {
    if (!c) {
        return
    }
    var a = new SuperMap.REST.GeometryBufferAnalystResult();
    if (c.succeed) {
        a.succeed = c.succeed
    }
    if (c.resultGeometry) {
        a.resultGeometry = SuperMap.REST.ServerGeometry.fromJson(c.resultGeometry).toGeometry()
    }
    return a
}
;
SuperMap.REST.SpatialAnalystEventArgs = SuperMap.Class(SuperMap.ServiceEventArgs, {
    result: null,
    initialize: function(a, d) {
        SuperMap.ServiceEventArgs.prototype.initialize.apply(this, [d]);
        var c = this;
        c.result = a
    },
    destroy: function() {
        SuperMap.ServiceEventArgs.prototype.destroy.apply(this);
        var a = this;
        if (a.result) {
            a.result.destroy();
            a.result = null
        }
    },
    CLASS_NAME: "SuperMap.REST.SpatialAnalystEventArgs"
});
SuperMap.REST.BufferAnalystEventArgs = SuperMap.Class(SuperMap.ServiceEventArgs, {
    result: null,
    initialize: function(a, d) {
        SuperMap.ServiceEventArgs.prototype.initialize.apply(this, [d]);
        var c = this;
        c.result = a
    },
    destroy: function() {
        SuperMap.ServiceEventArgs.prototype.destroy.apply(this);
        var a = this;
        if (a.result) {
            a.result.destroy();
            a.result = null
        }
    },
    CLASS_NAME: "SuperMap.REST.BufferAnalystEventArgs"
});
SuperMap.REST.BufferAnalystService = SuperMap.Class(SuperMap.ServiceBase, {
    EVENT_TYPES: ["processCompleted", "processFailed"],
    events: null,
    eventListeners: null,
    lastResult: null,
    mode: null,
    initialize: function(c, a) {
        SuperMap.ServiceBase.prototype.initialize.apply(this, [c]);
        var d = this;
        if (a) {
            SuperMap.Util.extend(d, a)
        }
        d.events = new SuperMap.Events(d,null,d.EVENT_TYPES,true);
        if (d.eventListeners instanceof Object) {
            d.events.on(d.eventListeners)
        }
    },
    destroy: function() {
        SuperMap.ServiceBase.prototype.destroy.apply(this, arguments);
        var a = this;
        a.EVENT_TYPES = null;
        if (a.events) {
            a.events.destroy();
            a.events = null
        }
        if (a.eventListeners) {
            a.eventListeners = null
        }
        if (a.lastResult) {
            a.lastResult.destroy();
            a.lastResult = null
        }
        a.mode = null
    },
    processAsync: function(f) {
        var d = new Object();
        var c = this;
        var a = c.url.substr(c.url.length - 1, 1);
        if (a == "/") {} else {
            c.url += "/"
        }
        if (f instanceof SuperMap.REST.DatasetBufferAnalystParameters) {
            c.mode = "datasets";
            c.url += "datasets/" + f.dataset + "/buffer";
            SuperMap.REST.DatasetBufferAnalystParameters.toObject(f, d)
        } else {
            if (f instanceof SuperMap.REST.GeometryBufferAnalystParameters) {
                c.mode = "geometry";
                c.url += "geometry/buffer";
                SuperMap.REST.GeometryBufferAnalystParameters.toObject(f, d)
            }
        }
        var e = SuperMap.Util.toJSON(d);
        if (c.isInTheSameDomain) {
            c.url += ".json?returnContent=true"
        } else {
            c.url += ".jsonp?returnContent=true"
        }
        c.request({
            method: "POST",
            data: e,
            scope: c,
            success: c.analyzeComplete,
            failure: c.analyzeError
        })
    },
    analyzeComplete: function(c) {
        c = SuperMap.Util.transformResult(c);
        if (this.mode == "datasets") {
            var a = SuperMap.REST.DatasetBufferAnalystResult.fromJson(c)
        } else {
            if (this.mode == "geometry") {
                var a = SuperMap.REST.GeometryBufferAnalystResult.fromJson(c)
            }
        }
        this.mode = null;
        this.lastResult = a;
        var d = new SuperMap.REST.BufferAnalystEventArgs(a,c);
        this.events.triggerEvent("processCompleted", d)
    },
    analyzeError: function(c) {
        var e = this
          , d = null
          , a = null
          , f = null;
        c = SuperMap.Util.transformResult(c);
        d = c.error;
        if (!d) {
            return
        }
        a = SuperMap.ServiceException.fromJson(d);
        f = new SuperMap.ServiceFailedEventArgs(a,c);
        e.events.triggerEvent("processFailed", f)
    },
    CLASS_NAME: "SuperMap.REST.BufferAnalystService"
});
SuperMap.REST.DatasetOverlayAnalystResult = SuperMap.Class(SuperMap.REST.SpatialAnalystResult, {
    recordset: null,
    initialize: function(a) {
        SuperMap.REST.SpatialAnalystResult.prototype.initialize.apply(this, arguments);
        if (!a) {
            return
        }
        SuperMap.Util.extend(this, a)
    },
    destroy: function() {
        SuperMap.REST.SpatialAnalystResult.prototype.destroy.apply(this, arguments);
        var a = this;
        if (a.recordset) {
            a.recordset.destroy();
            a.recordset = null
        }
    },
    CLASS_NAME: "SuperMap.REST.DatasetOverlayAnalystResult "
});
SuperMap.REST.DatasetOverlayAnalystResult.fromJson = function(d) {
    if (!d) {
        return
    }
    var a = new SuperMap.REST.DatasetOverlayAnalystResult();
    if (d.succeed) {
        a.succeed = d.succeed
    }
    for (var c in d) {
        if (c == "recordset") {
            a.recordset = SuperMap.REST.Recordset.fromJson(d.recordset)
        } else {
            a[c] = d[c]
        }
    }
    return a
}
;
SuperMap.REST.GeometryOverlayAnalystResult = SuperMap.Class(SuperMap.REST.SpatialAnalystResult, {
    resultGeometry: null,
    initialize: function(a) {
        SuperMap.REST.SpatialAnalystResult.prototype.initialize.apply(this, arguments);
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        SuperMap.REST.SpatialAnalystResult.prototype.destroy.apply(this, arguments);
        var a = this;
        if (a.resultGeometry) {
            a.resultGeometry.destroy();
            a.resultGeometry = null
        }
    },
    CLASS_NAME: "SuperMap.REST.GeometryOverlayAnalystResult"
});
SuperMap.REST.GeometryOverlayAnalystResult.fromJson = function(c) {
    if (!c) {
        return
    }
    var a = new SuperMap.REST.GeometryOverlayAnalystResult();
    if (c.succeed) {
        a.succeed = c.succeed
    }
    if (c.resultGeometry) {
        a.resultGeometry = SuperMap.REST.ServerGeometry.fromJson(c.resultGeometry).toGeometry()
    }
    return a
}
;
SuperMap.REST.OverlayAnalystParameters = SuperMap.Class({
    operation: SuperMap.REST.OverlayOperationType.UNION,
    initialize: function(a) {
        var c = this;
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        var a = this;
        a.operation = null
    },
    CLASS_NAME: "SuperMap.REST.OverlayAnalystParameters"
});
SuperMap.REST.GeometryOverlayAnalystParameters = SuperMap.Class(SuperMap.REST.OverlayAnalystParameters, {
    operateGeometry: null,
    sourceGeometry: null,
    initialize: function(a) {
        SuperMap.REST.OverlayAnalystParameters.prototype.initialize.apply(this, arguments);
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        SuperMap.REST.OverlayAnalystParameters.prototype.destroy.apply(this, arguments);
        var a = this;
        if (a.sourceGeometry) {
            a.sourceGeometry.destroy();
            a.sourceGeometry = null
        }
        if (a.operateGeometry) {
            a.operateGeometry.destroy();
            a.operateGeometry = null
        }
    },
    CLASS_NAME: "SuperMap.REST.GeometryOverlayAnalystParameters"
});
SuperMap.REST.GeometryOverlayAnalystParameters.toObject = function(d, a) {
    for (var c in d) {
        if (c == "sourceGeometry") {
            a.sourceGeometry = SuperMap.REST.ServerGeometry.fromGeometry(d.sourceGeometry)
        } else {
            if (c == "operateGeometry") {
                a.operateGeometry = SuperMap.REST.ServerGeometry.fromGeometry(d.operateGeometry)
            } else {
                a[c] = d[c]
            }
        }
    }
}
;
SuperMap.REST.DatasetOverlayAnalystParameters = SuperMap.Class(SuperMap.REST.OverlayAnalystParameters, {
    operateDataset: null,
    operateDatasetFields: null,
    operateDatasetFilter: null,
    operateRegions: null,
    sourceDataset: null,
    sourceDatasetFields: null,
    sourceDatasetFilter: null,
    tolerance: 0,
    resultSetting: null,
    initialize: function(a) {
        var c = this;
        c.operateDatasetFields = new Array();
        c.operateDatasetFilter = new SuperMap.REST.FilterParameter();
        c.operateRegions = new Array();
        c.sourceDatasetFields = new Array();
        c.sourceDatasetFilter = new SuperMap.REST.FilterParameter();
        c.resultSetting = new SuperMap.REST.DataReturnOption();
        SuperMap.REST.OverlayAnalystParameters.prototype.initialize.apply(this, arguments);
        if (!a) {
            return
        }
        SuperMap.Util.extend(this, a)
    },
    destroy: function() {
        SuperMap.REST.OverlayAnalystParameters.prototype.destroy.apply(this, arguments);
        var d = this;
        d.operateDataset = null;
        d.operateDatasetFields = null;
        if (d.operateDatasetFilter) {
            d.operateDatasetFilter.destroy();
            d.operateDatasetFilter = null
        }
        if (d.operateRegions) {
            for (var c = 0, e = d.operateRegions, a = e.length; c < a; c++) {
                e[c].destroy()
            }
            d.operateRegions = null
        }
        d.sourceDataset = null;
        d.sourceDatasetFields = null;
        if (d.sourceDatasetFilter) {
            d.sourceDatasetFilter.destroy();
            d.sourceDatasetFilter = null
        }
        d.tolerance = null;
        if (d.resultSetting) {
            d.resultSetting.destroy();
            d.resultSetting = null
        }
    },
    CLASS_NAME: "SuperMap.REST.DatasetOverlayAnalystParameters"
});
SuperMap.REST.DatasetOverlayAnalystParameters.toObject = function(a, c) {
    for (var e in a) {
        if (e == "sourceDataset") {} else {
            if (e == "operateRegions") {
                c.operateRegions = new Array();
                for (var d in a.operateRegions) {
                    c.operateRegions[d] = SuperMap.REST.ServerGeometry.fromGeometry(a.operateRegions[d])
                }
            } else {
                if (e == "resultSetting") {
                    c.dataReturnOption = a.resultSetting
                } else {
                    c[e] = a[e]
                }
            }
        }
    }
}
;
SuperMap.REST.OverlayAnalystEventArgs = SuperMap.Class(SuperMap.ServiceEventArgs, {
    result: null,
    initialize: function(a, d) {
        SuperMap.ServiceEventArgs.prototype.initialize.apply(this, [d]);
        var c = this;
        c.result = a
    },
    destroy: function() {
        SuperMap.ServiceEventArgs.prototype.destroy.apply(this);
        var a = this;
        if (a.result) {
            a.result.destroy();
            a.result = null
        }
    },
    CLASS_NAME: "SuperMap.REST.OverlayAnalystEventArgs"
});
SuperMap.REST.OverlayAnalystService = SuperMap.Class(SuperMap.ServiceBase, {
    EVENT_TYPES: ["processCompleted", "processFailed"],
    events: null,
    eventListeners: null,
    lastResult: null,
    mode: null,
    initialize: function(c, a) {
        SuperMap.ServiceBase.prototype.initialize.apply(this, [c]);
        var d = this;
        if (a) {
            SuperMap.Util.extend(d, a)
        }
        d.events = new SuperMap.Events(d,null,d.EVENT_TYPES,true);
        if (d.eventListeners instanceof Object) {
            d.events.on(d.eventListeners)
        }
    },
    destroy: function() {
        SuperMap.ServiceBase.prototype.destroy.apply(this, arguments);
        var a = this;
        a.EVENT_TYPES = null;
        if (a.events) {
            a.events.destroy();
            a.events = null
        }
        if (a.eventListeners) {
            a.eventListeners = null
        }
        if (a.lastResult) {
            a.lastResult.destroy();
            a.lastResult = null
        }
        a.mode = null
    },
    processAsync: function(f) {
        var d = new Object();
        var c = this;
        var a = c.url.substr(c.url.length - 1, 1);
        if (a == "/") {} else {
            c.url += "/"
        }
        if (f instanceof SuperMap.REST.DatasetOverlayAnalystParameters) {
            c.mode = "datasets";
            c.url += "datasets/" + f.sourceDataset + "/overlay";
            SuperMap.REST.DatasetOverlayAnalystParameters.toObject(f, d)
        } else {
            if (f instanceof SuperMap.REST.GeometryOverlayAnalystParameters) {
                c.mode = "geometry";
                c.url += "geometry/overlay";
                SuperMap.REST.GeometryOverlayAnalystParameters.toObject(f, d)
            }
        }
        var e = SuperMap.Util.toJSON(d);
        if (c.isInTheSameDomain) {
            c.url += ".json?returnContent=true"
        } else {
            c.url += ".jsonp?returnContent=true"
        }
        c.request({
            method: "POST",
            data: e,
            scope: c,
            success: c.analyzeComplete,
            failure: c.analyzeError
        })
    },
    analyzeComplete: function(c) {
        c = SuperMap.Util.transformResult(c);
        if (this.mode == "datasets") {
            var a = SuperMap.REST.DatasetOverlayAnalystResult.fromJson(c)
        } else {
            if (this.mode == "geometry") {
                var a = SuperMap.REST.GeometryOverlayAnalystResult.fromJson(c)
            }
        }
        this.mode = null;
        this.lastResult = a;
        var d = new SuperMap.REST.OverlayAnalystEventArgs(a,c);
        this.events.triggerEvent("processCompleted", d)
    },
    analyzeError: function(c) {
        var e = this
          , d = null
          , a = null
          , f = null;
        c = SuperMap.Util.transformResult(c);
        d = c.error;
        if (!d) {
            return
        }
        a = SuperMap.ServiceException.fromJson(d);
        f = new SuperMap.ServiceFailedEventArgs(a,c);
        e.events.triggerEvent("processFailed", f)
    },
    CLASS_NAME: "SuperMap.REST.OverlayAnalystService"
});
SuperMap.REST.GenerateSpatialDataResult = SuperMap.Class(SuperMap.REST.SpatialAnalystResult, {
    dataset: null,
    recordset: null,
    succeed: null,
    message: null,
    initialize: function(a) {
        SuperMap.REST.SpatialAnalystResult.prototype.initialize.apply(this, arguments);
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        var a = this;
        if (a.recordset) {
            a.recordset.destroy();
            a.recordset = null
        }
        a.dataset = null;
        a.succeed = null;
        a.message = null
    },
    CLASS_NAME: "SuperMap.REST.GenerateSpatialDataResult"
});
SuperMap.REST.GenerateSpatialDataResult.fromJson = function(c) {
    if (!c) {
        return
    }
    var a = new SuperMap.REST.GenerateSpatialDataResult();
    if (c.recordset) {
        a.recordset = SuperMap.REST.Recordset.fromJson(c.recordset)
    }
    if (c.dataset) {
        a.dataset = c.dataset
    }
    a.succeed = c.succeed;
    a.message = c.message;
    return a
}
;
SuperMap.REST.GenerateSpatialDataEventArgs = SuperMap.Class(SuperMap.ServiceEventArgs, {
    result: null,
    initialize: function(a, d) {
        SuperMap.ServiceEventArgs.prototype.initialize.apply(this, [d]);
        var c = this;
        c.result = a
    },
    destroy: function() {
        SuperMap.ServiceEventArgs.prototype.destroy.apply(this, arguments);
        var a = this;
        if (a.result) {
            a.result.destroy();
            a.result = null
        }
    },
    CLASS_NAME: "SuperMap.REST.GenerateSpatialDataEventArgs"
});
SuperMap.REST.GenerateSpatialDataParameters = SuperMap.Class({
    routeTable: null,
    routeIDField: null,
    eventTable: null,
    eventRouteIDField: null,
    measureField: null,
    measureStartField: null,
    measureEndField: null,
    measureOffsetField: null,
    errorInfoField: null,
    dataReturnOption: null,
    initialize: function(a) {
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        var a = this;
        if (a.routeTable) {
            a.routeTable = null
        }
        a.routeIDField = null;
        a.eventTable = null;
        a.eventRouteIDField = null;
        a.measureField = null;
        a.measureStartField = null;
        a.measureEndField = null;
        a.measureOffsetField = null;
        a.errorInfoField = null;
        if (a.dataReturnOption) {
            a.dataReturnOption.destroy();
            a.dataReturnOption = null
        }
    },
    CLASS_NAME: "SuperMap.REST.GenerateSpatialDataParameters"
});
SuperMap.REST.GenerateSpatialDataService = SuperMap.Class(SuperMap.ServiceBase, {
    EVENT_TYPES: ["processCompleted", "processFailed"],
    events: null,
    eventListeners: null,
    lastResult: null,
    initialize: function(c, a) {
        SuperMap.ServiceBase.prototype.initialize.apply(this, [c]);
        var d = this;
        if (a) {
            SuperMap.Util.extend(d, a)
        }
        d.events = new SuperMap.Events(d,null,d.EVENT_TYPES,true);
        if (d.eventListeners instanceof Object) {
            d.events.on(d.eventListeners)
        }
    },
    destroy: function() {
        SuperMap.ServiceBase.prototype.destroy.apply(this, arguments);
        var a = this;
        a.EVENT_TYPES = null;
        if (a.events) {
            a.events.destroy();
            a.events = null
        }
        if (a.eventListeners) {
            a.eventListeners = null
        }
        if (a.lastResult) {
            a.lastResult.destroy();
            a.lastResult = null
        }
    },
    processAsync: function(d) {
        if (!d) {
            return
        }
        var a = this, c;
        c = a.getJsonParameters(d);
        a.request({
            method: "POST",
            data: c,
            scope: a,
            success: a.GenerateSpatialDataComplete,
            failure: a.GenerateSpatialDataError
        })
    },
    GenerateSpatialDataComplete: function(a) {
        var e = this
          , d = null
          , c = null;
        a = SuperMap.Util.transformResult(a);
        c = new SuperMap.REST.GenerateSpatialDataResult.fromJson(a);
        e.lastResult = c;
        d = new SuperMap.REST.GenerateSpatialDataEventArgs(c,a);
        e.events.triggerEvent("processCompleted", d)
    },
    GenerateSpatialDataError: function(c) {
        var f = this
          , e = null
          , a = null
          , d = null;
        c = SuperMap.Util.transformResult(c);
        e = c.error;
        if (!e) {
            return
        }
        a = SuperMap.ServiceException.fromJson(e);
        d = new SuperMap.ServiceFailedEventArgs(a,c);
        f.events.triggerEvent("processFailed", d)
    },
    getJsonParameters: function(f) {
        var e = "", a = "datasets/" + f.routeTable + "/linearreferencing/generatespatialdata", d = this, c;
        c = d.url.substr(d.url.length - 1, 1);
        if (d.isInTheSameDomain) {
            d.url += (c === "/") ? a + ".json" : "/" + a + ".json"
        } else {
            d.url += (c === "/") ? a + ".jsonp" : "/" + a + ".jsonp"
        }
        d.url += "?returnContent=true";
        e = SuperMap.Util.toJSON(f);
        return e
    },
    CLASS_NAME: "SuperMap.REST.GenerateSpatialDataService"
});
SuperMap.REST.GeoRelationResult = SuperMap.Class({
    count: null,
    result: null,
    source: null,
    isFeatureResult: null,
    initialize: function(a) {
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        var d = this, c, a;
        d.count = null;
        if (d.isFeatureResult) {
            if (d.result) {
                a = d.result.length;
                for (c = 0; c < a; c++) {
                    d.result[c].destroy();
                    d.result[c] = null
                }
            }
            if (d.source) {
                d.source.destroy()
            }
        }
        d.result = null;
        d.source = null;
        d.isFeatureResult = null
    },
    CLASS_NAME: "SuperMap.REST.GeoRelationResult"
});
SuperMap.REST.GeoRelationResult.fromJson = function(f) {
    if (!f) {
        return
    }
    var g, d, c = [];
    if (f.result && f.result instanceof Array) {
        var e, h, a = f.result.length;
        for (e = 0; e < a; e++) {
            h = f.result[e];
            if (typeof h === "object") {
                c.push(SuperMap.REST.ServerFeature.fromJson(h).toFeature())
            } else {
                c.push(h)
            }
        }
    }
    if (typeof f.source === "object") {
        g = SuperMap.REST.ServerFeature.fromJson(f.source).toFeature();
        d = true
    } else {
        g = f.source;
        d = false
    }
    return new SuperMap.REST.GeoRelationResult({
        count: f.count,
        result: c,
        source: g,
        isFeatureResult: d
    })
}
;
SuperMap.REST.GeoRelationAnalystEventArgs = SuperMap.Class(SuperMap.ServiceEventArgs, {
    result: null,
    initialize: function(a, d) {
        SuperMap.ServiceEventArgs.prototype.initialize.apply(this, [d]);
        var c = this;
        c.result = a
    },
    destroy: function() {
        SuperMap.ServiceEventArgs.prototype.destroy.apply(this, arguments);
        var a = this;
        if (a.result) {
            a.result.destroy();
            a.result = null
        }
    },
    CLASS_NAME: "SuperMap.REST.GeoRelationAnalystEventArgs"
});
SuperMap.REST.GeoRelationAnalystParameters = SuperMap.Class({
    dataset: null,
    sourceFilter: null,
    referenceFilter: null,
    spatialRelationType: null,
    isBorderInside: null,
    returnFeature: null,
    returnGeoRelatedOnly: null,
    startRecord: 0,
    expectCount: 500,
    initialize: function(a) {
        var c = this;
        if (a) {
            SuperMap.Util.extend(c, a)
        }
    },
    destroy: function() {
        var a = this;
        if (a.sourceFilter) {
            a.sourceFilter.destroy()
        }
        a.sourceFilter = null;
        if (a.referenceFilter) {
            a.referenceFilter.destroy()
        }
        a.referenceFilter = null;
        a.dataset = null;
        a.spatialRelationType = null;
        a.isBorderInside = null;
        a.returnFeature = null;
        a.returnGeoRelatedOnly = null;
        a.startRecord = null;
        a.expectCount = null
    },
    CLASS_NAME: "SuperMap.REST.GeoRelationAnalystParameters"
});
SuperMap.REST.GeoRelationAnalystResult = SuperMap.Class({
    geoRelationResults: null,
    initialize: function(a) {
        if (!a) {
            return
        }
        SuperMap.Util.extend(this, a)
    },
    destroy: function() {
        var d = this
          , e = d.geoRelationResults;
        if (e) {
            var a = e.length;
            for (var c = 0; c < a; c++) {
                e[c].destroy()
            }
        }
        d.geoRelationResults = null
    },
    CLASS_NAME: "SuperMap.REST.GeoRelationAnalystResult"
});
SuperMap.REST.GeoRelationAnalystResult.fromJson = function(e) {
    if (e && e instanceof Array) {
        var c, f = [], a = e.length;
        for (var d = 0; d < a; d++) {
            c = SuperMap.REST.GeoRelationResult.fromJson(e[d]);
            f.push(c)
        }
        return new SuperMap.REST.GeoRelationAnalystResult({
            geoRelationResults: f
        })
    }
}
;
SuperMap.REST.GeoRelationAnalystService = SuperMap.Class(SuperMap.ServiceBase, {
    EVENT_TYPES: ["processCompleted", "processFailed"],
    events: null,
    eventListeners: null,
    lastResult: null,
    initialize: function(c, a) {
        SuperMap.ServiceBase.prototype.initialize.apply(this, [c]);
        var d = this;
        if (a) {
            SuperMap.Util.extend(d, a)
        }
        d.events = new SuperMap.Events(d,null,d.EVENT_TYPES,true);
        if (d.eventListeners instanceof Object) {
            d.events.on(d.eventListeners)
        }
    },
    destroy: function() {
        SuperMap.ServiceBase.prototype.destroy.apply(this, arguments);
        var a = this;
        a.EVENT_TYPES = null;
        if (a.events) {
            a.events.destroy();
            a.events = null
        }
        if (a.eventListeners) {
            a.eventListeners = null
        }
        if (a.lastResult) {
            a.lastResult.destroy();
            a.lastResult = null
        }
    },
    processAsync: function(e) {
        var c = this;
        var a = c.url.substr(c.url.length - 1, 1);
        if (a == "/") {
            c.url += "datasets/" + e.dataset + "/georelation"
        } else {
            c.url += "/datasets/" + e.dataset + "/georelation"
        }
        var d = SuperMap.Util.toJSON(e);
        if (c.isInTheSameDomain) {
            c.url += ".json?returnContent=true"
        } else {
            c.url += ".jsonp?returnContent=true"
        }
        c.request({
            method: "POST",
            data: d,
            scope: c,
            success: c.geoRelationAnalystComplete,
            failure: c.geoRelationAnalystError
        })
    },
    geoRelationAnalystComplete: function(a) {
        var c = this, a, e, d;
        a = SuperMap.Util.transformResult(a);
        d = SuperMap.REST.GeoRelationAnalystResult.fromJson(a);
        c.lastResult = d;
        e = new SuperMap.REST.GeoRelationAnalystEventArgs(d,a);
        c.events.triggerEvent("processCompleted", e)
    },
    geoRelationAnalystError: function(c) {
        var e = this
          , d = null
          , a = null
          , f = null;
        c = SuperMap.Util.transformResult(c);
        d = c.error;
        if (!d) {
            return
        }
        a = SuperMap.ServiceException.fromJson(d);
        f = new SuperMap.ServiceFailedEventArgs(a,c);
        e.events.triggerEvent("processFailed", f)
    },
    CLASS_NAME: "SuperMap.REST.GeoRelationAnalystService"
});
SuperMap.REST.ThiessenAnalystEventArgs = SuperMap.Class(SuperMap.ServiceEventArgs, {
    result: null,
    initialize: function(a, d) {
        SuperMap.ServiceEventArgs.prototype.initialize.apply(this, [d]);
        var c = this;
        c.result = a
    },
    destroy: function() {
        SuperMap.ServiceEventArgs.prototype.destroy.apply(this);
        var a = this;
        if (a.result) {
            a.result.destroy();
            a.result = null
        }
    },
    CLASS_NAME: "SuperMap.REST.ThiessenAnalystEventArgs"
});
SuperMap.REST.ThiessenAnalystParameters = SuperMap.Class({
    clipRegion: null,
    createResultDataset: false,
    resultDatasetName: null,
    resultDatasourceName: null,
    returnResultRegion: true,
    initialize: function(a) {
        if (!a) {
            return
        }
        SuperMap.Util.extend(this, a)
    },
    destroy: function() {
        var a = this;
        if (a.clipRegion) {
            a.clipRegion.destroy();
            a.clipRegion = null
        }
        a.createResultDataset = null;
        a.resultDatasetName = null;
        a.resultDatasourceName = null;
        a.returnResultRegion = null
    },
    CLASS_NAME: "SuperMap.REST.ThiessenAnalystParameters"
});
SuperMap.REST.ThiessenAnalystResult = SuperMap.Class({
    datasetName: null,
    datasourceName: null,
    regions: null,
    initialize: function(a) {
        if (!a) {
            return
        }
        SuperMap.Util.extend(this, a)
    },
    destroy: function() {
        var d = this;
        if (d.regions) {
            for (var c = 0, a = d.regions.length; c < a; c++) {
                d.regions[c].destroy()
            }
            d.regions = null
        }
        d.datasetName = null;
        d.datasourceName = null
    },
    CLASS_NAME: "SuperMap.REST.ThiessenAnalystResult"
});
SuperMap.REST.ThiessenAnalystResult.fromJson = function(e) {
    if (!e) {
        return
    }
    var c = new SuperMap.REST.ThiessenAnalystResult();
    if (e.datasetName) {
        c.datasetName = e.datasetName
    }
    if (e.datasourceName) {
        c.datasourceName = e.datasourceName
    }
    var f = [];
    if (e.regions) {
        for (var d = 0, a = e.regions.length; d < a; d++) {
            f.push(SuperMap.REST.ServerGeometry.fromJson(e.regions[d]).toGeometry())
        }
        c.regions = f
    }
    return c
}
;
SuperMap.REST.ThiessenAnalystService = SuperMap.Class(SuperMap.ServiceBase, {
    EVENT_TYPES: ["processCompleted", "processFailed"],
    events: null,
    eventListeners: null,
    lastResult: null,
    mode: null,
    initialize: function(c, a) {
        SuperMap.ServiceBase.prototype.initialize.apply(this, [c]);
        var d = this;
        if (a) {
            SuperMap.Util.extend(d, a)
        }
        d.events = new SuperMap.Events(d,null,d.EVENT_TYPES,true);
        if (d.eventListeners instanceof Object) {
            d.events.on(d.eventListeners)
        }
    },
    destroy: function() {
        SuperMap.ServiceBase.prototype.destroy.apply(this, arguments);
        var a = this;
        a.EVENT_TYPES = null;
        if (a.events) {
            a.events.destroy();
            a.events = null
        }
        if (a.eventListeners) {
            a.eventListeners = null
        }
        if (a.lastResult) {
            a.lastResult.destroy();
            a.lastResult = null
        }
        a.mode = null
    },
    processAsync: function(f) {
        var d = new Object();
        var c = this;
        var a = c.url.substr(c.url.length - 1, 1);
        if (a == "/") {} else {
            c.url += "/"
        }
        if (f instanceof SuperMap.REST.DatasetThiessenAnalystParameters) {
            c.mode = "datasets";
            c.url += "datasets/" + f.dataset + "/thiessenpolygon";
            SuperMap.REST.DatasetThiessenAnalystParameters.toObject(f, d)
        } else {
            if (f instanceof SuperMap.REST.GeometryThiessenAnalystParameters) {
                c.mode = "geometry";
                c.url += "geometry/thiessenpolygon";
                SuperMap.REST.GeometryThiessenAnalystParameters.toObject(f, d)
            }
        }
        var e = SuperMap.Util.toJSON(d);
        if (c.isInTheSameDomain) {
            c.url += ".json?returnContent=true"
        } else {
            c.url += ".jsonp?returnContent=true"
        }
        c.request({
            method: "POST",
            data: e,
            scope: c,
            success: c.analyzeComplete,
            failure: c.analyzeError
        })
    },
    analyzeComplete: function(c) {
        c = SuperMap.Util.transformResult(c);
        var a = SuperMap.REST.ThiessenAnalystResult.fromJson(c);
        this.lastResult = a;
        var d = new SuperMap.REST.ThiessenAnalystEventArgs(a,c);
        this.events.triggerEvent("processCompleted", d)
    },
    analyzeError: function(c) {
        var e = this
          , d = null
          , a = null
          , f = null;
        c = SuperMap.Util.transformResult(c);
        d = c.error;
        if (!d) {
            return
        }
        a = SuperMap.ServiceException.fromJson(d);
        f = new SuperMap.ServiceFailedEventArgs(a,c);
        e.events.triggerEvent("processFailed", f)
    },
    CLASS_NAME: "SuperMap.REST.ThiessenAnalystService"
});
SuperMap.REST.GeometryThiessenAnalystParameters = SuperMap.Class(SuperMap.REST.ThiessenAnalystParameters, {
    points: null,
    initialize: function(a) {
        SuperMap.REST.ThiessenAnalystParameters.prototype.initialize.apply(this, arguments);
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        SuperMap.REST.ThiessenAnalystParameters.prototype.destroy.apply(this, arguments);
        var c = this;
        if (c.points) {
            for (var a = c.points.length - 1; a >= 0; a--) {
                c.points[a].destroy()
            }
            c.points = null
        }
    },
    CLASS_NAME: "SuperMap.REST.GeometryThiessenAnalystParameters"
});
SuperMap.REST.GeometryThiessenAnalystParameters.toObject = function(c, a) {
    for (var d in c) {
        if (d == "clipRegion") {
            a.clipRegion = SuperMap.REST.ServerGeometry.fromGeometry(c.clipRegion)
        } else {
            a[d] = c[d]
        }
    }
}
;
SuperMap.REST.DatasetThiessenAnalystParameters = SuperMap.Class(SuperMap.REST.ThiessenAnalystParameters, {
    filterQueryParameter: null,
    dataset: null,
    initialize: function(a) {
        SuperMap.REST.ThiessenAnalystParameters.prototype.initialize.apply(this, arguments);
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        SuperMap.REST.ThiessenAnalystParameters.prototype.destroy.apply(this, arguments);
        var a = this;
        if (a.filterQueryParameter) {
            a.filterQueryParameter.destroy();
            a.filterQueryParameter = null
        }
    },
    CLASS_NAME: "SuperMap.REST.DatasetThiessenAnalystParameters"
});
SuperMap.REST.DatasetThiessenAnalystParameters.toObject = function(d, a) {
    for (var c in d) {
        if (c == "clipRegion") {
            a.clipRegion = SuperMap.REST.ServerGeometry.fromGeometry(d.clipRegion)
        } else {
            a[c] = d[c]
        }
    }
}
;
SuperMap.REST.PointWithMeasure = SuperMap.Class(SuperMap.Geometry.Point, {
    x: null,
    y: null,
    measure: null,
    initialize: function(a) {
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        var a = this;
        a.measure = null;
        a.x = null;
        a.y = null
    },
    CLASS_NAME: "SuperMap.REST.PointWithMeasure"
});
SuperMap.REST.PointWithMeasure.fromJson = function(a) {
    if (!a) {
        return
    }
    return new SuperMap.REST.PointWithMeasure({
        x: a.x,
        y: a.y,
        measure: a.measure
    })
}
;
SuperMap.REST.Route = SuperMap.Class(SuperMap.Geometry.LineString, {
    length: null,
    maxM: null,
    minM: null,
    parts: null,
    type: null,
    initialize: function(c, a) {
        SuperMap.Geometry.LineString.prototype.initialize.apply(this, arguments);
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        var a = this;
        a.length = null;
        a.maxM = null;
        a.minM = null;
        a.type = null;
        a.parts = null
    },
    CLASS_NAME: "SuperMap.REST.Route"
});
SuperMap.REST.Route.fromJson = function(e) {
    if (!e) {
        return
    }
    var g = [];
    if (e.points) {
        for (var d = 0, f = e.points, c = f.length; d < c; d++) {
            g.push(SuperMap.REST.PointWithMeasure.fromJson(f[d]))
        }
    }
    var a = new SuperMap.REST.Route(g,{
        length: e.length,
        maxM: e.maxM,
        minM: e.minM,
        type: e.type,
        parts: e.parts
    });
    return a
}
;
SuperMap.REST.PathGuideItem = SuperMap.Class({
    bounds: null,
    directionType: null,
    distance: null,
    id: null,
    index: null,
    isEdge: null,
    isStop: null,
    length: null,
    name: null,
    sideType: null,
    turnAngle: null,
    turnType: null,
    weight: null,
    description: null,
    geometry: null,
    initialize: function(a) {
        if (!a) {
            return
        }
        SuperMap.Util.extend(this, a)
    },
    destroy: function() {
        var a = this;
        a.bounds = null;
        a.directionType = null;
        a.distance = null;
        a.id = null;
        a.index = null;
        a.isEdge = null;
        a.isStop = null;
        a.length = null;
        a.name = null;
        a.sideType = null;
        a.turnAngle = null;
        a.turnType = null;
        a.weight = null;
        a.description = null;
        if (a.geometry) {
            a.geometry.destroy()
        }
        a.geometry = null
    },
    CLASS_NAME: "SuperMap.REST.PathGuideItem"
});
SuperMap.REST.PathGuideItem.fromJson = function(a) {
    var c = new SuperMap.Bounds(a.bounds.left,a.bounds.bottom,a.bounds.right,a.bounds.top);
    return new SuperMap.REST.PathGuideItem({
        bounds: c,
        directionType: a.directionType,
        distance: a.distance,
        id: a.id,
        index: a.index,
        isEdge: a.isEdge,
        isStop: a.isStop,
        length: a.length,
        name: a.name,
        sideType: a.sideType,
        turnAngle: a.turnAngle,
        turnType: a.turnType,
        weight: a.weight,
        description: a.description,
        geometry: SuperMap.REST.ServerGeometry.fromJson(a.geometry).toGeometry()
    })
}
;
SuperMap.REST.Path = SuperMap.Class({
    edgeFeatures: null,
    edgeIDs: null,
    nodeFeatures: null,
    nodeIDs: null,
    pathGuideItems: null,
    route: null,
    stopWeights: null,
    weight: null,
    initialize: function(a) {
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        var d = this;
        if (d.edgeFeatures) {
            for (var c = 0, a = d.edgeFeatures.length; c < a; c++) {
                d.edgeFeatures[c].destroy()
            }
            d.edgeFeatures = null
        }
        if (d.edgeIDs) {
            d.edgeIDs.length = 0;
            d.edgeIDs = null
        }
        if (d.nodeFeatures) {
            for (var c = 0, a = d.nodeFeatures.length; c < a; c++) {
                d.nodeFeatures[c].destroy()
            }
            d.nodeFeatures = null
        }
        if (d.nodeIDs) {
            d.nodeIDs.length = 0;
            d.nodeIDs = null
        }
        if (d.pathGuideItems) {
            for (var c = 0, a = d.pathGuideItems.length; c < a; c++) {
                d.pathGuideItems[c].destroy()
            }
            d.pathGuideItems = null
        }
        d.route = null;
        if (d.stopWeights) {
            d.stopWeights.length = 0;
            d.stopWeights = null
        }
        d.weight = null
    },
    CLASS_NAME: "SuperMap.REST.Path"
});
SuperMap.REST.Path.fromJson = function(g) {
    if (!g) {
        return
    }
    var d = new SuperMap.REST.Path({
        edgeIDs: g.edgeIDs,
        nodeIDs: g.nodeIDs,
        stopWeights: g.stopWeights,
        weight: g.weight
    });
    if (g.edgeFeatures) {
        d.edgeFeatures = [];
        for (var f = 0, c = g.edgeFeatures, a = c.length; f < a; f++) {
            d.edgeFeatures[f] = SuperMap.REST.ServerFeature.fromJson(c[f]).toFeature()
        }
    }
    if (g.nodeFeatures) {
        d.nodeFeatures = [];
        for (var f = 0, h = g.nodeFeatures, a = h.length; f < a; f++) {
            d.nodeFeatures[f] = SuperMap.REST.ServerFeature.fromJson(h[f]).toFeature()
        }
    }
    if (g.pathGuideItems) {
        d.pathGuideItems = [];
        for (var f = 0, e = g.pathGuideItems, a = e.length; f < a; f++) {
            d.pathGuideItems[f] = SuperMap.REST.PathGuideItem.fromJson(e[f])
        }
    }
    d.route = SuperMap.REST.Route.fromJson(g.route);
    return d
}
;
SuperMap.REST.FindPathResult = SuperMap.Class({
    pathList: null,
    initialize: function(a) {
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        var d = this;
        if (d.pathList) {
            for (var c = 0, a = d.pathList.length; c < a; c++) {
                d.pathList[c].destroy()
            }
            d.pathList = null
        }
    },
    CLASS_NAME: "SuperMap.REST.FindPathResult"
});
SuperMap.REST.FindPathResult.fromJson = function(e) {
    if (!e) {
        return
    }
    var c = new SuperMap.REST.FindPathResult();
    if (e.pathList) {
        c.pathList = [];
        for (var d = 0, f = e.pathList, a = f.length; d < a; d++) {
            c.pathList[d] = SuperMap.REST.Path.fromJson(f[d])
        }
    }
    return c
}
;
SuperMap.REST.FindPathEventArgs = SuperMap.Class(SuperMap.ServiceEventArgs, {
    result: null,
    initialize: function(a, d) {
        SuperMap.ServiceEventArgs.prototype.initialize.apply(this, [d]);
        var c = this;
        c.result = a
    },
    destroy: function() {
        SuperMap.ServiceEventArgs.prototype.destroy.apply(this);
        var a = this;
        if (a.result) {
            a.result.destroy();
            a.result = null
        }
    },
    CLASS_NAME: "SuperMap.REST.FindPathEventArgs"
});
SuperMap.REST.TransportationAnalystResultSetting = SuperMap.Class({
    returnEdgeFeatures: false,
    returnEdgeGeometry: false,
    returnEdgeIDs: false,
    returnNodeFeatures: false,
    returnNodeGeometry: false,
    returnNodeIDs: false,
    returnPathGuides: false,
    returnRoutes: false,
    initialize: function(a) {
        if (!a) {
            return
        }
        SuperMap.Util.extend(this, a)
    },
    destroy: function() {
        var a = this;
        a.returnEdgeFeatures = null;
        a.returnEdgeGeometry = null;
        a.returnEdgeIDs = null;
        a.returnNodeFeatures = null;
        a.returnNodeGeometry = null;
        a.returnNodeIDs = null;
        a.returnPathGuides = null;
        a.returnRoutes = null
    },
    CLASS_NAME: "SuperMap.REST.TransportationAnalystResultSetting"
});
SuperMap.REST.TransportationAnalystParameter = SuperMap.Class({
    barrierEdgeIDs: null,
    barrierNodeIDs: null,
    barrierPoints: null,
    weightFieldName: null,
    turnWeightField: null,
    resultSetting: null,
    initialize: function(a) {
        var c = this;
        c.resultSetting = new SuperMap.REST.TransportationAnalystResultSetting();
        if (!a) {
            return
        }
        SuperMap.Util.extend(this, a)
    },
    destroy: function() {
        var c = this;
        c.barrierEdgeIDs = null;
        c.barrierNodeIDs = null;
        c.weightFieldName = null;
        c.turnWeightField = null;
        if (c.resultSetting) {
            c.resultSetting.destroy();
            c.resultSetting = null
        }
        if (c.barrierPoints && c.barrierPoints.length) {
            for (var a in c.barrierPoints) {
                c.barrierPoints.destroy()
            }
        }
        c.barrierPoints = null
    },
    CLASS_NAME: "SuperMap.REST.TransportationAnalystParameter"
});
SuperMap.REST.FindPathParameters = SuperMap.Class({
    isAnalyzeById: false,
    hasLeastEdgeCount: null,
    nodes: null,
    parameter: null,
    initialize: function(a) {
        var c = this;
        c.parameter = new SuperMap.REST.TransportationAnalystParameter();
        if (!a) {
            return
        }
        SuperMap.Util.extend(this, a)
    },
    destroy: function() {
        var a = this;
        a.isAnalyzeById = null;
        a.hasLeastEdgeCount = null;
        a.nodes = null;
        if (a.parameter) {
            a.parameter.destroy();
            a.parameter = null
        }
    },
    CLASS_NAME: "SuperMap.REST.FindPathParameters"
});
SuperMap.REST.FindPathService = SuperMap.Class(SuperMap.ServiceBase, {
    EVENT_TYPES: ["processCompleted", "processFailed"],
    events: null,
    eventListeners: null,
    lastResult: null,
    initialize: function(c, a) {
        SuperMap.ServiceBase.prototype.initialize.apply(this, arguments);
        var d = this;
        if (a) {
            SuperMap.Util.extend(d, a)
        }
        d.events = new SuperMap.Events(d,null,d.EVENT_TYPES,true);
        if (d.eventListeners instanceof Object) {
            d.events.on(d.eventListeners)
        }
    },
    destroy: function() {
        SuperMap.ServiceBase.prototype.destroy.apply(this, arguments);
        var a = this;
        a.EVENT_TYPES = null;
        a.events = null;
        a.eventListeners = null;
        if (a.lastResult) {
            a.lastResult.destroy();
            a.lastResult = null
        }
    },
    processAsync: function(e) {
        if (!e) {
            return
        }
        var d = this, c, a = d.url.substr(d.url.length - 1, 1);
        d.url = d.url + ((a == "/") ? "path" : "/path") + (this.isInTheSameDomain ? ".json?" : ".jsonp?");
        c = {
            hasLeastEdgeCount: e.hasLeastEdgeCount,
            parameter: SuperMap.Util.toJSON(e.parameter),
            nodes: d.getJson(e.isAnalyzeById, e.nodes)
        };
        d.request({
            method: "GET",
            params: c,
            scope: d,
            success: d.findPathComplete,
            failure: d.findPathError
        })
    },
    getJson: function(e, f) {
        var d = "["
          , a = f ? f.length : 0;
        if (e === false) {
            for (var c = 0; c < a; c++) {
                if (c > 0) {
                    d += ","
                }
                d += '{"x":' + f[c].x + ',"y":' + f[c].y + "}"
            }
        } else {
            if (e == true) {
                for (var c = 0; c < a; c++) {
                    if (c > 0) {
                        d += ","
                    }
                    d += f[c]
                }
            }
        }
        d += "]";
        return d
    },
    findPathComplete: function(a) {
        var d = this, e, c;
        a = SuperMap.Util.transformResult(a);
        e = SuperMap.REST.FindPathResult.fromJson(a);
        d.lastResult = e;
        c = new SuperMap.REST.FindPathEventArgs(e,a);
        d.events.triggerEvent("processCompleted", c)
    },
    findPathError: function(c) {
        var e = this
          , d = null
          , a = null
          , f = null;
        c = SuperMap.Util.transformResult(c);
        d = c.error;
        if (!d) {
            return
        }
        a = SuperMap.ServiceException.fromJson(d);
        f = new SuperMap.ServiceFailedEventArgs(a,c);
        e.events.triggerEvent("processFailed", f)
    },
    CLASS_NAME: "SuperMap.REST.FindPathService"
});
SuperMap.REST.ComputeWeightMatrixResult = SuperMap.Class({
    weightMatrix: null,
    initialize: function(a) {
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        var a = this;
        if (a.weightMatrix) {
            a.weightMatrix.length = 0;
            a.weightMatrix = null
        }
    },
    CLASS_NAME: "SuperMap.REST.ComputeWeightMatrixResult"
});
SuperMap.REST.ComputeWeightMatrixResult.fromJson = function(a) {
    if (!a) {
        return
    }
    return result = new SuperMap.REST.ComputeWeightMatrixResult({
        weightMatrix: a
    })
}
;
SuperMap.REST.ComputeWeightMatrixEventArgs = SuperMap.Class(SuperMap.ServiceEventArgs, {
    result: null,
    initialize: function(a, d) {
        SuperMap.ServiceEventArgs.prototype.initialize.apply(this, [d]);
        var c = this;
        c.result = a
    },
    destroy: function() {
        SuperMap.ServiceEventArgs.prototype.destroy.apply(this);
        var a = this;
        if (a.result) {
            a.result.destroy();
            a.result = null
        }
    },
    CLASS_NAME: "SuperMap.REST.ComputeWeightMatrixEventArgs"
});
SuperMap.REST.ComputeWeightMatrixParameters = SuperMap.Class({
    isAnalyzeById: false,
    nodes: null,
    parameter: null,
    initialize: function(a) {
        var c = this;
        c.parameter = new SuperMap.REST.TransportationAnalystParameter();
        if (!a) {
            return
        }
        SuperMap.Util.extend(this, a)
    },
    destroy: function() {
        var a = this;
        a.isAnalyzeById = null;
        a.nodes = null;
        if (a.parameter) {
            a.parameter.destroy();
            a.parameter = null
        }
    },
    CLASS_NAME: "SuperMap.REST.ComputeWeightMatrixParameters"
});
SuperMap.REST.ComputeWeightMatrixService = SuperMap.Class(SuperMap.ServiceBase, {
    EVENT_TYPES: ["processCompleted", "processFailed"],
    events: null,
    eventListeners: null,
    lastResult: null,
    initialize: function(c, a) {
        SuperMap.ServiceBase.prototype.initialize.apply(this, arguments);
        var d = this;
        if (a) {
            SuperMap.Util.extend(d, a)
        }
        d.events = new SuperMap.Events(d,null,d.EVENT_TYPES,true);
        if (d.eventListeners instanceof Object) {
            d.events.on(d.eventListeners)
        }
    },
    destroy: function() {
        SuperMap.ServiceBase.prototype.destroy.apply(this, arguments);
        var a = this;
        a.EVENT_TYPES = null;
        a.events = null;
        a.eventListeners = null;
        if (a.lastResult) {
            a.lastResult.destroy();
            a.lastResult = null
        }
    },
    processAsync: function(e) {
        if (!e) {
            return
        }
        var d = this, c, a = d.url.substr(d.url.length - 1, 1);
        d.url = d.url + ((a == "/") ? "weightmatrix" : "/weightmatrix") + (this.isInTheSameDomain ? ".json?" : ".jsonp?");
        c = {
            parameter: SuperMap.Util.toJSON(e.parameter),
            nodes: d.getJson(e.isAnalyzeById, e.nodes)
        };
        d.request({
            method: "GET",
            params: c,
            scope: d,
            success: d.computeWeightMatrixComplete,
            failure: d.computeWeightMatrixError
        })
    },
    getJson: function(e, f) {
        var d = "["
          , a = f ? f.length : 0;
        if (e === false) {
            for (var c = 0; c < a; c++) {
                if (c > 0) {
                    d += ","
                }
                d += '{"x":' + f[c].x + ',"y":' + f[c].y + "}"
            }
        } else {
            if (e == true) {
                for (var c = 0; c < a; c++) {
                    if (c > 0) {
                        d += ","
                    }
                    d += f[c]
                }
            }
        }
        d += "]";
        return d
    },
    computeWeightMatrixComplete: function(a) {
        var d = this, e, c;
        a = SuperMap.Util.transformResult(a);
        e = SuperMap.REST.ComputeWeightMatrixResult.fromJson(a);
        d.lastResult = e;
        c = new SuperMap.REST.ComputeWeightMatrixEventArgs(e,a);
        d.events.triggerEvent("processCompleted", c)
    },
    computeWeightMatrixError: function(c) {
        var e = this
          , d = null
          , a = null
          , f = null;
        c = SuperMap.Util.transformResult(c);
        d = c.error;
        if (!d) {
            return
        }
        a = SuperMap.ServiceException.fromJson(d);
        f = new SuperMap.ServiceFailedEventArgs(a,c);
        e.events.triggerEvent("processFailed", f)
    },
    CLASS_NAME: "SuperMap.REST.ComputeWeightMatrixService"
});
SuperMap.REST.ServiceArea = SuperMap.Class({
    edgeFeatures: null,
    edgeIDs: null,
    nodeFeatures: null,
    nodeIDs: null,
    routes: null,
    serviceRegion: null,
    initialize: function(a) {
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        var d = this;
        if (d.edgeFeatures) {
            for (var c = 0, a = d.edgeFeatures.length; c < a; c++) {
                d.edgeFeatures[c].destroy()
            }
            d.edgeFeatures = null
        }
        if (d.edgeIDs) {
            d.edgeIDs.length = 0;
            d.edgeIDs = null
        }
        if (d.nodeFeatures) {
            for (var c = 0, a = d.nodeFeatures.length; c < a; c++) {
                d.nodeFeatures[c].destroy()
            }
            d.nodeFeatures = null
        }
        if (d.nodeIDs) {
            d.nodeIDs.length = 0;
            d.nodeIDs = null
        }
        if (d.routes) {
            for (var c = 0, a = d.routes.length; c < a; c++) {
                d.routes[c].destroy()
            }
            d.routes = null
        }
        d.serviceRegion && d.serviceRegion.destroy()
    },
    CLASS_NAME: "SuperMap.REST.ServiceArea"
});
SuperMap.REST.ServiceArea.fromJson = function(g) {
    if (!g) {
        return
    }
    var d = new SuperMap.REST.ServiceArea({
        edgeIDs: g.edgeIDs,
        nodeIDs: g.nodeIDs
    });
    if (g.edgeFeatures) {
        d.edgeFeatures = [];
        for (var f = 0, c = g.edgeFeatures, a = c.length; f < a; f++) {
            d.edgeFeatures[f] = SuperMap.REST.ServerFeature.fromJson(c[f]).toFeature()
        }
    }
    if (g.nodeFeatures) {
        d.nodeFeatures = [];
        for (var f = 0, h = g.nodeFeatures, a = h.length; f < a; f++) {
            d.nodeFeatures[f] = SuperMap.REST.ServerFeature.fromJson(h[f]).toFeature()
        }
    }
    if (g.routes) {
        d.routes = [];
        for (var f = 0, e = g.routes, a = e.length; f < a; f++) {
            d.routes[f] = SuperMap.REST.Route.fromJson(e[f])
        }
    }
    g.serviceRegion && (d.serviceRegion = SuperMap.REST.ServerGeometry.fromJson(g.serviceRegion).toGeometry());
    return d
}
;
SuperMap.REST.FindServiceAreasResult = SuperMap.Class({
    serviceAreaList: null,
    initialize: function(a) {
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        var d = this;
        if (d.serviceAreaList) {
            for (var c = 0, a = d.serviceAreaList.length; c < a; c++) {
                d.serviceAreaList[c].destroy()
            }
            d.serviceAreaList = null
        }
    },
    CLASS_NAME: "SuperMap.REST.FindServiceAreasResult"
});
SuperMap.REST.FindServiceAreasResult.fromJson = function(f) {
    if (!f) {
        return
    }
    var c = new SuperMap.REST.FindServiceAreasResult();
    if (f.serviceAreaList) {
        c.serviceAreaList = [];
        for (var e = 0, d = f.serviceAreaList, a = d.length; e < a; e++) {
            c.serviceAreaList[e] = SuperMap.REST.ServiceArea.fromJson(d[e])
        }
    }
    return c
}
;
SuperMap.REST.FindServiceAreasEventArgs = SuperMap.Class(SuperMap.ServiceEventArgs, {
    result: null,
    initialize: function(a, d) {
        SuperMap.ServiceEventArgs.prototype.initialize.apply(this, [d]);
        var c = this;
        c.result = a
    },
    destroy: function() {
        SuperMap.ServiceEventArgs.prototype.destroy.apply(this);
        var a = this;
        if (a.result) {
            a.result.destroy();
            a.result = null
        }
    },
    CLASS_NAME: "SuperMap.REST.FindServiceAreasEventArgs"
});
SuperMap.REST.FindServiceAreasParameters = SuperMap.Class({
    isAnalyzeById: false,
    isCenterMutuallyExclusive: false,
    centers: null,
    isFromCenter: false,
    weights: null,
    parameter: null,
    initialize: function(a) {
        var c = this;
        c.parameter = new SuperMap.REST.TransportationAnalystParameter();
        if (!a) {
            return
        }
        SuperMap.Util.extend(this, a)
    },
    destroy: function() {
        var a = this;
        a.isAnalyzeById = null;
        a.isCenterMutuallyExclusive = null;
        a.centers = null;
        a.isFromCenter = null;
        a.weights = null;
        if (a.parameter) {
            a.parameter.destroy();
            a.parameter = null
        }
    },
    CLASS_NAME: "SuperMap.REST.FindServiceAreasParameters"
});
SuperMap.REST.FindServiceAreasService = SuperMap.Class(SuperMap.ServiceBase, {
    EVENT_TYPES: ["processCompleted", "processFailed"],
    events: null,
    eventListeners: null,
    lastResult: null,
    initialize: function(c, a) {
        SuperMap.ServiceBase.prototype.initialize.apply(this, arguments);
        var d = this;
        if (a) {
            SuperMap.Util.extend(d, a)
        }
        d.events = new SuperMap.Events(d,null,d.EVENT_TYPES,true);
        if (d.eventListeners instanceof Object) {
            d.events.on(d.eventListeners)
        }
    },
    destroy: function() {
        SuperMap.ServiceBase.prototype.destroy.apply(this, arguments);
        var a = this;
        a.EVENT_TYPES = null;
        a.events = null;
        a.eventListeners = null;
        if (a.lastResult) {
            a.lastResult.destroy();
            a.lastResult = null
        }
    },
    processAsync: function(e) {
        if (!e) {
            return
        }
        var d = this, c, a = d.url.substr(d.url.length - 1, 1);
        d.url = d.url + ((a == "/") ? "servicearea" : "/servicearea") + (this.isInTheSameDomain ? ".json?" : ".jsonp?");
        c = {
            isFromCenter: e.isFromCenter,
            isCenterMutuallyExclusive: e.isCenterMutuallyExclusive,
            parameter: SuperMap.Util.toJSON(e.parameter),
            centers: d.getJson(e.isAnalyzeById, e.centers),
            weights: d.getJson(true, e.weights)
        };
        d.request({
            method: "GET",
            params: c,
            scope: d,
            success: d.findServiceAreasComplete,
            failure: d.findServiceAreasError
        })
    },
    getJson: function(e, f) {
        var d = "["
          , a = f ? f.length : 0;
        if (e === false) {
            for (var c = 0; c < a; c++) {
                if (c > 0) {
                    d += ","
                }
                d += '{"x":' + f[c].x + ',"y":' + f[c].y + "}"
            }
        } else {
            if (e == true) {
                for (var c = 0; c < a; c++) {
                    if (c > 0) {
                        d += ","
                    }
                    d += f[c]
                }
            }
        }
        d += "]";
        return d
    },
    findServiceAreasComplete: function(a) {
        var d = this, e, c;
        a = SuperMap.Util.transformResult(a);
        e = SuperMap.REST.FindServiceAreasResult.fromJson(a);
        d.lastResult = e;
        c = new SuperMap.REST.FindServiceAreasEventArgs(e,a);
        d.events.triggerEvent("processCompleted", c)
    },
    findServiceAreasError: function(c) {
        var e = this
          , d = null
          , a = null
          , f = null;
        c = SuperMap.Util.transformResult(c);
        d = c.error;
        if (!d) {
            return
        }
        a = SuperMap.ServiceException.fromJson(d);
        f = new SuperMap.ServiceFailedEventArgs(a,c);
        e.events.triggerEvent("processFailed", f)
    },
    CLASS_NAME: "SuperMap.REST.FindServiceAreasService"
});
SuperMap.REST.ClosestFacilityPath = SuperMap.Class(SuperMap.REST.Path, {
    facility: null,
    facilityIndex: null,
    initialize: function(a) {
        SuperMap.REST.Path.prototype.initialize.apply(this, arguments);
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        SuperMap.REST.Path.prototype.destroy.apply(this, arguments);
        var a = this;
        a.facility = null;
        a.facilityIndex = null
    },
    CLASS_NAME: "SuperMap.REST.ClosestFacilityPath"
});
SuperMap.REST.ClosestFacilityPath.fromJson = function(g) {
    if (!g) {
        return
    }
    var d = new SuperMap.REST.ClosestFacilityPath({
        edgeIDs: g.edgeIDs,
        nodeIDs: g.nodeIDs,
        stopWeights: g.stopWeights,
        weight: g.weight,
        facilityIndex: g.facilityIndex
    });
    if (g.facility && g.facility.x) {
        d.facility = SuperMap.Geometry.Point(g.facility.x, g.facility.y)
    } else {
        d.facility = g.facility
    }
    if (g.edgeFeatures) {
        d.edgeFeatures = [];
        for (var f = 0, c = g.edgeFeatures, a = c.length; f < a; f++) {
            d.edgeFeatures[f] = SuperMap.REST.ServerFeature.fromJson(c[f]).toFeature()
        }
    }
    if (g.nodeFeatures) {
        d.nodeFeatures = [];
        for (var f = 0, h = g.nodeFeatures, a = h.length; f < a; f++) {
            d.nodeFeatures[f] = SuperMap.REST.ServerFeature.fromJson(h[f]).toFeature()
        }
    }
    if (g.pathGuideItems) {
        d.pathGuideItems = [];
        for (var f = 0, e = g.pathGuideItems, a = e.length; f < a; f++) {
            d.pathGuideItems[f] = SuperMap.REST.PathGuideItem.fromJson(e[f])
        }
    }
    d.route = SuperMap.REST.Route.fromJson(g.route);
    return d
}
;
SuperMap.REST.FindClosestFacilitiesParameters = SuperMap.Class({
    event: null,
    expectFacilityCount: 1,
    facilities: null,
    fromEvent: false,
    isAnalyzeById: false,
    maxWeight: 0,
    parameter: null,
    initialize: function(a) {
        var c = this;
        c.parameter = new SuperMap.REST.TransportationAnalystParameter();
        if (!a) {
            return
        }
        SuperMap.Util.extend(this, a)
    },
    destroy: function() {
        var a = this;
        a.event = null;
        a.expectFacilityCount = null;
        a.facilities = null;
        a.fromEvent = null;
        a.isAnalyzeById = null;
        a.maxWeight = null;
        if (a.parameter) {
            a.parameter.destroy();
            a.parameter = null
        }
    },
    CLASS_NAME: "SuperMap.REST.FindClosestFacilitiesParameters"
});
SuperMap.REST.FindClosestFacilitiesEventArgs = SuperMap.Class(SuperMap.ServiceEventArgs, {
    result: null,
    initialize: function(a, d) {
        SuperMap.ServiceEventArgs.prototype.initialize.apply(this, [d]);
        var c = this;
        c.result = a
    },
    destroy: function() {
        SuperMap.ServiceEventArgs.prototype.destroy.apply(this);
        var a = this;
        if (a.result) {
            a.result.destroy();
            a.result = null
        }
    },
    CLASS_NAME: "SuperMap.REST.FindClosestFacilitiesEventArgs"
});
SuperMap.REST.FindClosestFacilityResult = SuperMap.Class({
    facilityPathList: null,
    initialize: function(a) {
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        var d = this;
        if (d.facilityPathList) {
            for (var c = 0, e = d.facilityPathList, a = e.length; c < a; c++) {
                e[c].destroy()
            }
            d.facilityPathList = null
        }
    },
    CLASS_NAME: "SuperMap.REST.FindClosestFacilityResult"
});
SuperMap.REST.FindClosestFacilityResult.fromJson = function(e) {
    if (!e) {
        return
    }
    var c = new SuperMap.REST.FindClosestFacilityResult();
    if (e.facilityPathList) {
        c.facilityPathList = [];
        for (var d = 0, f = e.facilityPathList, a = f.length; d < a; d++) {
            c.facilityPathList[d] = SuperMap.REST.ClosestFacilityPath.fromJson(f[d])
        }
    }
    return c
}
;
SuperMap.REST.FindClosestFacilitiesService = SuperMap.Class(SuperMap.ServiceBase, {
    EVENT_TYPES: ["processCompleted", "processFailed"],
    events: null,
    eventListeners: null,
    lastResult: null,
    initialize: function(c, a) {
        SuperMap.ServiceBase.prototype.initialize.apply(this, arguments);
        var d = this;
        if (a) {
            SuperMap.Util.extend(d, a)
        }
        d.events = new SuperMap.Events(d,null,d.EVENT_TYPES,true);
        if (d.eventListeners instanceof Object) {
            d.events.on(d.eventListeners)
        }
    },
    destroy: function() {
        SuperMap.ServiceBase.prototype.destroy.apply(this, arguments);
        var a = this;
        a.EVENT_TYPES = null;
        a.events = null;
        a.eventListeners = null;
        if (a.lastResult) {
            a.lastResult.destroy();
            a.lastResult = null
        }
    },
    processAsync: function(e) {
        if (!e) {
            return
        }
        var d = this, c, a = d.url.substr(d.url.length - 1, 1);
        d.url = d.url + ((a == "/") ? "closestfacility" : "/closestfacility") + (this.isInTheSameDomain ? ".json?" : ".jsonp?");
        c = {
            expectFacilityCount: e.expectFacilityCount,
            fromEvent: e.fromEvent,
            maxWeight: e.maxWeight,
            parameter: SuperMap.Util.toJSON(e.parameter),
            event: SuperMap.Util.toJSON(e.event),
            facilities: d.getJson(e.isAnalyzeById, e.facilities)
        };
        d.request({
            method: "GET",
            params: c,
            scope: d,
            success: d.findClosestFacilityComplete,
            failure: d.findClosestFacilityError
        })
    },
    getJson: function(e, f) {
        var d = "["
          , a = f ? f.length : 0;
        if (e === false) {
            for (var c = 0; c < a; c++) {
                if (c > 0) {
                    d += ","
                }
                d += '{"x":' + f[c].x + ',"y":' + f[c].y + "}"
            }
        } else {
            if (e == true) {
                for (var c = 0; c < a; c++) {
                    if (c > 0) {
                        d += ","
                    }
                    d += f[c]
                }
            }
        }
        d += "]";
        return d
    },
    findClosestFacilityComplete: function(a) {
        var d = this, e, c;
        a = SuperMap.Util.transformResult(a);
        e = SuperMap.REST.FindClosestFacilityResult.fromJson(a);
        d.lastResult = e;
        c = new SuperMap.REST.FindClosestFacilitiesEventArgs(e,a);
        d.events.triggerEvent("processCompleted", c)
    },
    findClosestFacilityError: function(c) {
        var e = this
          , d = null
          , a = null
          , f = null;
        c = SuperMap.Util.transformResult(c);
        d = c.error;
        if (!d) {
            return
        }
        a = SuperMap.ServiceException.fromJson(d);
        f = new SuperMap.ServiceFailedEventArgs(a,c);
        e.events.triggerEvent("processFailed", f)
    },
    CLASS_NAME: "SuperMap.REST.FindClosestFacilitiesService"
});
SuperMap.REST.FindMTSPPathsParameters = SuperMap.Class({
    centers: null,
    hasLeastTotalCost: false,
    isAnalyzeById: false,
    nodes: null,
    parameter: null,
    initialize: function(a) {
        var c = this;
        c.parameter = new SuperMap.REST.TransportationAnalystParameter();
        if (!a) {
            return
        }
        SuperMap.Util.extend(this, a)
    },
    destroy: function() {
        var a = this;
        a.centers = null;
        a.hasLeastTotalCost = null;
        a.isAnalyzeById = null;
        a.nodes = null;
        a.maxWeight = null;
        if (a.parameter) {
            a.parameter.destroy();
            a.parameter = null
        }
    },
    CLASS_NAME: "SuperMap.REST.FindMTSPPathsParameters"
});
SuperMap.REST.FindMTSPPathsResult = SuperMap.Class({
    pathList: null,
    initialize: function(a) {
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        var d = this;
        if (d.pathList) {
            for (var c = 0, e = d.pathList, a = e.length; c < a; c++) {
                e[c].destroy()
            }
            d.pathList = null
        }
    },
    CLASS_NAME: "SuperMap.REST.FindMTSPPathResult"
});
SuperMap.REST.FindMTSPPathsResult.fromJson = function(e) {
    if (!e) {
        return
    }
    var c = new SuperMap.REST.FindMTSPPathsResult();
    if (e.pathList) {
        c.pathList = [];
        for (var d = 0, f = e.pathList, a = e.pathList.length; d < a; d++) {
            c.pathList[d] = SuperMap.REST.MTSPPath.fromJson(f[d])
        }
    }
    return c
}
;
SuperMap.REST.FindMTSPPathsEventArgs = SuperMap.Class(SuperMap.ServiceEventArgs, {
    result: null,
    initialize: function(a, d) {
        SuperMap.ServiceEventArgs.prototype.initialize.apply(this, [d]);
        var c = this;
        c.result = a
    },
    destroy: function() {
        SuperMap.ServiceEventArgs.prototype.destroy.apply(this);
        var a = this;
        if (a.result) {
            a.result.destroy();
            a.result = null
        }
    },
    CLASS_NAME: "SuperMap.REST.FindMTSPPathsEventArgs"
});
SuperMap.REST.MTSPPath = SuperMap.Class({
    center: null,
    edgeFeatures: null,
    edgeIDs: null,
    nodeFeatures: null,
    nodeIDs: null,
    pathGuideItems: null,
    route: null,
    stopWeights: null,
    stopIndexes: null,
    weight: null,
    initialize: function(a) {
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        var g = this;
        if (g.edgeFeatures) {
            for (var e = 0, c = g.edgeFeatures, a = c.length; e < a; e++) {
                c[e].destroy()
            }
            g.edgeFeatures = null
        }
        if (g.edgeIDs) {
            g.edgeIDs.length = 0;
            g.edgeIDs = null
        }
        if (g.nodeFeatures) {
            for (var e = 0, f = g.nodeFeatures, a = f.length; e < a; e++) {
                f[e].destroy()
            }
            g.nodeFeatures = null
        }
        if (g.nodeIDs) {
            g.nodeIDs.length = 0;
            g.nodeIDs = null
        }
        if (g.pathGuideItems) {
            for (var e = 0, d = g.pathGuideItems, a = d.length; e < a; e++) {
                d[e].destroy()
            }
            g.pathGuideItems = null
        }
        g.route = null;
        if (g.stopWeights) {
            g.stopWeights.length = 0;
            g.stopWeights = null
        }
        if (g.stopIndexes) {
            g.stopIndexes.length = 0;
            g.stopIndexes = null
        }
        g.weight = null;
        g.center = null
    },
    CLASS_NAME: "SuperMap.REST.MTSPPath"
});
SuperMap.REST.MTSPPath.fromJson = function(g) {
    if (!g) {
        return
    }
    var d = new SuperMap.REST.MTSPPath({
        edgeIDs: g.edgeIDs,
        nodeIDs: g.nodeIDs,
        stopWeights: g.stopWeights,
        stopIndexes: g.stopIndexes,
        weight: g.weight
    });
    if (g.edgeFeatures) {
        d.edgeFeatures = [];
        for (var f = 0, c = g.edgeFeatures, a = c.length; f < a; f++) {
            d.edgeFeatures[f] = SuperMap.REST.ServerFeature.fromJson(c[f]).toFeature()
        }
    }
    if (g.nodeFeatures) {
        d.nodeFeatures = [];
        for (var f = 0, h = g.nodeFeatures, a = h.length; f < a; f++) {
            d.nodeFeatures[f] = SuperMap.REST.ServerFeature.fromJson(h[f]).toFeature()
        }
    }
    if (g.pathGuideItems) {
        d.pathGuideItems = [];
        for (var f = 0, e = g.pathGuideItems, a = e.length; f < a; f++) {
            d.pathGuideItems[f] = SuperMap.REST.PathGuideItem.fromJson(e[f])
        }
    }
    d.route = SuperMap.REST.Route.fromJson(g.route);
    d.ceter = g.center;
    return d
}
;
SuperMap.REST.FindMTSPPathsService = SuperMap.Class(SuperMap.ServiceBase, {
    EVENT_TYPES: ["processCompleted", "processFailed"],
    events: null,
    eventListeners: null,
    lastResult: null,
    initialize: function(c, a) {
        SuperMap.ServiceBase.prototype.initialize.apply(this, arguments);
        var d = this;
        if (a) {
            SuperMap.Util.extend(d, a)
        }
        d.events = new SuperMap.Events(d,null,d.EVENT_TYPES,true);
        if (d.eventListeners instanceof Object) {
            d.events.on(d.eventListeners)
        }
    },
    destroy: function() {
        SuperMap.ServiceBase.prototype.destroy.apply(this, arguments);
        var a = this;
        a.EVENT_TYPES = null;
        a.events = null;
        a.eventListeners = null;
        if (a.lastResult) {
            a.lastResult.destroy();
            a.lastResult = null
        }
    },
    processAsync: function(f) {
        if (!f) {
            return
        }
        var e = this, d, a = e.url.substr(e.url.length - 1, 1), c = e.getJson(f.isAnalyzeById, f.centers);
        nodes = e.getJson(f.isAnalyzeById, f.nodes);
        e.url = e.url + "/mtsppath" + (this.isInTheSameDomain ? ".json?" : ".jsonp?");
        d = {
            centers: c,
            nodes: nodes,
            parameter: SuperMap.Util.toJSON(f.parameter),
            hasLeastTotalCost: f.hasLeastTotalCost
        };
        e.request({
            method: "GET",
            params: d,
            scope: e,
            success: e.findMTSPPathsComplete,
            failure: e.findMTSPPathsError
        })
    },
    getJson: function(e, f) {
        var d = "["
          , a = f ? f.length : 0;
        if (e === false) {
            for (var c = 0; c < a; c++) {
                if (c > 0) {
                    d += ","
                }
                d += '{"x":' + f[c].x + ',"y":' + f[c].y + "}"
            }
        } else {
            if (e == true) {
                for (var c = 0; c < a; c++) {
                    if (c > 0) {
                        d += ","
                    }
                    d += f[c]
                }
            }
        }
        d += "]";
        return d
    },
    findMTSPPathsComplete: function(a) {
        var e = this, d, c;
        a = SuperMap.Util.transformResult(a);
        d = SuperMap.REST.FindMTSPPathsResult.fromJson(a);
        e.lastResult = d;
        c = new SuperMap.REST.FindMTSPPathsEventArgs(d,a);
        e.events.triggerEvent("processCompleted", c)
    },
    findMTSPPathsError: function(c) {
        var e = this
          , d = null
          , a = null
          , f = null;
        c = SuperMap.Util.transformResult(c);
        d = c.error;
        if (!d) {
            return
        }
        a = SuperMap.ServiceException.fromJson(d);
        f = new SuperMap.ServiceFailedEventArgs(a,c);
        e.events.triggerEvent("processFailed", f)
    },
    CLASS_NAME: "SuperMap.REST.FindMTSPPathsService"
});
SuperMap.REST.FindTSPPathsParameters = SuperMap.Class({
    endNodeAssigned: false,
    isAnalyzeById: false,
    nodes: null,
    parameter: null,
    initialize: function(a) {
        var c = this;
        c.parameter = new SuperMap.REST.TransportationAnalystParameter();
        if (!a) {
            return
        }
        SuperMap.Util.extend(this, a)
    },
    destroy: function() {
        var a = this;
        a.endNodeAssigned = null;
        a.isAnalyzeById = null;
        a.nodes = null;
        if (a.parameter) {
            a.parameter.destroy();
            a.parameter = null
        }
    },
    CLASS_NAME: "SuperMap.REST.FindTSPPathsParameters"
});
SuperMap.REST.FindTSPPathsResult = SuperMap.Class({
    tspPathList: null,
    initialize: function(a) {
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        var e = this;
        if (e.tspPathList) {
            for (var c = 0, d = e.tspPathList, a = d.length; c < a; c++) {
                d[c].destroy()
            }
            e.tspPathList = null
        }
    },
    CLASS_NAME: "SuperMap.REST.FindTSPPathResult"
});
SuperMap.REST.FindTSPPathsResult.fromJson = function(e) {
    if (!e) {
        return
    }
    var c = new SuperMap.REST.FindTSPPathsResult();
    if (e.tspPathList) {
        c.tspPathList = [];
        for (var d = 0, f = e.tspPathList, a = e.tspPathList.length; d < a; d++) {
            c.tspPathList[d] = SuperMap.REST.TSPPath.fromJson(f[d])
        }
    }
    return c
}
;
SuperMap.REST.FindTSPPathsEventArgs = SuperMap.Class(SuperMap.ServiceEventArgs, {
    result: null,
    initialize: function(a, d) {
        SuperMap.ServiceEventArgs.prototype.initialize.apply(this, [d]);
        var c = this;
        c.result = a
    },
    destroy: function() {
        SuperMap.ServiceEventArgs.prototype.destroy.apply(this);
        var a = this;
        if (a.result) {
            a.result.destroy();
            a.result = null
        }
    },
    CLASS_NAME: "SuperMap.REST.FindTSPPathsEventArgs"
});
SuperMap.REST.TSPPath = SuperMap.Class({
    edgeFeatures: null,
    edgeIDs: null,
    nodeFeatures: null,
    nodeIDs: null,
    pathGuideItems: null,
    route: null,
    stopWeights: null,
    stopIndexes: null,
    weight: null,
    initialize: function(a) {
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        var g = this;
        if (g.edgeFeatures) {
            for (var e = 0, c = g.edgeFeatures, a = c.length; e < a; e++) {
                c[e].destroy()
            }
            g.edgeFeatures = null
        }
        if (g.edgeIDs) {
            g.edgeIDs.length = 0;
            g.edgeIDs = null
        }
        if (g.nodeFeatures) {
            for (var e = 0, f = g.nodeFeatures, a = f.length; e < a; e++) {
                f[e].destroy()
            }
            g.nodeFeatures = null
        }
        if (g.nodeIDs) {
            g.nodeIDs.length = 0;
            g.nodeIDs = null
        }
        if (g.pathGuideItems) {
            for (var e = 0, d = g.pathGuideItems, a = d.length; e < a; e++) {
                d[e].destroy()
            }
            g.pathGuideItems = null
        }
        g.route = null;
        if (g.stopWeights) {
            g.stopWeights.length = 0;
            g.stopWeights = null
        }
        if (g.stopIndexes) {
            g.stopIndexes.length = 0;
            g.stopIndexes = null
        }
        g.weight = null
    },
    CLASS_NAME: "SuperMap.REST.TSPPath"
});
SuperMap.REST.TSPPath.fromJson = function(g) {
    if (!g) {
        return
    }
    var d = new SuperMap.REST.TSPPath({
        edgeIDs: g.edgeIDs,
        nodeIDs: g.nodeIDs,
        stopWeights: g.stopWeights,
        stopIndexes: g.stopIndexes,
        weight: g.weight
    });
    if (g.edgeFeatures) {
        d.edgeFeatures = [];
        for (var f = 0, c = g.edgeFeatures, a = c.length; f < a; f++) {
            d.edgeFeatures[f] = SuperMap.REST.ServerFeature.fromJson(c[f]).toFeature()
        }
    }
    if (g.nodeFeatures) {
        d.nodeFeatures = [];
        for (var f = 0, h = g.nodeFeatures, a = h.length; f < a; f++) {
            d.nodeFeatures[f] = SuperMap.REST.ServerFeature.fromJson(h[f]).toFeature()
        }
    }
    if (g.pathGuideItems) {
        d.pathGuideItems = [];
        for (var f = 0, e = g.pathGuideItems, a = e.length; f < a; f++) {
            d.pathGuideItems[f] = SuperMap.REST.PathGuideItem.fromJson(e[f])
        }
    }
    d.route = SuperMap.REST.Route.fromJson(g.route);
    return d
}
;
SuperMap.REST.FindTSPPathsService = SuperMap.Class(SuperMap.ServiceBase, {
    EVENT_TYPES: ["processCompleted", "processFailed"],
    events: null,
    eventListeners: null,
    lastResult: null,
    initialize: function(c, a) {
        SuperMap.ServiceBase.prototype.initialize.apply(this, arguments);
        var d = this;
        if (a) {
            SuperMap.Util.extend(d, a)
        }
        d.events = new SuperMap.Events(d,null,d.EVENT_TYPES,true);
        if (d.eventListeners instanceof Object) {
            d.events.on(d.eventListeners)
        }
    },
    destroy: function() {
        SuperMap.ServiceBase.prototype.destroy.apply(this, arguments);
        var a = this;
        a.EVENT_TYPES = null;
        a.events = null;
        a.eventListeners = null;
        if (a.lastResult) {
            a.lastResult.destroy();
            a.lastResult = null
        }
    },
    processAsync: function(e) {
        if (!e) {
            return
        }
        var d = this, c, a = d.url.substr(d.url.length - 1, 1);
        d.url = d.url + ((a == "/") ? "tsppath" : "/tsppath") + (this.isInTheSameDomain ? ".json?" : ".jsonp?");
        c = {
            parameter: SuperMap.Util.toJSON(e.parameter),
            endNodeAssigned: e.endNodeAssigned,
            nodes: d.getNodesJson(e)
        };
        d.request({
            method: "GET",
            params: c,
            scope: d,
            success: d.findTSPPathsComplete,
            failure: d.findTSPPathsError
        })
    },
    getNodesJson: function(h) {
        var g = "", f;
        if (h.isAnalyzeById === false) {
            for (f = "[",
            d = 0,
            c = h.nodes,
            a = c.length; d < a; d++) {
                if (d > 0) {
                    f += ","
                }
                f += '{"x":' + c[d].x + ',"y":' + c[d].y + "}"
            }
            f += "]";
            g += f
        } else {
            if (h.isAnalyzeById == true) {
                for (var e = "[", d = 0, c = h.nodes, a = c.length; d < a; d++) {
                    if (d > 0) {
                        e += ","
                    }
                    e += c[d]
                }
                e += "]";
                g += e
            }
        }
        return g
    },
    findTSPPathsComplete: function(a) {
        var e = this, c, d;
        a = SuperMap.Util.transformResult(a);
        c = SuperMap.REST.FindTSPPathsResult.fromJson(a);
        e.lastResult = c;
        d = new SuperMap.REST.FindTSPPathsEventArgs(c,a);
        e.events.triggerEvent("processCompleted", d)
    },
    findTSPPathsError: function(c) {
        var e = this
          , d = null
          , a = null
          , f = null;
        c = SuperMap.Util.transformResult(c);
        d = c.error;
        if (!d) {
            return
        }
        a = SuperMap.ServiceException.fromJson(d);
        f = new SuperMap.ServiceFailedEventArgs(a,c);
        e.events.triggerEvent("processFailed", f)
    },
    CLASS_NAME: "SuperMap.REST.FindTSPPathsService"
});
SuperMap.REST.SupplyCenter = SuperMap.Class({
    maxWeight: null,
    nodeID: null,
    resourceValue: null,
    type: null,
    initialize: function(a) {
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        var a = this;
        a.maxWeight = null;
        a.nodeID = null;
        a.resourceValue = null;
        a.type = null
    },
    CLASS_NAME: "SuperMap.REST.SupplyCenter"
});
SuperMap.REST.SupplyCenter.fromJson = function(c) {
    if (!c) {
        return
    }
    var a = new SuperMap.REST.SupplyCenter({
        maxWeight: c.maxWeight,
        nodeID: c.nodeID,
        resourceValue: c.resourceValue,
        type: c.type
    });
    return a
}
;
SuperMap.REST.DemandResult = SuperMap.Class(SuperMap.REST.ServerFeature, {
    actualResourceValue: null,
    demandID: null,
    isEdge: null,
    supplyCenter: null,
    initialize: function(a) {
        SuperMap.REST.ServerFeature.prototype.initialize.apply(this, arguments);
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        var a = this;
        SuperMap.REST.ServerFeature.prototype.destroy.apply(a, arguments);
        a.actualResourceValue = null;
        a.demandID = null;
        a.isEdge = null;
        a.nodeID = null;
        a.SupplyCenter && a.SupplyCenter.destory()
    },
    CLASS_NAME: "SuperMap.REST.DemandResult"
});
SuperMap.REST.DemandResult.fromJson = function(d) {
    if (!d) {
        return
    }
    var a = new SuperMap.REST.DemandResult();
    a.actualResourceValue = d.actualResourceValue;
    a.demandID = d.demandID;
    a.isEdge = d.isEdge;
    if (d.supplyCenter) {
        a.supplyCenter = SuperMap.REST.SupplyCenter.fromJson(d.supplyCenter)
    }
    var f;
    if (d.fieldNames) {
        f = [];
        for (var c = 0; c < d.fieldNames.length; c++) {
            f.push(d.fieldNames[c])
        }
    }
    a.fieldNames = f;
    var e;
    if (d.fieldValues) {
        e = [];
        for (var c = 0; c < d.fieldValues.length; c++) {
            e.push(d.fieldValues[c])
        }
    }
    a.fieldValues = e;
    if (d.geometry) {
        a.geometry = SuperMap.REST.ServerGeometry.fromJson(d.geometry).toGeometry()
    } else {
        a.geometry = null
    }
    return a
}
;
SuperMap.REST.SupplyResult = SuperMap.Class(SuperMap.REST.ServerFeature, {
    actualResourceValue: null,
    averageWeight: null,
    demandCount: null,
    maxWeight: null,
    nodeID: null,
    resourceValue: null,
    totalWeights: null,
    type: null,
    initialize: function(a) {
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        var a = this;
        SuperMap.REST.ServerFeature.prototype.destroy.call(this, arguments);
        a.actualResourceValue = null;
        a.averageWeight = null;
        a.demandCount = null;
        a.maxWeight = null;
        a.nodeID = null;
        a.resourceValue = null;
        a.totalWeights = null;
        a.type = null
    },
    CLASS_NAME: "SuperMap.REST.SupplyResult"
});
SuperMap.REST.SupplyResult.fromJson = function(e) {
    if (!e) {
        return
    }
    var c = new SuperMap.REST.SupplyResult({
        actualResourceValue: e.actualResourceValue,
        averageWeight: e.averageWeight,
        demandCount: e.demandCount,
        maxWeight: e.maxWeight,
        nodeID: e.nodeID,
        resourceValue: e.resourceValue,
        totalWeights: e.totalWeights,
        type: e.type
    });
    if (e.fieldNames) {
        c.fieldNames = [];
        for (var d = 0, g = e.fieldNames, a = g.length; d < a; d++) {
            c.fieldNames.push(g[d])
        }
    }
    if (e.fieldValues) {
        c.fieldValues = [];
        for (var d = 0, f = e.fieldValues, a = f.length; d < a; d++) {
            c.fieldValues.push(f[d])
        }
    }
    e.geometry ? (c.geometry = SuperMap.REST.ServerGeometry.fromJson(e.geometry).toGeometry()) : (c.geometry = null);
    return c
}
;
SuperMap.REST.FindLocationResult = SuperMap.Class({
    demandResults: null,
    supplyResults: null,
    initialize: function(a) {
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        var d = this;
        if (d.demandResults) {
            for (var c = 0, a = d.demandResults.length; c < a; c++) {
                d.demandResults[c].destroy()
            }
            d.demandResults = null
        }
        if (d.supplyResults) {
            for (var c = 0, a = d.supplyResults.length; c < a; c++) {
                d.supplyResults[c].destroy()
            }
            d.supplyResults = null
        }
    },
    CLASS_NAME: "SuperMap.REST.FindLocationResult"
});
SuperMap.REST.FindLocationResult.fromJson = function(f) {
    if (!f) {
        return
    }
    var c = new SuperMap.REST.FindLocationResult();
    if (f.demandResults) {
        c.demandResults = [];
        for (var e = 0, d = f.demandResults, a = d.length; e < a; e++) {
            c.demandResults[e] = SuperMap.REST.DemandResult.fromJson(d[e])
        }
    }
    if (f.supplyResults) {
        c.supplyResults = [];
        for (var e = 0, g = f.supplyResults, a = g.length; e < a; e++) {
            c.supplyResults[e] = SuperMap.REST.SupplyResult.fromJson(g[e])
        }
    }
    return c
}
;
SuperMap.REST.FindLocationEventArgs = SuperMap.Class(SuperMap.ServiceEventArgs, {
    result: null,
    initialize: function(a, d) {
        SuperMap.ServiceEventArgs.prototype.initialize.apply(this, [d]);
        var c = this;
        c.result = a
    },
    destroy: function() {
        SuperMap.ServiceEventArgs.prototype.destroy.apply(this);
        var a = this;
        if (a.result) {
            a.result.destroy();
            a.result = null
        }
    },
    CLASS_NAME: "SuperMap.REST.FindLocationEventArgs"
});
SuperMap.REST.FindLocationParameters = SuperMap.Class({
    expectedSupplyCenterCount: null,
    isFromCenter: false,
    nodeDemandField: null,
    supplyCenters: null,
    turnWeightField: null,
    weightName: null,
    initialize: function(a) {
        if (!a) {
            return
        }
        SuperMap.Util.extend(this, a)
    },
    destroy: function() {
        var e = this;
        e.expectedSupplyCenterCount = null;
        e.isFromCenter = null;
        e.nodeDemandField = null;
        e.turnWeightField = null;
        e.weightName = null;
        if (e.supplyCenters) {
            for (var c = 0, d = e.supplyCenters, a = d.length; c < a; c++) {
                d[c].destroy()
            }
            e.supplyCenters = null
        }
    },
    CLASS_NAME: "SuperMap.REST.FindLocationParameters"
});
SuperMap.REST.FindLocationService = SuperMap.Class(SuperMap.ServiceBase, {
    EVENT_TYPES: ["processCompleted", "processFailed"],
    events: null,
    eventListeners: null,
    lastResult: null,
    initialize: function(c, a) {
        SuperMap.ServiceBase.prototype.initialize.apply(this, arguments);
        var d = this;
        if (a) {
            SuperMap.Util.extend(d, a)
        }
        d.events = new SuperMap.Events(d,null,d.EVENT_TYPES,true);
        if (d.eventListeners instanceof Object) {
            d.events.on(d.eventListeners)
        }
    },
    destroy: function() {
        SuperMap.ServiceBase.prototype.destroy.apply(this, arguments);
        var a = this;
        a.EVENT_TYPES = null;
        a.events = null;
        a.eventListeners = null;
        if (a.lastResult) {
            a.lastResult.destroy();
            a.lastResult = null
        }
    },
    processAsync: function(e) {
        if (!e) {
            return
        }
        var d = this, c, a = d.url.substr(d.url.length - 1, 1);
        d.url = d.url + ((a == "/") ? "location" : "/location") + (this.isInTheSameDomain ? ".json?" : ".jsonp?");
        c = {
            isFromCenter: e.isFromCenter,
            expectedSupplyCenterCount: e.expectedSupplyCenterCount,
            nodeDemandField: e.nodeDemandField,
            weightName: e.weightName,
            turnWeightField: e.turnWeightField,
            returnEdgeFeature: true,
            returnEdgeGeometry: true,
            returnNodeFeature: true,
            mapParameter: SuperMap.Util.toJSON(e.mapParameter),
            supplyCenters: d.getCentersJson(e.supplyCenters)
        };
        d.request({
            method: "GET",
            params: c,
            scope: d,
            success: d.findLocationComplete,
            failure: d.findLocationError
        })
    },
    getCentersJson: function(e) {
        var d = "["
          , a = e ? e.length : 0;
        for (var c = 0; c < a; c++) {
            if (c > 0) {
                d += ","
            }
            d += SuperMap.Util.toJSON(e[c])
        }
        d += "]";
        return d
    },
    findLocationComplete: function(a) {
        var e = this, d, c;
        a = SuperMap.Util.transformResult(a);
        d = SuperMap.REST.FindLocationResult.fromJson(a);
        e.lastResult = d;
        c = new SuperMap.REST.FindLocationEventArgs(d,a);
        e.events.triggerEvent("processCompleted", c)
    },
    findLocationError: function(c) {
        var e = this
          , d = null
          , a = null
          , f = null;
        c = SuperMap.Util.transformResult(c);
        d = c.error;
        if (!d) {
            return
        }
        a = SuperMap.ServiceException.fromJson(d);
        f = new SuperMap.ServiceFailedEventArgs(a,c);
        e.events.triggerEvent("processFailed", f)
    },
    CLASS_NAME: "SuperMap.REST.FindLocationService"
});
SuperMap.REST.GetEdgeWeightNamesResult = SuperMap.Class({
    edgeWeightNames: null,
    initialize: function(a) {
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        var a = this;
        if (a.edgeWeightNames) {
            a.edgeWeightNames = null
        }
    },
    CLASS_NAME: "SuperMap.REST.GetEdgeWeightNamesResult"
});
SuperMap.REST.GetEdgeWeightNamesResult.fromJson = function(e) {
    if (!e) {
        return
    }
    var c = [];
    if (e.length > 0) {
        for (var d = 0; d < e.length; d++) {
            c.push(e[d])
        }
    }
    var a = new SuperMap.REST.GetEdgeWeightNamesResult({
        edgeWeightNames: c
    });
    return a
}
;
SuperMap.REST.GetEdgeWeightNamesEventArgs = SuperMap.Class(SuperMap.ServiceEventArgs, {
    result: null,
    initialize: function(a, d) {
        SuperMap.ServiceEventArgs.prototype.initialize.apply(this, [d]);
        var c = this;
        c.result = a
    },
    destroy: function() {
        SuperMap.ServiceEventArgs.prototype.destroy.apply(this);
        var a = this;
        if (a.result) {
            a.result.destroy();
            a.result = null
        }
    },
    CLASS_NAME: "SuperMap.REST.GetEdgeWeightNamesEventArgs"
});
SuperMap.REST.GetEdgeWeightNamesService = SuperMap.Class(SuperMap.ServiceBase, {
    EVENT_TYPES: ["processCompleted", "processFailed"],
    events: null,
    eventListeners: null,
    lastResult: null,
    initialize: function(c, a) {
        SuperMap.ServiceBase.prototype.initialize.apply(this, arguments);
        var d = this;
        if (a) {
            SuperMap.Util.extend(d, a)
        }
        d.events = new SuperMap.Events(d,null,d.EVENT_TYPES,true);
        if (d.eventListeners instanceof Object) {
            d.events.on(d.eventListeners)
        }
    },
    destroy: function() {
        SuperMap.ServiceBase.prototype.destroy.apply(this, arguments);
        var a = this;
        a.EVENT_TYPES = null;
        a.events = null;
        a.eventListeners = null;
        if (a.lastResult) {
            a.lastResult.destroy();
            a.lastResult = null
        }
    },
    processAsync: function() {
        var d = this, c, a = d.url.substr(d.url.length - 1, 1);
        d.url = d.url + ((a == "/") ? "edgeweightnames" : "/edgeweightnames") + (this.isInTheSameDomain ? ".json?" : ".jsonp?");
        d.request({
            method: "GET",
            scope: d,
            success: d.getEdgeWeightNamesComplete,
            failure: d.getEdgeWeightNamesError
        })
    },
    getEdgeWeightNamesComplete: function(a) {
        var e = this, c, d;
        a = SuperMap.Util.transformResult(a);
        c = SuperMap.REST.GetEdgeWeightNamesResult.fromJson(a);
        e.lastResult = c;
        d = new SuperMap.REST.GetEdgeWeightNamesEventArgs(c,a);
        e.events.triggerEvent("processCompleted", d)
    },
    getEdgeWeightNamesError: function(c) {
        var e = this
          , d = null
          , a = null
          , f = null;
        c = SuperMap.Util.transformResult(c);
        d = c.error;
        if (!d) {
            return
        }
        a = SuperMap.ServiceException.fromJson(d);
        f = new SuperMap.ServiceFailedEventArgs(a,c);
        e.events.triggerEvent("processFailed", f)
    },
    CLASS_NAME: "SuperMap.REST.GetEdgeWeightNamesService"
});
SuperMap.REST.GetTurnNodeWeightNamesResult = SuperMap.Class({
    turnNodeWeightNames: null,
    initialize: function(a) {
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        var a = this;
        if (a.turnNodeWeightNames) {
            a.turnNodeWeightNames = null
        }
    },
    CLASS_NAME: "SuperMap.REST.GetTurnNodeWeightNamesResult"
});
SuperMap.REST.GetTurnNodeWeightNamesResult.fromJson = function(e) {
    if (!e) {
        return
    }
    var c = [];
    if (e.length > 0) {
        for (var d = 0; d < e.length; d++) {
            c.push(e[d])
        }
    }
    var a = new SuperMap.REST.GetTurnNodeWeightNamesResult({
        turnNodeWeightNames: c
    });
    return a
}
;
SuperMap.REST.GetTurnNodeWeightNamesEventArgs = SuperMap.Class(SuperMap.ServiceEventArgs, {
    result: null,
    initialize: function(a, d) {
        SuperMap.ServiceEventArgs.prototype.initialize.apply(this, [d]);
        var c = this;
        c.result = a
    },
    destroy: function() {
        SuperMap.ServiceEventArgs.prototype.destroy.apply(this);
        var a = this;
        if (a.result) {
            a.result.destroy();
            a.result = null
        }
    },
    CLASS_NAME: "SuperMap.REST.GetTurnNodeWeightNamesEventArgs"
});
SuperMap.REST.GetTurnNodeWeightNamesService = SuperMap.Class(SuperMap.ServiceBase, {
    EVENT_TYPES: ["processCompleted", "processFailed"],
    events: null,
    eventListeners: null,
    lastResult: null,
    initialize: function(c, a) {
        SuperMap.ServiceBase.prototype.initialize.apply(this, arguments);
        var d = this;
        if (a) {
            SuperMap.Util.extend(d, a)
        }
        d.events = new SuperMap.Events(d,null,d.EVENT_TYPES,true);
        if (d.eventListeners instanceof Object) {
            d.events.on(d.eventListeners)
        }
    },
    destroy: function() {
        SuperMap.ServiceBase.prototype.destroy.apply(this, arguments);
        var a = this;
        a.EVENT_TYPES = null;
        a.events = null;
        a.eventListeners = null;
        if (a.lastResult) {
            a.lastResult.destroy();
            a.lastResult = null
        }
    },
    processAsync: function() {
        var d = this, c, a = d.url.substr(d.url.length - 1, 1);
        d.url = d.url + ((a == "/") ? "turnnodeweightfieldnames" : "/turnnodeweightfieldnames") + (this.isInTheSameDomain ? ".json?" : ".jsonp?");
        d.request({
            method: "GET",
            scope: d,
            success: d.getTurnNodeWeightNamesComplete,
            failure: d.getTurnNodeWeightNamesError
        })
    },
    getTurnNodeWeightNamesComplete: function(c) {
        var e = this, a, d;
        c = SuperMap.Util.transformResult(c);
        a = SuperMap.REST.GetTurnNodeWeightNamesResult.fromJson(c);
        e.lastResult = a;
        d = new SuperMap.REST.GetTurnNodeWeightNamesEventArgs(a,c);
        e.events.triggerEvent("processCompleted", d)
    },
    getTurnNodeWeightNamesError: function(c) {
        var e = this
          , d = null
          , a = null
          , f = null;
        c = SuperMap.Util.transformResult(c);
        d = c.error;
        if (!d) {
            return
        }
        a = SuperMap.ServiceException.fromJson(d);
        f = new SuperMap.ServiceFailedEventArgs(a,c);
        e.events.triggerEvent("processFailed", f)
    },
    CLASS_NAME: "SuperMap.REST.GetTurnNodeWeightNamesService"
});
SuperMap.REST.DataReturnOption = SuperMap.Class({
    expectCount: 1000,
    dataset: null,
    dataReturnMode: SuperMap.REST.DataReturnMode.RECORDSET_ONLY,
    deleteExistResultDataset: true,
    initialize: function(a) {
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        var a = this;
        a.expectCount = null;
        a.dataset = null;
        a.dataReturnMode = null;
        a.deleteExistResultDataset = null
    },
    CLASS_NAME: "SuperMap.REST.DataReturnOption"
});
SuperMap.REST.SurfaceAnalystParametersSetting = SuperMap.Class({
    clipRegion: null,
    datumValue: 0,
    expectedZValues: null,
    interval: 0,
    resampleTolerance: 0,
    smoothMethod: SuperMap.REST.SmoothMethod.BSPLINE,
    smoothness: 0,
    initialize: function(c) {
        if (c) {
            var a = c.clipRegion;
            if (a) {
                if (a instanceof SuperMap.Geometry && a.components) {
                    c.clipRegion = SuperMap.REST.ServerGeometry.fromGeometry(a)
                } else {
                    delete c.clipRegion
                }
            }
            SuperMap.Util.extend(this, c)
        }
    },
    destroy: function() {
        var a = this;
        if (a.clipRegion) {
            a.clipRegion.destroy();
            a.clipRegion = null
        }
        a.datumValue = null;
        a.expectedZValues = null;
        a.interval = null;
        a.resampleTolerance = null;
        a.smoothMethod = null;
        a.smoothness = null
    },
    CLASS_NAME: "SuperMap.REST.SurfaceAnalystParametersSetting"
});
SuperMap.REST.SurfaceAnalystParameters = SuperMap.Class({
    resolution: 0,
    extractParameter: null,
    resultSetting: null,
    surfaceAnalystMethod: SuperMap.REST.SurfaceAnalystMethod.ISOLINE,
    initialize: function(a) {
        var c = this;
        c.extractParameter = new SuperMap.REST.SurfaceAnalystParametersSetting();
        c.resultSetting = new SuperMap.REST.DataReturnOption();
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        var a = this;
        a.resolution = null;
        if (a.extractParameter) {
            a.extractParameter.destroy();
            a.extractParameter = null
        }
        if (a.resultSetting) {
            a.resultSetting.destroy();
            a.resultSetting = null
        }
        a.surfaceAnalystMethod = null
    },
    CLASS_NAME: "SuperMap.REST.SurfaceAnalystParameters"
});
SuperMap.REST.DatasetSurfaceAnalystParameters = SuperMap.Class(SuperMap.REST.SurfaceAnalystParameters, {
    dataset: null,
    filterQueryParameter: null,
    zValueFieldName: null,
    initialize: function(a) {
        var c = this;
        c.filterQueryParameter = new SuperMap.REST.FilterParameter();
        SuperMap.REST.SurfaceAnalystParameters.prototype.initialize.apply(this, arguments);
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        SuperMap.REST.SurfaceAnalystParameters.prototype.destroy.apply(this, arguments);
        var a = this;
        a.dataset = null;
        if (a.filterQueryParameter) {
            a.filterQueryParameter.destroy();
            a.filterQueryParameter = null
        }
        a.zValueFieldName = null
    },
    CLASS_NAME: "SuperMap.REST.DatasetSurfaceAnalystParameters"
});
SuperMap.REST.DatasetSurfaceAnalystParameters.toObject = function(d, a) {
    for (var c in d) {
        if (c == "filterQueryParameter") {
            a.filterQueryParameter = d.filterQueryParameter
        }
        if (c == "extractParameter") {
            a.extractParameter = d.extractParameter
        } else {
            if (c == "dataset") {} else {
                if (c == "surfaceAnalystMethod") {} else {
                    a[c] = d[c]
                }
            }
        }
    }
}
;
SuperMap.REST.GeometrySurfaceAnalystParameters = SuperMap.Class(SuperMap.REST.SurfaceAnalystParameters, {
    points: null,
    zValues: null,
    initialize: function(a) {
        SuperMap.REST.SurfaceAnalystParameters.prototype.initialize.apply(this, arguments);
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        SuperMap.REST.SurfaceAnalystParameters.prototype.destroy.apply(this, arguments);
        var e = this;
        if (e.points) {
            for (var c = 0, d = e.points, a = d.length; c < a; c++) {
                d[c].destroy()
            }
            e.points = null
        }
        e.zValues = null
    },
    CLASS_NAME: "SuperMap.REST.GeometrySurfaceAnalystParameters"
});
SuperMap.REST.SurfaceAnalystResult = SuperMap.Class(SuperMap.REST.SpatialAnalystResult, {
    recordset: null,
    dataset: null,
    initialize: function(a) {
        SuperMap.REST.SpatialAnalystResult.prototype.initialize.apply(this, arguments);
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        var a = this;
        if (a.recordset) {
            a.recordset.destroy();
            a.recordset = null
        }
        a.dataset = null
    },
    CLASS_NAME: "SuperMap.REST.SurfaceAnalystResult"
});
SuperMap.REST.SurfaceAnalystResult.fromJson = function(c) {
    if (!c) {
        return
    }
    var a = new SuperMap.REST.SurfaceAnalystResult();
    if (c.succeed) {
        a.succeed = c.succeed
    }
    if (c.recordset) {
        a.recordset = SuperMap.REST.Recordset.fromJson(c.recordset)
    }
    if (c.dataset) {
        a.dataset = c.dataset
    }
    return a
}
;
SuperMap.REST.SurfaceAnalystEventArgs = SuperMap.Class(SuperMap.ServiceEventArgs, {
    result: null,
    initialize: function(a, d) {
        SuperMap.ServiceEventArgs.prototype.initialize.apply(this, [d]);
        var c = this;
        c.result = a
    },
    destroy: function() {
        SuperMap.ServiceEventArgs.prototype.destroy.apply(this, arguments);
        var a = this;
        if (a.result) {
            a.result.destroy();
            a.result = null
        }
    },
    CLASS_NAME: "SuperMap.REST.SurfaceAnalystEventArgs"
});
SuperMap.REST.SurfaceAnalystService = SuperMap.Class(SuperMap.ServiceBase, {
    EVENT_TYPES: ["processCompleted", "processFailed"],
    events: null,
    eventListeners: null,
    lastResult: null,
    initialize: function(c, a) {
        SuperMap.ServiceBase.prototype.initialize.apply(this, [c]);
        var d = this;
        if (a) {
            SuperMap.Util.extend(d, a)
        }
        d.events = new SuperMap.Events(d,null,d.EVENT_TYPES,true);
        if (d.eventListeners instanceof Object) {
            d.events.on(d.eventListeners)
        }
    },
    destroy: function() {
        SuperMap.ServiceBase.prototype.destroy.apply(this, arguments);
        var a = this;
        a.EVENT_TYPES = null;
        if (a.events) {
            a.events.destroy();
            a.events = null
        }
        if (a.eventListeners) {
            a.eventListeners = null
        }
        if (a.lastResult) {
            a.lastResult.destroy();
            a.lastResult = null
        }
    },
    processAsync: function(d) {
        if (!d) {
            return
        }
        var a = this, c;
        c = a.getJsonParameters(d);
        a.request({
            method: "POST",
            data: c,
            scope: a,
            success: a.surfaceAnalystComplete,
            failure: a.surfaceAnalystError
        })
    },
    surfaceAnalystComplete: function(a) {
        var e = this
          , d = null
          , c = null;
        a = SuperMap.Util.transformResult(a);
        c = new SuperMap.REST.SurfaceAnalystResult.fromJson(a);
        e.lastResult = c;
        d = new SuperMap.REST.SurfaceAnalystEventArgs(c,a);
        e.events.triggerEvent("processCompleted", d)
    },
    surfaceAnalystError: function(c) {
        var f = this
          , e = null
          , a = null
          , d = null;
        c = SuperMap.Util.transformResult(c);
        e = c.error;
        if (!e) {
            return
        }
        a = SuperMap.ServiceException.fromJson(e);
        d = new SuperMap.ServiceFailedEventArgs(a,c);
        f.events.triggerEvent("processFailed", d)
    },
    getJsonParameters: function(d) {
        var c = "";
        var a = this;
        if (d instanceof SuperMap.REST.DatasetSurfaceAnalystParameters) {
            end = a.url.substr(a.url.length - 1, 1);
            if (a.isInTheSameDomain) {
                a.url += (end == "/") ? "datasets/" + d.dataset + "/" + d.surfaceAnalystMethod.toLowerCase() + ".json?returnContent=true" : "/datasets/" + d.dataset + "/" + d.surfaceAnalystMethod.toLowerCase() + ".json?returnContent=true"
            } else {
                a.url += (end == "/") ? "datasets/" + d.dataset + "/" + d.surfaceAnalystMethod.toLowerCase() + ".jsonp?returnContent=true" : "/datasets/" + d.dataset + "/" + d.surfaceAnalystMethod.toLowerCase() + ".jsonp?returnContent=true"
            }
        } else {
            if (d instanceof SuperMap.REST.GeometrySurfaceAnalystParameters) {
                end = a.url.substr(a.url.length - 1, 1);
                if (a.isInTheSameDomain) {
                    a.url += (end == "/") ? "geometry/" + d.surfaceAnalystMethod.toLowerCase() + ".json?returnContent=true" : "/geometry/" + d.surfaceAnalystMethod.toLowerCase() + ".json?returnContent=true"
                } else {
                    a.url += (end == "/") ? "geometry/" + d.surfaceAnalystMethod.toLowerCase() + ".jsonp?returnContent=true" : "/geometry/" + d.surfaceAnalystMethod.toLowerCase() + ".jsonp?returnContent=true"
                }
            } else {
                return
            }
        }
        c = SuperMap.Util.toJSON(d);
        return c
    },
    CLASS_NAME: "SuperMap.REST.SurfaceAnalystService"
});
SuperMap.REST.RouteCalculateMeasureParameters = SuperMap.Class({
    sourceRoute: null,
    point: null,
    tolerance: null,
    isIgnoreGap: false,
    initialize: function(a) {
        if (a) {
            var d = a.sourceRoute;
            var c = {};
            if (d) {
                if (d instanceof SuperMap.Geometry && d.components) {
                    c.type = d.type;
                    c.parts = d.parts;
                    c.points = d.components;
                    a.sourceRoute = c
                }
            }
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        var a = this;
        a.sourceRoute = null;
        a.point = null;
        if (a.tolerance) {
            a.tolerance = null
        }
        if (a.isIgnoreGap) {
            a.isIgnoreGap = false
        }
    },
    CLASS_NAME: "SuperMap.REST.RouteCalculateMeasureParameters"
});
SuperMap.REST.RouteCalculateMeasureResult = SuperMap.Class(SuperMap.REST.SpatialAnalystResult, {
    measure: null,
    message: null,
    succeed: null,
    initialize: function(a) {
        SuperMap.REST.SpatialAnalystResult.prototype.initialize.apply(this, arguments);
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        var a = this;
        a.measure = null;
        a.message = null;
        a.succeed = null
    },
    CLASS_NAME: "SuperMap.REST.RouteCalculateMeasureResult"
});
SuperMap.REST.RouteCalculateMeasureResult.fromJson = function(c) {
    if (!c) {
        return
    }
    var a = new SuperMap.REST.RouteCalculateMeasureResult();
    if (c.measure) {
        a.measure = c.measure
    }
    if (c.message) {
        a.message = c.message
    }
    a.succeed = c.succeed;
    return a
}
;
SuperMap.REST.RouteCalculateMeasureEventArgs = SuperMap.Class(SuperMap.ServiceEventArgs, {
    result: null,
    initialize: function(a, d) {
        SuperMap.ServiceEventArgs.prototype.initialize.apply(this, [d]);
        var c = this;
        c.result = a
    },
    destroy: function() {
        SuperMap.ServiceEventArgs.prototype.destroy.apply(this, arguments);
        var a = this;
        if (a.result) {
            a.result.destroy();
            a.result = null
        }
    },
    CLASS_NAME: "SuperMap.REST.RouteCalculateMeasureEventArgs"
});
SuperMap.REST.RouteCalculateMeasureService = SuperMap.Class(SuperMap.ServiceBase, {
    EVENT_TYPES: ["processCompleted", "processFailed"],
    events: null,
    eventListeners: null,
    lastResult: null,
    initialize: function(c, a) {
        SuperMap.ServiceBase.prototype.initialize.apply(this, [c]);
        var d = this;
        if (a) {
            SuperMap.Util.extend(d, a)
        }
        d.events = new SuperMap.Events(d,null,d.EVENT_TYPES,true);
        if (d.eventListeners instanceof Object) {
            d.events.on(d.eventListeners)
        }
    },
    destroy: function() {
        SuperMap.ServiceBase.prototype.destroy.apply(this, arguments);
        var a = this;
        a.EVENT_TYPES = null;
        if (a.events) {
            a.events.destroy();
            a.events = null
        }
        if (a.eventListeners) {
            a.eventListeners = null
        }
        if (a.lastResult) {
            a.lastResult.destroy();
            a.lastResult = null
        }
    },
    processAsync: function(d) {
        if (!d) {
            return
        }
        var a = this, c;
        c = a.getJsonParameters(d);
        a.request({
            method: "POST",
            data: c,
            scope: a,
            success: a.RouteCalculateMeasureComplete,
            failure: a.RouteCalculateMeasureError
        })
    },
    RouteCalculateMeasureComplete: function(a) {
        var e = this, c, d;
        a = SuperMap.Util.transformResult(a);
        d = new SuperMap.REST.RouteCalculateMeasureResult.fromJson(a);
        e.lastResult = d;
        c = new SuperMap.REST.RouteCalculateMeasureEventArgs(d,a);
        e.events.triggerEvent("processCompleted", c)
    },
    RouteCalculateMeasureError: function(c) {
        var f = this, e, a, d;
        c = SuperMap.Util.transformResult(c);
        e = c.error;
        if (!e) {
            return
        }
        a = SuperMap.ServiceException.fromJson(e);
        d = new SuperMap.ServiceFailedEventArgs(a,c);
        f.events.triggerEvent("processFailed", d)
    },
    getJsonParameters: function(f) {
        var e, a = "geometry/calculatemeasure", d = this, c;
        c = d.url.substr(d.url.length - 1, 1);
        if (d.isInTheSameDomain) {
            d.url += (c === "/") ? a + ".json" : "/" + a + ".json"
        } else {
            d.url += (c === "/") ? a + ".jsonp" : "/" + a + ".jsonp"
        }
        d.url += "?returnContent=true";
        e = SuperMap.Util.toJSON(f);
        return e
    },
    CLASS_NAME: "SuperMap.REST.RouteCalculateMeasureService"
});
SuperMap.REST.RouteLocatorParameters = SuperMap.Class({
    sourceRoute: null,
    type: null,
    measure: null,
    offset: 0,
    isIgnoreGap: false,
    startMeasure: null,
    endMeasure: null,
    initialize: function(a) {
        if (a) {
            var d = a.sourceRoute;
            var c = {};
            if (d) {
                if (d instanceof SuperMap.Geometry && d.components) {
                    c.type = d.type;
                    c.parts = d.parts;
                    c.points = d.components;
                    a.sourceRoute = c
                }
            }
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        var a = this;
        a.sourceRoute = null;
        a.type = null;
        a.measure = null;
        a.offset = 0;
        a.isIgnoreGap = false;
        a.startMeasure = null;
        a.endMeasure = null
    },
    CLASS_NAME: "SuperMap.REST.RouteLocatorParameters"
});
SuperMap.REST.RouteLocatorResult = SuperMap.Class(SuperMap.REST.SpatialAnalystResult, {
    succeed: null,
    image: null,
    message: null,
    resultGeometry: null,
    initialize: function(a) {
        SuperMap.REST.SpatialAnalystResult.prototype.initialize.apply(this, arguments);
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        var a = this;
        a.succeed = null;
        if (a.image) {
            a.image = null
        }
        if (a.message) {
            a.message = null
        }
        a.resultGeometry = null
    },
    CLASS_NAME: "SuperMap.REST.RouteLocatorResult"
});
SuperMap.REST.RouteLocatorResult.fromJson = function(f) {
    if (!f) {
        return
    }
    var d = new SuperMap.REST.RouteLocatorResult();
    if (f.image) {
        d.image = f.image
    }
    if (f.message) {
        d.message = f.message
    }
    if (f.resultGeometry) {
        if (f.resultGeometry.type === "POINT") {
            var c = f.resultGeometry.points[0].x;
            var j = f.resultGeometry.points[0].y;
            d.resultGeometry = new SuperMap.Geometry.Point(c,j)
        } else {
            if (f.resultGeometry.type === "LINE") {
                var h = f.resultGeometry.points.length;
                var g = [];
                for (var e = 0; e < h; e++) {
                    var c = f.resultGeometry.points[e].x;
                    var j = f.resultGeometry.points[e].y;
                    var a = new SuperMap.Geometry.Point(c,j);
                    g.push(a)
                }
                d.resultGeometry = new SuperMap.Geometry.LineString(g)
            }
        }
    }
    d.succeed = f.succeed;
    return d
}
;
SuperMap.REST.RouteLocatorEventArgs = SuperMap.Class(SuperMap.ServiceEventArgs, {
    result: null,
    initialize: function(a, d) {
        SuperMap.ServiceEventArgs.prototype.initialize.apply(this, [d]);
        var c = this;
        c.result = a
    },
    destroy: function() {
        SuperMap.ServiceEventArgs.prototype.destroy.apply(this, arguments);
        var a = this;
        if (a.result) {
            a.result.destroy();
            a.result = null
        }
    },
    CLASS_NAME: "SuperMap.REST.RouteLocatorEventArgs"
});
SuperMap.REST.RouteLocatorService = SuperMap.Class(SuperMap.ServiceBase, {
    EVENT_TYPES: ["processCompleted", "processFailed"],
    events: null,
    eventListeners: null,
    lastResult: null,
    initialize: function(c, a) {
        SuperMap.ServiceBase.prototype.initialize.apply(this, [c]);
        var d = this;
        if (a) {
            SuperMap.Util.extend(d, a)
        }
        d.events = new SuperMap.Events(d,null,d.EVENT_TYPES,true);
        if (d.eventListeners instanceof Object) {
            d.events.on(d.eventListeners)
        }
    },
    destroy: function() {
        SuperMap.ServiceBase.prototype.destroy.apply(this, arguments);
        var a = this;
        a.EVENT_TYPES = null;
        if (a.events) {
            a.events.destroy();
            a.events = null
        }
        if (a.eventListeners) {
            a.eventListeners = null
        }
        if (a.lastResult) {
            a.lastResult.destroy();
            a.lastResult = null
        }
    },
    processAsync: function(d) {
        if (!d) {
            return
        }
        var a = this, c;
        c = a.getJsonParameters(d);
        a.request({
            method: "POST",
            data: c,
            scope: a,
            success: a.RouteLocatorComplete,
            failure: a.RouteLocatorError
        })
    },
    RouteLocatorComplete: function(a) {
        var d = this, c, e;
        a = SuperMap.Util.transformResult(a);
        e = new SuperMap.REST.RouteLocatorResult.fromJson(a);
        d.lastResult = e;
        c = new SuperMap.REST.RouteLocatorEventArgs(e,a);
        d.events.triggerEvent("processCompleted", c)
    },
    RouteLocatorError: function(c) {
        var f = this, e, a, d;
        c = SuperMap.Util.transformResult(c);
        e = c.error;
        if (!e) {
            return
        }
        a = SuperMap.ServiceException.fromJson(e);
        d = new SuperMap.ServiceFailedEventArgs(a,c);
        f.events.triggerEvent("processFailed", d)
    },
    getJsonParameters: function(f) {
        var e, a = "geometry/routelocator", d = this, c;
        c = d.url.substr(d.url.length - 1, 1);
        if (d.isInTheSameDomain) {
            d.url += (c === "/") ? a + ".json" : "/" + a + ".json"
        } else {
            d.url += (c === "/") ? a + ".jsonp" : "/" + a + ".jsonp"
        }
        d.url += "?returnContent=true";
        e = SuperMap.Util.toJSON(f);
        return e
    },
    CLASS_NAME: "SuperMap.REST.RouteLocatorService"
});
SuperMap.REST.GetFeaturesServiceBase = SuperMap.Class(SuperMap.ServiceBase, {
    EVENT_TYPES: ["processCompleted", "processFailed"],
    events: null,
    eventListeners: null,
    lastResult: null,
    returnContent: true,
    fromIndex: 0,
    toIndex: 19,
    initialize: function(d, c) {
        SuperMap.ServiceBase.prototype.initialize.apply(this, [d]);
        if (c) {
            SuperMap.Util.extend(this, c)
        }
        var e = this, a;
        e.events = new SuperMap.Events(e,null,e.EVENT_TYPES,true);
        if (e.eventListeners instanceof Object) {
            e.events.on(e.eventListeners)
        }
        a = e.url.substr(e.url.length - 1, 1);
        if (e.isInTheSameDomain) {
            e.url += (a == "/") ? "featureResults.json?" : "/featureResults.json?"
        } else {
            e.url += (a == "/") ? "featureResults.jsonp?" : "/featureResults.jsonp?"
        }
    },
    destroy: function() {
        SuperMap.ServiceBase.prototype.destroy.apply(this, arguments);
        var a = this;
        a.EVENT_TYPES = null;
        a.returnContent = null;
        a.fromIndex = null;
        a.toIndex = null;
        if (a.events) {
            a.events.destroy();
            a.events = null
        }
        if (a.eventListeners) {
            a.eventListeners = null
        }
        if (a.lastResult) {
            a.lastResult.destroy();
            a.lastResult = null
        }
    },
    processAsync: function(e) {
        if (!e) {
            return
        }
        var c = this
          , d = null
          , a = true;
        c.returnContent = e.returnContent;
        c.fromIndex = e.fromIndex;
        c.toIndex = e.toIndex;
        if (c.returnContent) {
            c.url += "returnContent=" + c.returnContent;
            a = false
        }
        if (c.fromIndex != null && c.toIndex != null && !isNaN(c.fromIndex) && !isNaN(c.toIndex) && c.fromIndex >= 0 && c.toIndex >= 0 && !a) {
            c.url += "&fromIndex=" + c.fromIndex + "&toIndex=" + c.toIndex
        }
        d = c.getJsonParameters(e);
        c.request({
            method: "POST",
            data: d,
            scope: c,
            success: c.getFeatureComplete,
            failure: c.getFeatureError
        })
    },
    getFeatureComplete: function(a) {
        var e = this
          , c = null
          , d = null;
        a = SuperMap.Util.transformResult(a);
        if (e.returnContent) {
            d = SuperMap.REST.GetFeaturesResult.fromJson(a)
        } else {
            d = new SuperMap.REST.GetFeaturesResult();
            d.resourceInfo = SuperMap.REST.ResourceInfo.fromJson(a)
        }
        e.lastResult = d;
        c = new SuperMap.REST.GetFeaturesEventArgs(d,a);
        e.events.triggerEvent("processCompleted", c)
    },
    getFeatureError: function(c) {
        var f = this
          , e = null
          , a = null
          , d = null;
        c = SuperMap.Util.transformResult(c);
        e = c.error;
        if (!e) {
            return
        }
        a = SuperMap.ServiceException.fromJson(e);
        d = new SuperMap.ServiceFailedEventArgs(a,c);
        f.events.triggerEvent("processFailed", d)
    },
    CLASS_NAME: "SuperMap.REST.GetFeaturesServiceBase"
});
SuperMap.REST.GetFeaturesParametersBase = SuperMap.Class({
    datasetNames: null,
    returnContent: true,
    fromIndex: 0,
    toIndex: 19,
    initialize: function(a) {
        if (!a) {
            return
        }
        SuperMap.Util.extend(this, a)
    },
    destroy: function() {
        var a = this;
        a.datasetNames = null;
        a.returnContent = null;
        a.fromIndex = null;
        a.toIndex = null
    },
    CLASS_NAME: "SuperMap.REST.GetFeaturesParametersBase"
});
SuperMap.REST.GetFeaturesByIDsParameters = SuperMap.Class(SuperMap.REST.GetFeaturesParametersBase, {
    getFeatureMode: "ID",
    IDs: null,
    fields: null,
    initialize: function(a) {
        SuperMap.REST.GetFeaturesParametersBase.prototype.initialize.apply(this, arguments);
        if (!a) {
            return
        }
        SuperMap.Util.extend(this, a)
    },
    destroy: function() {
        var a = this;
        SuperMap.REST.GetFeaturesParametersBase.prototype.destroy.apply(a, arguments);
        a.IDs = null;
        a.getFeatureMode = null;
        if (a.fields) {
            while (a.fields.length > 0) {
                a.fields.pop()
            }
            a.fields = null
        }
    },
    CLASS_NAME: "SuperMap.REST.GetFeaturesByIDsParameters"
});
SuperMap.REST.GetFeaturesByIDsParameters.toJsonParameters = function(d) {
    var a, c;
    a = {
        datasetNames: d.datasetNames,
        getFeatureMode: "ID",
        ids: d.IDs
    };
    if (d.fields) {
        c = new SuperMap.REST.FilterParameter();
        c.name = d.datasetNames;
        c.fields = d.fields;
        a.queryParameter = c
    }
    return SuperMap.Util.toJSON(a)
}
;
SuperMap.REST.GetFeaturesResult = SuperMap.Class({
    featureCount: null,
    featureUriList: null,
    features: null,
    resourceInfo: null,
    initialize: function(a) {
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        var d = this;
        d.featureCount = null;
        if (d.featureUriList) {
            d.featureUriList.length = 0;
            d.featureUriList = null
        }
        if (d.features) {
            for (var c = 0, a = d.features.length; c < a; c++) {
                d.features[c].destroy()
            }
            d.features = null
        }
        if (d.resourceInfo) {
            d.resourceInfo.destroy();
            d.resourceInfo = null
        }
    },
    CLASS_NAME: "SuperMap.REST.GetFeaturesResult"
});
SuperMap.REST.GetFeaturesResult.fromJson = function(e) {
    if (!e) {
        return
    }
    var f = null;
    if (e.features) {
        f = [];
        for (var d = 0, c = e.features, a = c.length; d < a; d++) {
            feature = SuperMap.REST.ServerFeature.fromJson(c[d]).toFeature();
            f.push(feature)
        }
    }
    return new SuperMap.REST.GetFeaturesResult({
        featureCount: e.featureCount,
        featureUriList: e.featureUriList,
        features: f,
        resourceInfo: e.resourceInfo
    })
}
;
SuperMap.REST.GetFeaturesByIDsService = SuperMap.Class(SuperMap.REST.GetFeaturesServiceBase, {
    initialize: function(c, a) {
        SuperMap.REST.GetFeaturesServiceBase.prototype.initialize.apply(this, arguments)
    },
    destroy: function() {
        SuperMap.REST.GetFeaturesServiceBase.prototype.destroy.apply(this, arguments)
    },
    getJsonParameters: function(a) {
        return SuperMap.REST.GetFeaturesByIDsParameters.toJsonParameters(a)
    },
    CLASS_NAME: "SuperMap.REST.GetFeaturesByIDsService"
});
SuperMap.REST.GetFeaturesEventArgs = SuperMap.Class(SuperMap.ServiceEventArgs, {
    result: null,
    initialize: function(a, d) {
        SuperMap.ServiceEventArgs.prototype.initialize.apply(this, [d]);
        var c = this;
        c.result = a
    },
    destroy: function() {
        SuperMap.ServiceEventArgs.prototype.destroy.apply(this);
        var a = this;
        if (a.result) {
            a.result.destroy();
            a.result = null
        }
    },
    CLASS_NAME: "SuperMap.REST.GetFeaturesEventArgs"
});
SuperMap.REST.GetFeaturesByBufferParameters = SuperMap.Class(SuperMap.REST.GetFeaturesParametersBase, {
    bufferDistance: null,
    attributeFilter: null,
    geometry: null,
    fields: null,
    initialize: function(a) {
        SuperMap.REST.GetFeaturesParametersBase.prototype.initialize.apply(this, arguments);
        if (!a) {
            return
        }
        SuperMap.Util.extend(this, a)
    },
    destroy: function() {
        SuperMap.REST.GetFeaturesParametersBase.prototype.destroy.apply(this, arguments);
        var a = this;
        a.bufferDistance = null;
        a.attributeFilter = null;
        if (a.fields) {
            while (a.fields.length > 0) {
                a.fields.pop()
            }
            a.fields = null
        }
        if (a.geometry) {
            a.geometry.destroy();
            a.geometry = null
        }
    },
    CLASS_NAME: "SuperMap.REST.GetFeaturesByBufferParameters"
});
SuperMap.REST.GetFeaturesByBufferParameters.toJsonParameters = function(e) {
    var a, d, c;
    c = SuperMap.REST.ServerGeometry.fromGeometry(e.geometry);
    d = {
        datasetNames: e.datasetNames,
        getFeatureMode: "BUFFER",
        bufferDistance: e.bufferDistance,
        geometry: c
    };
    if (e.fields) {
        a = new SuperMap.REST.FilterParameter();
        a.name = e.datasetNames;
        a.fields = e.fields;
        d.queryParameter = a
    }
    if (e.attributeFilter) {
        d.attributeFilter = e.attributeFilter;
        d.getFeatureMode = "BUFFER_ATTRIBUTEFILTER"
    }
    return SuperMap.Util.toJSON(d)
}
;
SuperMap.REST.GetFeaturesByBufferService = SuperMap.Class(SuperMap.REST.GetFeaturesServiceBase, {
    initialize: function(c, a) {
        SuperMap.REST.GetFeaturesServiceBase.prototype.initialize.apply(this, arguments)
    },
    destroy: function() {
        SuperMap.REST.GetFeaturesServiceBase.prototype.destroy.apply(this, arguments)
    },
    getJsonParameters: function(a) {
        return SuperMap.REST.GetFeaturesByBufferParameters.toJsonParameters(a)
    },
    CLASS_NAME: "SuperMap.REST.GetFeaturesByBufferService"
});
SuperMap.REST.GetFeaturesBySQLParameters = SuperMap.Class(SuperMap.REST.GetFeaturesParametersBase, {
    getFeatureMode: "SQL",
    queryParameter: null,
    initialize: function(a) {
        SuperMap.REST.GetFeaturesParametersBase.prototype.initialize.apply(this, arguments);
        if (!a) {
            return
        }
        SuperMap.Util.extend(this, a)
    },
    destroy: function() {
        SuperMap.REST.GetFeaturesParametersBase.prototype.destroy.apply(this, arguments);
        var a = this;
        a.getFeatureMode = null;
        if (a.queryParameter) {
            a.queryParameter.destroy();
            a.queryParameter = null
        }
    },
    CLASS_NAME: "SuperMap.REST.GetFeaturesBySQLParameters"
});
SuperMap.REST.GetFeaturesBySQLParameters.toJsonParameters = function(c) {
    var a = {
        datasetNames: c.datasetNames,
        getFeatureMode: "SQL",
        queryParameter: c.queryParameter
    };
    return SuperMap.Util.toJSON(a)
}
;
SuperMap.REST.GetFeaturesBySQLService = SuperMap.Class(SuperMap.REST.GetFeaturesServiceBase, {
    initialize: function(c, a) {
        SuperMap.REST.GetFeaturesServiceBase.prototype.initialize.apply(this, arguments)
    },
    destroy: function() {
        SuperMap.REST.GetFeaturesServiceBase.prototype.destroy.apply(this, arguments)
    },
    getJsonParameters: function(a) {
        return SuperMap.REST.GetFeaturesBySQLParameters.toJsonParameters(a)
    },
    CLASS_NAME: "SuperMap.REST.GetFeaturesBySQLService"
});
SuperMap.REST.GetFeaturesByGeometryService = SuperMap.Class(SuperMap.REST.GetFeaturesServiceBase, {
    initialize: function(c, a) {
        SuperMap.REST.GetFeaturesServiceBase.prototype.initialize.apply(this, arguments)
    },
    destroy: function() {
        SuperMap.REST.GetFeaturesServiceBase.prototype.destroy.apply(this, arguments)
    },
    getJsonParameters: function(a) {
        return SuperMap.REST.GetFeaturesByGeometryParameters.toJsonParameters(a)
    },
    CLASS_NAME: "SuperMap.REST.GetFeaturesByGeometryService"
});
SuperMap.REST.GetFeaturesByGeometryParameters = SuperMap.Class(SuperMap.REST.GetFeaturesParametersBase, {
    getFeatureMode: "SPATIAL",
    geometry: null,
    fields: null,
    attributeFilter: null,
    spatialQueryMode: SuperMap.REST.SpatialQueryMode.CONTAIN,
    initialize: function(a) {
        SuperMap.REST.GetFeaturesParametersBase.prototype.initialize.apply(this, arguments);
        if (!a) {
            return
        }
        SuperMap.Util.extend(this, a)
    },
    destroy: function() {
        var a = this;
        SuperMap.REST.GetFeaturesParametersBase.prototype.destroy.apply(a, arguments);
        if (a.geometry) {
            a.geometry.destroy();
            a.geometry = null
        }
        if (a.fields) {
            while (a.fields.length > 0) {
                a.fields.pop()
            }
            a.fields = null
        }
        a.attributeFilter = null;
        a.spatialQueryMode = null;
        a.getFeatureMode = null
    },
    CLASS_NAME: "SuperMap.REST.GetFeaturesByGeometryParameters"
});
SuperMap.REST.GetFeaturesByGeometryParameters.toJsonParameters = function(e) {
    var c, d, a;
    d = SuperMap.REST.ServerGeometry.fromGeometry(e.geometry);
    a = {
        datasetNames: e.datasetNames,
        getFeatureMode: "SPATIAL",
        geometry: d,
        spatialQueryMode: e.spatialQueryMode
    };
    if (e.fields) {
        c = new SuperMap.REST.FilterParameter();
        c.name = e.datasetNames;
        c.fields = e.fields;
        a.queryParameter = c
    }
    if (e.attributeFilter) {
        a.attributeFilter = e.attributeFilter;
        a.getFeatureMode = "SPATIAL_ATTRIBUTEFILTER"
    }
    return SuperMap.Util.toJSON(a)
}
;
SuperMap.REST.EditFeaturesParameters = SuperMap.Class({
    features: null,
    editType: SuperMap.REST.EditType.ADD,
    IDs: null,
    returnContent: false,
    isUseBatch: false,
    initialize: function(a) {
        if (!a) {
            return
        }
        SuperMap.Util.extend(this, a)
    },
    destroy: function() {
        var a = this;
        a.features = null;
        a.editType = null;
        a.IDs = null;
        a.returnContent = null
    },
    CLASS_NAME: "SuperMap.REST.EditFeaturesParameters"
});
SuperMap.REST.EditFeaturesParameters.toJsonParameters = function(h) {
    var g, e, a, f, c = h.editType;
    if (c === SuperMap.REST.EditType.DELETE) {
        if (h.IDs === null) {
            return
        }
        f = {
            ids: h.IDs
        }
    } else {
        if (h.features === null) {
            return
        }
        a = h.features.length;
        f = [];
        for (var d = 0; d < a; d++) {
            e = h.features[d];
            e.geometry = SuperMap.REST.ServerGeometry.fromGeometry(e.geometry);
            f.push(e)
        }
    }
    return SuperMap.Util.toJSON(f)
}
;
SuperMap.REST.EditFeaturesEventArgs = SuperMap.Class(SuperMap.ServiceEventArgs, {
    result: null,
    initialize: function(a, d) {
        SuperMap.ServiceEventArgs.prototype.initialize.apply(this, [d]);
        var c = this;
        c.result = a
    },
    destroy: function() {
        SuperMap.ServiceEventArgs.prototype.destroy.apply(this);
        var a = this;
        if (a.result) {
            a.result.destroy();
            a.result = null
        }
    },
    CLASS_NAME: "SuperMap.REST.EditFeaturesEventArgs"
});
SuperMap.REST.EditFeaturesResult = SuperMap.Class({
    IDs: null,
    resourceInfo: null,
    initialize: function(a) {
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        var a = this;
        a.IDs = null;
        if (a.resourceInfo) {
            a.resourceInfo.destroy();
            a.resourceInfo = null
        }
    },
    CLASS_NAME: "SuperMap.REST.EditFeaturesResult"
});
SuperMap.REST.EditFeaturesResult.fromJson = function(a) {
    if (!a) {
        return
    }
    if (a instanceof Array) {
        return new SuperMap.REST.EditFeaturesResult({
            IDs: a
        })
    } else {
        return new SuperMap.REST.EditFeaturesResult({
            resourceInfo: SuperMap.REST.ResourceInfo.fromJson(a)
        })
    }
}
;
SuperMap.REST.EditFeaturesService = SuperMap.Class(SuperMap.ServiceBase, {
    EVENT_TYPES: ["processCompleted", "processFailed"],
    events: null,
    eventListeners: null,
    lastResult: null,
    returnContent: false,
    isUseBatch: false,
    initialize: function(d, c) {
        SuperMap.ServiceBase.prototype.initialize.apply(this, [d]);
        if (c) {
            SuperMap.Util.extend(this, c)
        }
        var e = this, a;
        e.events = new SuperMap.Events(e,null,e.EVENT_TYPES,true);
        if (e.eventListeners instanceof Object) {
            e.events.on(e.eventListeners)
        }
        a = e.url.substr(e.url.length - 1, 1);
        if (e.isInTheSameDomain) {
            e.url += (a == "/") ? "features.json?" : "/features.json?"
        } else {
            e.url += (a == "/") ? "features.jsonp?" : "/features.jsonp?"
        }
    },
    destroy: function() {
        SuperMap.ServiceBase.prototype.destroy.apply(this, arguments);
        var a = this;
        a.EVENT_TYPES = null;
        a.returnContent = null;
        a.isUseBatch = null;
        a.fromIndex = null;
        a.toIndex = null;
        if (a.events) {
            a.events.destroy();
            a.events = null
        }
        if (a.eventListeners) {
            a.eventListeners = null
        }
        if (a.lastResult) {
            a.lastResult.destroy();
            a.lastResult = null
        }
    },
    processAsync: function(f) {
        if (!f) {
            return
        }
        var k = this
          , a = "POST"
          , c = "["
          , e = f.editType
          , j = null;
        k.returnContent = f.returnContent;
        k.isUseBatch = f.isUseBatch;
        j = SuperMap.REST.EditFeaturesParameters.toJsonParameters(f);
        if (e === SuperMap.REST.EditType.DELETE) {
            for (var g = 0, h = f.IDs.length, d = f.IDs; g < h; g++) {
                if (g !== h - 1) {
                    c += d[g] + ","
                } else {
                    c += d[g]
                }
            }
            c += "]";
            k.url += "ids=" + c;
            a = "DELETE";
            j = c
        } else {
            if (e === SuperMap.REST.EditType.UPDATE) {
                a = "PUT"
            } else {
                if (k.isUseBatch) {
                    k.url += "isUseBatch=" + k.isUseBatch;
                    k.returnContent = false
                }
                if (k.returnContent) {
                    k.url += "returnContent=" + k.returnContent;
                    a = "POST"
                }
            }
        }
        k.request({
            method: a,
            data: j,
            scope: k,
            success: k.editFeaturesComplted,
            failure: k.editFeaturesFailed
        })
    },
    editFeaturesComplted: function(a) {
        var e = this
          , c = null
          , d = null;
        a = SuperMap.Util.transformResult(a);
        if (e.returnContent) {
            d = SuperMap.REST.EditFeaturesResult.fromJson(a)
        } else {
            d = new SuperMap.REST.EditFeaturesResult();
            d.resourceInfo = SuperMap.REST.ResourceInfo.fromJson(a)
        }
        e.lastResult = d;
        c = new SuperMap.REST.EditFeaturesEventArgs(d,a);
        e.events.triggerEvent("processCompleted", c)
    },
    editFeaturesFailed: function(c) {
        var f = this
          , e = null
          , a = null
          , d = null;
        c = SuperMap.Util.transformResult(c);
        e = c.error;
        if (!e) {
            return
        }
        a = SuperMap.ServiceException.fromJson(e);
        d = new SuperMap.ServiceFailedEventArgs(a,c);
        f.events.triggerEvent("processFailed", d)
    },
    CLASS_NAME: "SuperMap.REST.EditFeaturesService"
});
SuperMap.REST.GetFieldsResult = SuperMap.Class({
    fieldNames: null,
    childUriList: null,
    initialize: function(a) {
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        var a = this;
        a.fieldNames = null;
        a.childUriList = null
    },
    CLASS_NAME: "SuperMap.REST.GetFieldsResult"
});
SuperMap.REST.GetFieldsResult.fromJson = function(a) {
    if (!a) {
        return
    }
    return new SuperMap.REST.GetFieldsResult({
        fieldNames: a.fieldNames,
        childUriList: a.childUriList
    })
}
;
SuperMap.REST.GetFieldsEventArgs = SuperMap.Class(SuperMap.ServiceEventArgs, {
    result: null,
    initialize: function(a, d) {
        SuperMap.ServiceEventArgs.prototype.initialize.apply(this, [d]);
        var c = this;
        c.result = a
    },
    destroy: function() {
        SuperMap.ServiceEventArgs.prototype.destroy.apply(this);
        var a = this;
        if (a.result) {
            a.result.destroy();
            a.result = null
        }
    },
    CLASS_NAME: "SuperMap.REST.GetFieldsEventArgs"
});
SuperMap.REST.GetFieldsService = SuperMap.Class(SuperMap.ServiceBase, {
    EVENT_TYPES: ["processCompleted", "processFailed"],
    events: null,
    eventListeners: null,
    lastResult: null,
    datasource: null,
    dataset: null,
    initialize: function(d, c) {
        SuperMap.ServiceBase.prototype.initialize.apply(this, [d]);
        if (c) {
            SuperMap.Util.extend(this, c)
        }
        var e = this, a;
        e.events = new SuperMap.Events(e,null,e.EVENT_TYPES,true);
        if (e.eventListeners instanceof Object) {
            e.events.on(e.eventListeners)
        }
    },
    destroy: function() {
        SuperMap.ServiceBase.prototype.destroy.apply(this, arguments);
        var a = this;
        a.EVENT_TYPES = null;
        a.datasource = null;
        a.dataset = null;
        if (a.events) {
            a.events.destroy();
            a.events = null
        }
        if (a.eventListeners) {
            a.eventListeners = null
        }
        if (a.lastResult) {
            a.lastResult.destroy();
            a.lastResult = null
        }
    },
    processAsync: function() {
        var c = this
          , a = c.url.substr(c.url.length - 1, 1)
          , d = "datasources/" + c.datasource + "/datasets/" + c.dataset;
        if (c.isInTheSameDomain) {
            c.url += (a == "/") ? d + "/fields.json?" : "/" + d + "/fields.json?"
        } else {
            c.url += (a == "/") ? d + "fields.jsonp?" : "/" + d + "/fields.jsonp?"
        }
        c.request({
            method: "GET",
            data: null,
            scope: c,
            success: c.getFieldsComplted,
            failure: c.getFieldsFailed
        })
    },
    getFieldsComplted: function(a) {
        var d = this
          , c = null
          , e = null;
        a = SuperMap.Util.transformResult(a);
        e = SuperMap.REST.GetFieldsResult.fromJson(a);
        d.lastResult = e;
        c = new SuperMap.REST.GetFieldsEventArgs(e,a);
        d.events.triggerEvent("processCompleted", c)
    },
    getFieldsFailed: function(c) {
        var f = this
          , e = null
          , a = null
          , d = null;
        c = SuperMap.Util.transformResult(c);
        e = c.error;
        if (!e) {
            return
        }
        a = SuperMap.ServiceException.fromJson(e);
        d = new SuperMap.ServiceFailedEventArgs(a,c);
        f.events.triggerEvent("processFailed", d)
    },
    CLASS_NAME: "SuperMap.REST.GetFieldsService"
});
SuperMap.REST.FieldStatisticResult = SuperMap.Class({
    mode: null,
    result: null,
    initialize: function(a) {
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        var a = this;
        a.mode = null;
        a.result = null
    },
    CLASS_NAME: "SuperMap.REST.FieldStatisticResult"
});
SuperMap.REST.FieldStatisticResult.fromJson = function(a) {
    if (!a) {
        return
    }
    return new SuperMap.REST.FieldStatisticResult({
        mode: a.mode,
        result: Number(a.result)
    })
}
;
SuperMap.REST.FieldStatisticEventArgs = SuperMap.Class(SuperMap.ServiceEventArgs, {
    result: null,
    initialize: function(a, d) {
        SuperMap.ServiceEventArgs.prototype.initialize.apply(this, [d]);
        var c = this;
        c.result = a
    },
    destroy: function() {
        SuperMap.ServiceEventArgs.prototype.destroy.apply(this);
        var a = this;
        if (a.result) {
            a.result.destroy();
            a.result = null
        }
    },
    CLASS_NAME: "SuperMap.REST.FieldStatisticEventArgs"
});
SuperMap.REST.FieldStatisticService = SuperMap.Class(SuperMap.ServiceBase, {
    EVENT_TYPES: ["processCompleted", "processFailed"],
    events: null,
    eventListeners: null,
    lastResult: null,
    datasource: null,
    dataset: null,
    field: null,
    statisticMode: null,
    initialize: function(d, c) {
        SuperMap.ServiceBase.prototype.initialize.apply(this, [d]);
        if (c) {
            SuperMap.Util.extend(this, c)
        }
        var e = this, a;
        e.events = new SuperMap.Events(e,null,e.EVENT_TYPES,true);
        if (e.eventListeners instanceof Object) {
            e.events.on(e.eventListeners)
        }
    },
    destroy: function() {
        SuperMap.ServiceBase.prototype.destroy.apply(this, arguments);
        var a = this;
        a.EVENT_TYPES = null;
        a.datasource = null;
        a.dataset = null;
        a.field = null;
        a.statisticMode = null;
        if (a.events) {
            a.events.destroy();
            a.events = null
        }
        if (a.eventListeners) {
            a.eventListeners = null
        }
        if (a.lastResult) {
            a.lastResult.destroy();
            a.lastResult = null
        }
    },
    processAsync: function() {
        var d = this
          , a = d.url.substr(d.url.length - 1, 1)
          , c = "datasources/" + d.datasource + "/datasets/" + d.dataset + "/fields/" + d.field + "/" + d.statisticMode;
        if (d.isInTheSameDomain) {
            d.url += (a == "/") ? c + ".json?" : "/" + c + ".json?"
        } else {
            d.url += (a == "/") ? c + ".jsonp?" : "/" + c + ".jsonp?"
        }
        d.request({
            method: "GET",
            data: null,
            scope: d,
            success: d.fieldStatisticCompleted,
            failure: d.fieldStatisticFailed
        })
    },
    fieldStatisticCompleted: function(a) {
        var e = this
          , c = null
          , d = null;
        a = SuperMap.Util.transformResult(a);
        d = SuperMap.REST.FieldStatisticResult.fromJson(a);
        e.lastResult = d;
        c = new SuperMap.REST.FieldStatisticEventArgs(d,a);
        e.events.triggerEvent("processCompleted", c)
    },
    fieldStatisticFailed: function(c) {
        var f = this
          , e = null
          , a = null
          , d = null;
        c = SuperMap.Util.transformResult(c);
        e = c.error;
        if (!e) {
            return
        }
        a = SuperMap.ServiceException.fromJson(e);
        d = new SuperMap.ServiceFailedEventArgs(a,c);
        f.events.triggerEvent("processFailed", d)
    },
    CLASS_NAME: "SuperMap.REST.FieldStatisticService"
});
SuperMap.REST.TransferGuide = SuperMap.Class({
    count: null,
    items: null,
    totalDistance: null,
    transferCount: null,
    initialize: function(a) {
        a = a || {};
        SuperMap.Util.extend(this, a)
    },
    destroy: function() {
        SuperMap.Util.reset(this)
    },
    CLASS_NAME: "SuperMap.REST.TransferGuide"
});
SuperMap.REST.TransferGuide.fromJson = function(f) {
    if (!f) {
        return
    }
    var c = [], e = f.items, a = e ? e.length : 0, g;
    for (var d = 0; d < a; d++) {
        g = SuperMap.REST.TransferGuideItem.fromJson(e[d]);
        c.push(g)
    }
    return new SuperMap.REST.TransferGuide({
        count: f.count,
        transferCount: f.transferCount,
        totalDistance: f.totalDistance,
        items: c
    })
}
;
SuperMap.REST.TransferGuideItem = SuperMap.Class({
    lineType: null,
    distance: null,
    endIndex: null,
    startIndex: null,
    isWalking: null,
    route: null,
    passStopCount: null,
    lineName: null,
    startPosition: null,
    endPosition: null,
    startStopName: null,
    endStopName: null,
    initialize: function(a) {
        a = a || {};
        SuperMap.Util.extend(this, a)
    },
    destroy: function() {
        SuperMap.Util.reset(this)
    },
    CLASS_NAME: "SuperMap.REST.TransferGuideItem"
});
SuperMap.REST.TransferGuideItem.fromJson = function(d) {
    if (!d) {
        return
    }
    var a = d.route, e = [], f;
    if (a && a.points && a.points.length) {
        for (var c in a.points) {
            f = a.points[c];
            e.push(new SuperMap.Geometry.Point(f.x,f.y))
        }
    }
    return new SuperMap.REST.TransferGuideItem({
        lineType: d.lineType,
        distance: d.distance,
        endStopName: d.endStopName,
        startStopName: d.startStopName,
        isWalking: d.isWalking,
        lineName: d.lineName,
        passStopCount: d.passStopCount,
        startIndex: d.startIndex,
        endIndex: d.endIndex,
        startPosition: d.startPosition,
        endPosition: d.endPosition,
        route: new SuperMap.Geometry.LineString(e)
    })
}
;
SuperMap.REST.TransferStopInfo = SuperMap.Class({
    alias: null,
    id: null,
    name: null,
    position: null,
    stopID: null,
    initialize: function(a) {
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        var a = this;
        a.alias = null;
        a.id = null;
        a.name = null;
        a.position = null;
        a.stopID = null
    },
    CLASS_NAME: "SuperMap.REST.TransferStopInfo"
});
SuperMap.REST.TransferStopInfo.fromJson = function(a) {
    if (!a) {
        return
    }
    return new SuperMap.REST.TransferStopInfo({
        alias: a.alias,
        id: a.id,
        name: a.name,
        position: a.position,
        stopID: a.stopID
    })
}
;
SuperMap.REST.TransferLines = SuperMap.Class({
    lineItems: null,
    initialize: function(a) {
        a = a || {};
        SuperMap.Util.extend(this, a)
    },
    destroy: function() {
        SuperMap.Util.reset(this)
    },
    CLASS_NAME: "SuperMap.REST.TransferLines"
});
SuperMap.REST.TransferLines.fromJson = function(e) {
    if (!e) {
        return
    }
    var g = e.lineItems, c = [], a = g ? g.length : 0, f;
    for (var d = 0; d < a; d++) {
        f = SuperMap.REST.TransferLine.fromJson(g[d]);
        c.push(f)
    }
    return new SuperMap.REST.TransferLines({
        lineItems: c
    })
}
;
SuperMap.REST.TransferLine = SuperMap.Class({
    lineID: null,
    lineName: null,
    startStopIndex: null,
    startStopName: null,
    endStopIndex: null,
    endStopName: null,
    initialize: function(a) {
        a = a || {};
        SuperMap.Util.extend(this, a)
    },
    destroy: function() {
        SuperMap.Util.reset(this)
    },
    CLASS_NAME: "SuperMap.REST.TransferLine"
});
SuperMap.REST.TransferLine.fromJson = function(a) {
    if (!a) {
        return
    }
    return new SuperMap.REST.TransferLine({
        lineID: a.lineID,
        lineName: a.lineName,
        startStopIndex: a.startStopIndex,
        startStopName: a.startStopName,
        endStopIndex: a.endStopIndex,
        endStopName: a.endStopName
    })
}
;
SuperMap.REST.TransferSolution = SuperMap.Class({
    transferCount: null,
    linesItems: null,
    initialize: function(a) {
        a = a || {};
        SuperMap.Util.extend(this, a)
    },
    destroy: function() {
        SuperMap.Util.reset(this)
    },
    CLASS_NAME: "SuperMap.REST.TransferSolution"
});
SuperMap.REST.TransferSolution.fromJson = function(e) {
    if (!e) {
        return
    }
    var g = e.linesItems, c = [], a = g ? g.length : 0, f;
    for (var d = 0; d < a; d++) {
        f = SuperMap.REST.TransferLines.fromJson(g[d]);
        c.push(f)
    }
    return new SuperMap.REST.TransferSolution({
        transferCount: e.transferCount,
        linesItems: c
    })
}
;
SuperMap.REST.StopQueryService = SuperMap.Class(SuperMap.ServiceBase, {
    EVENT_TYPES: ["processCompleted", "processFailed"],
    events: null,
    eventListeners: null,
    lastResult: null,
    initialize: function(c, a) {
        SuperMap.ServiceBase.prototype.initialize.apply(this, [c]);
        a = a || {};
        SuperMap.Util.extend(this, a);
        var d = this;
        d.events = new SuperMap.Events(d,null,d.EVENT_TYPES,true);
        if (d.eventListeners instanceof Object) {
            d.events.on(d.eventListeners)
        }
    },
    destroy: function() {
        SuperMap.ServiceBase.prototype.destroy.apply(this, arguments);
        SuperMap.Util.reset(this)
    },
    processAsync: function(d) {
        if (!d) {
            return
        }
        var c = this, a;
        a = c.url.substr(c.url.length - 1, 1);
        c.url += (a === "/") ? "" : "/";
        c.url += "stops/keyword/" + d.keyWord;
        c.url += c.isInTheSameDomain ? ".json?" : ".jsonp";
        c.request({
            method: "GET",
            params: {
                returnPosition: d.returnPosition
            },
            scope: c,
            success: c.StopQueryCompleted,
            failure: c.StopQueryFailed
        })
    },
    StopQueryCompleted: function(a) {
        var d = this
          , c = null
          , e = null;
        a = SuperMap.Util.transformResult(a);
        e = SuperMap.REST.StopQueryResult.fromJson(a);
        d.lastResult = e;
        c = new SuperMap.REST.StopQueryEventArgs(e,a);
        d.events.triggerEvent("processCompleted", c)
    },
    StopQueryFailed: function(c) {
        var f = this
          , e = null
          , a = null
          , d = null;
        c = SuperMap.Util.transformResult(c);
        e = c.error;
        if (!e) {
            return
        }
        a = SuperMap.ServiceException.fromJson(e);
        d = new SuperMap.ServiceFailedEventArgs(a,c);
        f.events.triggerEvent("processFailed", d)
    },
    CLASS_NAME: "SuperMap.REST.StopQueryService"
});
SuperMap.REST.StopQueryEventArgs = SuperMap.Class(SuperMap.ServiceEventArgs, {
    result: null,
    initialize: function(a, d) {
        SuperMap.ServiceEventArgs.prototype.initialize.apply(this, [d]);
        var c = this;
        c.result = a
    },
    destroy: function() {
        SuperMap.ServiceEventArgs.prototype.destroy.apply(this);
        SuperMap.Util.reset(this)
    },
    CLASS_NAME: "SuperMap.REST.StopQueryEventArgs"
});
SuperMap.REST.StopQueryParameters = SuperMap.Class({
    keyWord: null,
    returnPosition: false,
    initialize: function(a) {
        a = a || {};
        SuperMap.Util.extend(this, a)
    },
    destroy: function() {
        SuperMap.Util.reset(this)
    },
    CLASS_NAME: "SuperMap.REST.StopQueryParameters"
});
SuperMap.REST.StopQueryResult = SuperMap.Class({
    transferStopInfos: null,
    initialize: function(a) {
        a = a || {};
        SuperMap.Util.extend(this, a)
    },
    destroy: function() {
        SuperMap.Util.reset(this)
    },
    CLASS_NAME: "SuperMap.REST.StopQueryResult"
});
SuperMap.REST.StopQueryResult.fromJson = function(e) {
    if (!e) {
        return
    }
    var f = [];
    for (var c = 0, a = e.length; c < a; c++) {
        var d = e[c];
        f.push(SuperMap.REST.TransferStopInfo.fromJson(e[c]))
    }
    return new SuperMap.REST.StopQueryResult({
        transferStopInfos: f
    })
}
;
SuperMap.REST.TransferPathService = SuperMap.Class(SuperMap.ServiceBase, {
    EVENT_TYPES: ["processCompleted", "processFailed"],
    events: null,
    eventListeners: null,
    lastResult: null,
    initialize: function(c, a) {
        SuperMap.ServiceBase.prototype.initialize.apply(this, [c]);
        a = a || {};
        SuperMap.Util.extend(this, a);
        var d = this;
        d.events = new SuperMap.Events(d,null,d.EVENT_TYPES,true);
        if (d.eventListeners instanceof Object) {
            d.events.on(d.eventListeners)
        }
    },
    destroy: function() {
        SuperMap.ServiceBase.prototype.destroy.apply(this, arguments);
        SuperMap.Util.reset(this)
    },
    processAsync: function(d) {
        if (!d) {
            return
        }
        var a = this, e = "GET", c;
        end = a.url.substr(a.url.length - 1, 1);
        a.url += (end === "/") ? "" : "/";
        a.url += a.isInTheSameDomain ? "path.json?" : "path.jsonp";
        c = {
            points: SuperMap.Util.toJSON(d.points),
            transferLines: d.transferLines
        };
        a.request({
            method: e,
            params: c,
            scope: a,
            success: a.TransferPathCompleted,
            failure: a.TransferPathFailed
        })
    },
    TransferPathCompleted: function(a) {
        var d = this
          , c = null
          , e = null;
        a = SuperMap.Util.transformResult(a);
        e = SuperMap.REST.TransferPathResult.fromJson(a);
        d.lastResult = e;
        c = new SuperMap.REST.TransferPathEventArgs(e,a);
        d.events.triggerEvent("processCompleted", c)
    },
    TransferPathFailed: function(c) {
        var f = this
          , e = null
          , a = null
          , d = null;
        c = SuperMap.Util.transformResult(c);
        e = c.error;
        if (!e) {
            return
        }
        a = SuperMap.ServiceException.fromJson(e);
        d = new SuperMap.ServiceFailedEventArgs(a,c);
        f.events.triggerEvent("processFailed", d)
    },
    CLASS_NAME: "SuperMap.REST.TransferPathService"
});
SuperMap.REST.TransferPathParameters = SuperMap.Class({
    transferLines: null,
    points: false,
    initialize: function(a) {
        a = a || {};
        SuperMap.Util.extend(this, a)
    },
    destroy: function() {
        SuperMap.Util.reset(this)
    },
    CLASS_NAME: "SuperMap.REST.TransferPathParameters"
});
SuperMap.REST.TransferPathParameters.toJson = function(a) {
    if (a) {
        return SuperMap.Util.toJSON(a)
    }
}
;
SuperMap.REST.TransferPathEventArgs = SuperMap.Class(SuperMap.ServiceEventArgs, {
    result: null,
    initialize: function(a, d) {
        SuperMap.ServiceEventArgs.prototype.initialize.apply(this, [d]);
        var c = this;
        c.result = a
    },
    destroy: function() {
        SuperMap.ServiceEventArgs.prototype.destroy.apply(this);
        SuperMap.Util.reset(this)
    },
    CLASS_NAME: "SuperMap.REST.TransferPathEventArgs"
});
SuperMap.REST.TransferPathResult = SuperMap.Class({
    transferGuide: null,
    initialize: function(a) {
        a = a || {};
        SuperMap.Util.extend(this, a)
    },
    destroy: function() {
        SuperMap.Util.reset(this)
    },
    CLASS_NAME: "SuperMap.REST.TransferPathResult"
});
SuperMap.REST.TransferPathResult.fromJson = function(c) {
    if (!c) {
        return
    }
    var a = SuperMap.REST.TransferGuide.fromJson(c);
    return new SuperMap.REST.TransferPathResult({
        transferGuide: a
    })
}
;
SuperMap.REST.TransferSolutionService = SuperMap.Class(SuperMap.ServiceBase, {
    EVENT_TYPES: ["processCompleted", "processFailed"],
    events: null,
    eventListeners: null,
    lastResult: null,
    initialize: function(c, a) {
        SuperMap.ServiceBase.prototype.initialize.apply(this, [c]);
        a = a || {};
        SuperMap.Util.extend(this, a);
        var d = this;
        d.events = new SuperMap.Events(d,null,d.EVENT_TYPES,true);
        if (d.eventListeners instanceof Object) {
            d.events.on(d.eventListeners)
        }
    },
    destroy: function() {
        SuperMap.ServiceBase.prototype.destroy.apply(this, arguments);
        SuperMap.Util.reset(this)
    },
    processAsync: function(d) {
        if (!d) {
            return
        }
        var a = this, e = "GET", c;
        end = a.url.substr(a.url.length - 1, 1);
        a.url += (end === "/") ? "" : "/";
        a.url += a.isInTheSameDomain ? "solutions.json?" : "solutions.jsonp";
        c = {
            points: SuperMap.Util.toJSON(d.points),
            walkingRatio: d.walkingRatio,
            transferTactic: d.transferTactic,
            solutionCount: d.solutionCount,
            transferPreference: d.transferPreference
        };
        a.request({
            method: e,
            params: c,
            scope: a,
            success: a.TransferSolutionComplted,
            failure: a.TransferSolutionFailed
        })
    },
    TransferSolutionComplted: function(a) {
        var e = this
          , d = null
          , c = null;
        a = SuperMap.Util.transformResult(a);
        c = SuperMap.REST.TransferSolutionResult.fromJson(a);
        e.lastResult = c;
        d = new SuperMap.REST.TransferSolutionEventArgs(c,a);
        e.events.triggerEvent("processCompleted", d)
    },
    TransferSolutionFailed: function(c) {
        var f = this
          , e = null
          , a = null
          , d = null;
        c = SuperMap.Util.transformResult(c);
        e = c.error;
        if (!e) {
            return
        }
        a = SuperMap.ServiceException.fromJson(e);
        d = new SuperMap.ServiceFailedEventArgs(a,c);
        f.events.triggerEvent("processFailed", d)
    },
    CLASS_NAME: "SuperMap.REST.TransferSolutionService"
});
SuperMap.REST.TransferSolutionParameters = SuperMap.Class({
    solutionCount: 6,
    transferPreference: SuperMap.REST.TransferPreference.NONE,
    transferTactic: SuperMap.REST.TransferTactic.LESS_TIME,
    walkingRatio: null,
    points: false,
    initialize: function(a) {
        a = a || {};
        SuperMap.Util.extend(this, a)
    },
    destroy: function() {
        SuperMap.Util.reset(this)
    },
    CLASS_NAME: "SuperMap.REST.TransferSolutionParameters"
});
SuperMap.REST.TransferSolutionParameters.toJson = function(a) {
    if (a) {
        return SuperMap.Util.toJSON(a)
    }
}
;
SuperMap.REST.TransferSolutionEventArgs = SuperMap.Class(SuperMap.ServiceEventArgs, {
    result: null,
    initialize: function(a, d) {
        SuperMap.ServiceEventArgs.prototype.initialize.apply(this, [d]);
        var c = this;
        c.result = a
    },
    destroy: function() {
        SuperMap.ServiceEventArgs.prototype.destroy.apply(this);
        SuperMap.Util.reset(this)
    },
    CLASS_NAME: "SuperMap.REST.TransferSolutionEventArgs"
});
SuperMap.REST.TransferSolutionResult = SuperMap.Class({
    transferGuide: null,
    solutionItems: null,
    initialize: function(a) {
        a = a || {};
        SuperMap.Util.extend(this, a)
    },
    destroy: function() {
        SuperMap.Util.reset(this)
    },
    CLASS_NAME: "SuperMap.REST.TransferSolutionResult"
});
SuperMap.REST.TransferSolutionResult.fromJson = function(f) {
    if (!f) {
        return
    }
    var g = f.defaultGuide
      , c = f.solutionItems
      , a = c ? c.length : 0
      , d = [];
    for (var e = 0; e < a; e++) {
        d.push(SuperMap.REST.TransferSolution.fromJson(c[e]))
    }
    return new SuperMap.REST.TransferSolutionResult({
        transferGuide: SuperMap.REST.TransferGuide.fromJson(g),
        solutionItems: d
    })
}
;
SuperMap.REST.ClipParameter = SuperMap.Class({
    clipDatasetName: null,
    clipDatasourceName: null,
    clipRegion: null,
    isClipInRegion: false,
    isExactClip: null,
    initialize: function(a) {
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        var a = this;
        a.clipDatasetName = null;
        a.clipDatasourceName = null;
        a.clipRegion = null;
        a.isClipInRegion = null;
        a.isExactClip = null
    },
    toJSON: function() {
        if (this.isClipInRegion == false) {
            return null
        }
        var c = "";
        var f = this;
        c += "'isClipInRegion':" + SuperMap.Util.toJSON(f.isClipInRegion);
        if (f.clipDatasetName != null) {
            c += ",'clipDatasetName':" + SuperMap.Util.toJSON(f.clipDatasetName)
        }
        if (f.clipDatasourceName != null) {
            c += ",'clipDatasourceName':" + SuperMap.Util.toJSON(f.clipDatasourceName)
        }
        if (f.isExactClip != null) {
            c += ",'isExactClip':" + SuperMap.Util.toJSON(f.isExactClip)
        }
        if (f.clipRegion != null) {
            var e = SuperMap.REST.ServerGeometry.fromGeometry(f.clipRegion);
            if (e) {
                var d = e.parts[0];
                var a = e.points.splice(0, d);
                c += ",'clipRegion':{\"point2Ds\":";
                c += SuperMap.Util.toJSON(a);
                c += "}"
            }
        }
        return "{" + c + "}"
    },
    CLASS_NAME: "SuperMap.REST.ClipParameter"
});
SuperMap.REST.InterpolationAnalystEventArgs = SuperMap.Class(SuperMap.ServiceEventArgs, {
    result: null,
    initialize: function(a, d) {
        SuperMap.ServiceEventArgs.prototype.initialize.apply(this, [d]);
        var c = this;
        c.result = a
    },
    destroy: function() {
        SuperMap.ServiceEventArgs.prototype.destroy.apply(this);
        var a = this;
        if (a.result) {
            a.result.destroy();
            a.result = null
        }
    },
    CLASS_NAME: "SuperMap.REST.InterpolationAnalystEventArgs"
});
SuperMap.REST.InterpolationAnalystParameters = SuperMap.Class({
    bounds: null,
    searchRadius: 0,
    zValueFieldName: null,
    zValueScale: 1,
    resolution: null,
    filterQueryParameter: null,
    outputDatasetName: null,
    outputDatasourceName: null,
    pixelFormat: SuperMap.REST.PixelFormat.BIT16,
    dataset: null,
    inputPoints: null,
    InterpolationAnalystType: "dataset",
    clipParam: null,
    initialize: function(a) {
        if (!a) {
            return
        }
        SuperMap.Util.extend(this, a)
    },
    destroy: function() {
        var a = this;
        a.bounds = null;
        a.searchRadius = null;
        a.zValueFieldName = null;
        a.zValueScale = null;
        a.resolution = null;
        a.filterQueryParameter = null;
        a.outputDatasetName = null;
        a.pixelFormat = null
    },
    CLASS_NAME: "SuperMap.REST.InterpolationAnalystParameters"
});
SuperMap.REST.InterpolationAnalystParameters.toObject = function(a, c) {
    for (var d in a) {
        if (d === "inputPoints" && a.InterpolationAnalystType === "geometry") {
            var h = [];
            for (var e = 0; e < a.inputPoints.length; e++) {
                var f = a.inputPoints[e];
                var g = {
                    x: f.x,
                    y: f.y,
                    z: f.tag
                };
                h.push(g)
            }
            c[d] = h
        } else {
            c[d] = a[d]
        }
    }
}
;
SuperMap.REST.InterpolationAnalystResult = SuperMap.Class(SuperMap.REST.SpatialAnalystResult, {
    recordset: null,
    initialize: function(a) {
        SuperMap.REST.SpatialAnalystResult.prototype.initialize.apply(this, arguments);
        if (!a) {
            return
        }
        SuperMap.Util.extend(this, a)
    },
    destroy: function() {
        SuperMap.REST.SpatialAnalystResult.prototype.destroy.apply(this, arguments);
        var a = this;
        if (a.recordset) {
            a.recordset.destroy();
            a.recordset = null
        }
    },
    CLASS_NAME: "SuperMap.REST.InterpolationAnalystResult"
});
SuperMap.REST.InterpolationAnalystResult.fromJson = function(d) {
    if (!d) {
        return
    }
    var a = new SuperMap.REST.InterpolationAnalystResult();
    if (d.succeed) {
        a.succeed = d.succeed
    }
    for (var c in d) {
        if (c == "recordset") {
            a.recordset = SuperMap.REST.Recordset.fromJson(d.recordset)
        } else {
            a[c] = d[c]
        }
    }
    return a
}
;
SuperMap.REST.InterpolationAnalystService = SuperMap.Class(SuperMap.ServiceBase, {
    EVENT_TYPES: ["processCompleted", "processFailed"],
    events: null,
    eventListeners: null,
    mode: null,
    initialize: function(c, a) {
        SuperMap.ServiceBase.prototype.initialize.apply(this, [c]);
        var d = this;
        if (a) {
            SuperMap.Util.extend(d, a)
        }
        d.events = new SuperMap.Events(d,null,d.EVENT_TYPES,true);
        if (d.eventListeners instanceof Object) {
            d.events.on(d.eventListeners)
        }
    },
    destroy: function() {
        SuperMap.ServiceBase.prototype.destroy.apply(this, arguments);
        var a = this;
        a.EVENT_TYPES = null;
        if (a.events) {
            a.events.destroy();
            a.events = null
        }
        if (a.eventListeners) {
            a.eventListeners = null
        }
        a.mode = null
    },
    processAsync: function(f) {
        var d = new Object();
        var c = this;
        var a = c.url.substr(c.url.length - 1, 1);
        if (a == "/") {} else {
            c.url += "/"
        }
        if (f instanceof SuperMap.REST.InterpolationDensityAnalystParameters) {
            c.mode = "Density";
            if (f.InterpolationAnalystType === "geometry") {
                c.url += "geometry/interpolation/density"
            } else {
                c.url += "datasets/" + f.dataset + "/interpolation/density"
            }
        } else {
            if (f instanceof SuperMap.REST.InterpolationIDWAnalystParameters) {
                c.mode = "IDW";
                if (f.InterpolationAnalystType === "geometry") {
                    c.url += "geometry/interpolation/idw"
                } else {
                    c.url += "datasets/" + f.dataset + "/interpolation/idw"
                }
            } else {
                if (f instanceof SuperMap.REST.InterpolationRBFAnalystParameters) {
                    c.mode = "RBF";
                    if (f.InterpolationAnalystType === "geometry") {
                        c.url += "geometry/interpolation/rbf"
                    } else {
                        c.url += "datasets/" + f.dataset + "/interpolation/rbf"
                    }
                } else {
                    if (f instanceof SuperMap.REST.InterpolationKrigingAnalystParameters) {
                        c.mode = "Kriging";
                        if (f.InterpolationAnalystType === "geometry") {
                            c.url += "geometry/interpolation/kriging"
                        } else {
                            c.url += "datasets/" + f.dataset + "/interpolation/kriging"
                        }
                    }
                }
            }
        }
        SuperMap.REST.InterpolationAnalystParameters.toObject(f, d);
        var e = SuperMap.Util.toJSON(d);
        if (c.isInTheSameDomain) {
            c.url += ".json?returnContent=true"
        } else {
            c.url += ".jsonp?returnContent=true"
        }
        c.request({
            method: "POST",
            data: e,
            scope: c,
            success: c.analyzeComplete,
            failure: c.analyzeError
        })
    },
    analyzeComplete: function(c) {
        c = SuperMap.Util.transformResult(c);
        var a = SuperMap.REST.InterpolationAnalystResult.fromJson(c);
        this.lastResult = a;
        var d = new SuperMap.REST.InterpolationAnalystEventArgs(a,c);
        this.events.triggerEvent("processCompleted", d)
    },
    analyzeError: function(c) {
        var e = this
          , d = null
          , a = null
          , f = null;
        c = SuperMap.Util.transformResult(c);
        d = c.error;
        if (!d) {
            return
        }
        a = SuperMap.ServiceException.fromJson(d);
        f = new SuperMap.ServiceFailedEventArgs(a,c);
        e.events.triggerEvent("processFailed", f)
    },
    CLASS_NAME: "SuperMap.REST.InterpolationAnalystService"
});
SuperMap.REST.InterpolationDensityAnalystParameters = SuperMap.Class(SuperMap.REST.InterpolationAnalystParameters, {
    initialize: function(a) {
        SuperMap.REST.InterpolationAnalystParameters.prototype.initialize.apply(this, arguments);
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        SuperMap.REST.ThiessenAnalystParameters.prototype.destroy.apply(this, arguments)
    },
    CLASS_NAME: "SuperMap.REST.InterpolationDensityAnalystParameters"
});
SuperMap.REST.InterpolationIDWAnalystParameters = SuperMap.Class(SuperMap.REST.InterpolationAnalystParameters, {
    power: 2,
    searchMode: null,
    expectedCount: 12,
    initialize: function(a) {
        SuperMap.REST.InterpolationAnalystParameters.prototype.initialize.apply(this, arguments);
        var c = this;
        c.power = 2;
        c.searchMode = null;
        c.expectedCount = 12;
        if (a) {
            SuperMap.Util.extend(c, a)
        }
    },
    destroy: function() {
        SuperMap.REST.ThiessenAnalystParameters.prototype.destroy.apply(this, arguments);
        var a = this;
        a.power = null;
        a.searchMode = null;
        a.expectedCount = null
    },
    CLASS_NAME: "SuperMap.REST.InterpolationIDWAnalystParameters"
});
SuperMap.REST.InterpolationKrigingAnalystParameters = SuperMap.Class(SuperMap.REST.InterpolationAnalystParameters, {
    type: null,
    mean: null,
    angle: 0,
    nugget: 0,
    range: 0,
    sill: 0,
    variogramMode: SuperMap.REST.VariogramMode.SPHERICAL,
    exponent: SuperMap.REST.Exponent.EXP1,
    searchMode: null,
    expectedCount: 12,
    maxPointCountForInterpolation: 200,
    maxPointCountInNode: 50,
    initialize: function(a) {
        SuperMap.REST.InterpolationAnalystParameters.prototype.initialize.apply(this, arguments);
        var c = this;
        c.type = null;
        c.mean = null;
        c.angle = 0;
        c.nugget = 0;
        c.range = 0;
        c.sill = 0;
        c.variogramMode = "SPHERICAL";
        c.exponent = "EXP1";
        c.searchMode = null;
        c.expectedCount = 12;
        c.maxPointCountForInterpolation = 200;
        c.maxPointCountInNode = 50;
        if (a) {
            SuperMap.Util.extend(c, a)
        }
    },
    destroy: function() {
        SuperMap.REST.ThiessenAnalystParameters.prototype.destroy.apply(this, arguments);
        var a = this;
        a.type = null;
        a.mean = null;
        a.angle = null;
        a.nugget = null;
        a.range = null;
        a.sill = null;
        a.variogramMode = null;
        a.exponent = null;
        a.searchMode = null;
        a.expectedCount = null;
        a.maxPointCountForInterpolation = null;
        a.maxPointCountInNode = null
    },
    CLASS_NAME: "SuperMap.REST.InterpolationKrigingAnalystParameters"
});
SuperMap.REST.InterpolationRBFAnalystParameters = SuperMap.Class(SuperMap.REST.InterpolationAnalystParameters, {
    smooth: 0.1,
    tension: 40,
    searchMode: null,
    expectedCount: 12,
    maxPointCountForInterpolation: 200,
    maxPointCountInNode: 50,
    initialize: function(a) {
        SuperMap.REST.InterpolationAnalystParameters.prototype.initialize.apply(this, arguments);
        var c = this;
        c.smooth = 0.1;
        c.tension = 40;
        c.searchMode = null;
        c.expectedCount = 12;
        c.maxPointCountForInterpolation = 200;
        c.maxPointCountInNode = 50;
        if (a) {
            SuperMap.Util.extend(c, a)
        }
    },
    destroy: function() {
        SuperMap.REST.ThiessenAnalystParameters.prototype.destroy.apply(this, arguments);
        var a = this;
        a.smooth = null;
        a.tension = null;
        a.searchMode = null;
        a.expectedCount = null;
        a.maxPointCountForInterpolation = null;
        a.maxPointCountInNode = null
    },
    CLASS_NAME: "SuperMap.REST.InterpolationRBFAnalystParameters"
});
SuperMap.REST.InterpolationRBFAnalystParameters.toObject = function(d, a) {
    for (var c in d) {
        a[c] = d[c]
    }
}
;
SuperMap.REST.InterpolationRBFAnalystParameters = SuperMap.Class(SuperMap.REST.InterpolationAnalystParameters, {
    smooth: 0.1,
    tension: 40,
    searchMode: null,
    expectedCount: 12,
    maxPointCountForInterpolation: 200,
    maxPointCountInNode: 50,
    initialize: function(a) {
        SuperMap.REST.InterpolationAnalystParameters.prototype.initialize.apply(this, arguments);
        var c = this;
        c.smooth = 0.1;
        c.tension = 40;
        c.searchMode = null;
        c.expectedCount = 12;
        c.maxPointCountForInterpolation = 200;
        c.maxPointCountInNode = 50;
        if (a) {
            SuperMap.Util.extend(c, a)
        }
    },
    destroy: function() {
        SuperMap.REST.ThiessenAnalystParameters.prototype.destroy.apply(this, arguments);
        var a = this;
        a.smooth = null;
        a.tension = null;
        a.searchMode = null;
        a.expectedCount = null;
        a.maxPointCountForInterpolation = null;
        a.maxPointCountInNode = null
    },
    CLASS_NAME: "SuperMap.REST.InterpolationRBFAnalystParameters"
});
SuperMap.REST.GetLayersInfoService = SuperMap.Class(SuperMap.ServiceBase, {
    EVENT_TYPES: ["processCompleted", "processFailed"],
    events: null,
    eventListeners: null,
    lastResult: null,
    isTempLayers: false,
    initialize: function(c, a) {
        SuperMap.ServiceBase.prototype.initialize.apply(this, [c]);
        if (a) {
            SuperMap.Util.extend(this, a)
        }
        var d = this;
        d.events = new SuperMap.Events(d,null,d.EVENT_TYPES,true);
        if (d.eventListeners instanceof Object) {
            d.events.on(d.eventListeners)
        }
    },
    destroy: function() {
        SuperMap.ServiceBase.prototype.destroy.apply(this, arguments);
        SuperMap.Util.reset(this)
    },
    processAsync: function() {
        var a = this
          , c = "GET";
        end = a.url.substr(a.url.length - 1, 1);
        if (!a.isTempLayers) {
            a.url += (end === "/") ? "" : "/";
            a.url += a.isInTheSameDomain ? "layers.json?" : "layers.jsonp?"
        } else {
            a.url += a.isInTheSameDomain ? ".json?" : ".jsonp?"
        }
        a.request({
            method: c,
            params: null,
            scope: a,
            success: a.getLayerComplted,
            failure: a.getLayerFailed
        })
    },
    getLayerComplted: function(m) {
        var h = this, j, d, a, k, e, f = 0;
        m = SuperMap.Util.transformResult(m);
        layerResult = SuperMap.Util.JSONClone({}, m);
        k = !!layerResult && layerResult.length > 0;
        e = k ? layerResult[0].subLayers.layers : null;
        f = e ? e.length : 0;
        if (f) {
            for (var c = 0; c < f; c++) {
                var g = e[c].ugcLayerType;
                switch (g) {
                case "THEME":
                    j = new SuperMap.REST.ServerTheme();
                    j.fromJson(e[c]);
                    e[c] = j;
                    break;
                case "GRID":
                    j = new SuperMap.REST.Grid();
                    j.fromJson(e[c]);
                    e[c] = j;
                    break;
                case "IMAGE":
                    j = new SuperMap.REST.Image();
                    j.fromJson(e[c]);
                    e[c] = j;
                    break;
                case "VECTOR":
                    j = new SuperMap.REST.Vector();
                    j.fromJson(e[c]);
                    e[c] = j;
                    break;
                case "WFS":
                    break;
                case "WMS":
                    break
                }
            }
            h.lastResult = layerResult[0];
            var l = new SuperMap.REST.GetLayersInfoEventArgs(layerResult[0],m);
            h.events.triggerEvent("processCompleted", l)
        }
    },
    getLayerFailed: function(c) {
        var f = this
          , e = null
          , a = null
          , d = null;
        c = SuperMap.Util.transformResult(c);
        e = c.error;
        if (!e) {
            return
        }
        a = SuperMap.ServiceException.fromJson(e);
        d = new SuperMap.ServiceFailedEventArgs(a,c);
        f.events.triggerEvent("processFailed", d)
    },
    CLASS_NAME: "SuperMap.REST.GetLayersInfoService"
});
SuperMap.REST.SetLayersInfoService = SuperMap.Class(SuperMap.ServiceBase, {
    EVENT_TYPES: ["processCompleted", "processFailed"],
    events: null,
    eventListeners: null,
    lastResult: null,
    resourceID: null,
    isTempLayers: false,
    initialize: function(c, a) {
        SuperMap.ServiceBase.prototype.initialize.apply(this, [c]);
        if (a) {
            SuperMap.Util.extend(this, a)
        }
        var d = this;
        d.events = new SuperMap.Events(d,null,d.EVENT_TYPES,true);
        if (d.eventListeners instanceof Object) {
            d.events.on(d.eventListeners)
        }
    },
    destroy: function() {
        SuperMap.ServiceBase.prototype.destroy.apply(this, arguments);
        SuperMap.Util.reset(this)
    },
    processAsync: function(e) {
        var m, h = [], n = this, a = "";
        if (!e) {
            return
        }
        end = n.url.substr(n.url.length - 1, 1);
        n.url += (end === "/") ? "" : "/";
        if (n.isTempLayers) {
            n.url += "tempLayersSet/" + n.resourceID;
            a = "PUT"
        } else {
            n.url += "tempLayersSet";
            a = "POST"
        }
        n.url += n.isInTheSameDomain ? ".json?" : ".jsonp?";
        var g = e.subLayers.layers
          , l = g.length;
        for (var k in g) {
            if (g[k].ugcLayerType === "GRID") {
                var d = {};
                var c = g[k].colorDictionarys;
                for (var f in c) {
                    var o = c[f].elevation;
                    d[o] = c[f].color
                }
            }
            g[k].colorDictionary = d;
            delete g[k].colorDictionarys
        }
        for (var k = 0; k < l; k++) {
            if (g[k].toJsonObject) {
                h.push(g[k].toJsonObject())
            } else {
                h.push(g[k])
            }
        }
        m = SuperMap.Util.extend(m, e);
        m.subLayers = {
            layers: h
        };
        m.object = null;
        var p = SuperMap.Util.toJSON([m]);
        n.request({
            method: a,
            data: p,
            scope: n,
            success: n.setLayerComplted,
            failure: n.setLayerFailed
        })
    },
    setLayerComplted: function(a) {
        var c = this, e;
        a = SuperMap.Util.transformResult(a);
        e = SuperMap.REST.SetLayersInfoResult.fromJson(a);
        var d = e.succeed;
        if (d) {
            var f = new SuperMap.REST.SetLayersInfoEventArgs(e,a);
            c.lastResult = e;
            c.events.triggerEvent("processCompleted", f)
        }
    },
    setLayerFailed: function(c) {
        var f = this
          , e = null
          , a = null
          , d = null;
        c = SuperMap.Util.transformResult(c);
        e = c.error;
        if (!e) {
            return
        }
        a = SuperMap.ServiceException.fromJson(e);
        d = new SuperMap.ServiceFailedEventArgs(a,c);
        f.events.triggerEvent("processFailed", d)
    },
    CLASS_NAME: "SuperMap.REST.SetLayersInfoService"
});
SuperMap.REST.SetLayersInfoEventArgs = SuperMap.Class(SuperMap.ServiceEventArgs, {
    result: null,
    initialize: function(a, d) {
        SuperMap.ServiceEventArgs.prototype.initialize.apply(this, [d]);
        var c = this;
        c.result = a
    },
    destroy: function() {
        SuperMap.ServiceEventArgs.prototype.destroy.apply(this, arguments);
        var a = this;
        if (a.result) {
            a.result = null
        }
    },
    CLASS_NAME: "SuperMap.REST.SetLayersInfoEventArgs"
});
SuperMap.REST.GetLayersInfoEventArgs = SuperMap.Class(SuperMap.ServiceEventArgs, {
    result: null,
    initialize: function(a, d) {
        SuperMap.ServiceEventArgs.prototype.initialize.apply(this, [d]);
        var c = this;
        c.result = a
    },
    destroy: function() {
        SuperMap.ServiceEventArgs.prototype.destroy.apply(this, arguments);
        var a = this;
        if (a.result) {
            SuperMap.Util.reset(a.result);
            a.result = null
        }
    },
    CLASS_NAME: "SuperMap.REST.GetLayersInfoEventArgs"
});
SuperMap.REST.SetLayersInfoResult = SuperMap.Class({
    succeed: null,
    newResourceID: null,
    newResourceLocation: null,
    initialize: function(a) {
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        var a = this;
        a.succeed = null;
        a.newResourceID = null;
        a.newResourceLocation = null
    },
    CLASS_NAME: "SuperMap.REST.SetLayersInfoResult"
});
SuperMap.REST.SetLayersInfoResult.fromJson = function(a) {
    if (!a) {
        return
    }
    return new SuperMap.REST.SetLayersInfoResult({
        succeed: a.succeed,
        newResourceID: a.newResourceID,
        newResourceLocation: a.newResourceLocation
    })
}
;
SuperMap.REST.OverlapDisplayedOptions = SuperMap.Class({
    allowPointOverlap: true,
    allowPointWithTextDisplay: true,
    allowTextOverlap: false,
    allowTextAndPointOverlap: true,
    allowThemeGraduatedSymbolOverlap: false,
    allowThemeGraphOverlap: false,
    horizontalOverlappedSpaceSize: 0,
    verticalOverlappedSpaceSize: 0,
    initialize: function(a) {
        a = a || {};
        SuperMap.Util.extend(this, a)
    },
    destroy: function() {
        SuperMap.Util.reset(this)
    },
    fromJson: function(a) {
        SuperMap.REST.UGCLayer.prototype.fromJson.apply(this, [a])
    },
    toServerJSONObject: function() {
        var a = SuperMap.REST.UGCLayer.prototype.toServerJSONObject.apply(this, arguments);
        return a
    },
    toString: function() {
        var c = SuperMap.REST.UGCLayer.prototype.toServerJSONObject.apply(this, arguments);
        var d = "{";
        for (var a in c) {
            if (c.hasOwnProperty(a)) {
                d += "'" + a + "':" + c[a] + ","
            }
        }
        d = d.substr(0, d.length - 1);
        d += "}";
        return d
    },
    CLASS_NAME: "SuperMap.REST.OverlapDisplayedOptions"
});
SuperMap.REST.ColorDictionary = SuperMap.Class({
    elevation: null,
    color: null,
    initialize: function(a) {
        a = a || {};
        SuperMap.Util.extend(this, a);
        var d = this
          , e = d.color;
        if (e) {
            d.color = new SuperMap.REST.ServerColor(e.red,e.green,e.blue)
        }
    },
    destroy: function() {
        SuperMap.Util.reset(this)
    },
    toServerJSONObject: function() {
        var a = {};
        a = SuperMap.Util.copyAttributes(a, this);
        return a
    },
    CLASS_NAME: "SuperMap.REST.ColorDictionary"
});
SuperMap.REST.UGCLayer = SuperMap.Class({
    bounds: null,
    caption: null,
    description: null,
    name: null,
    queryable: null,
    subLayers: null,
    type: null,
    visible: null,
    initialize: function(a) {
        a = a ? a : {};
        SuperMap.Util.extend(this, a)
    },
    destroy: function() {
        var a = this;
        SuperMap.Util.reset(a)
    },
    fromJson: function(c) {
        c = c ? c : {};
        SuperMap.Util.extend(this, c);
        var a = this.bounds;
        if (a) {
            this.bounds = new SuperMap.Bounds(a.leftBottom.x,a.leftBottom.y,a.rightTop.x,a.rightTop.y)
        }
    },
    toServerJSONObject: function() {
        var a = {};
        a = SuperMap.Util.copyAttributes(a, this);
        if (a.bounds) {
            if (a.bounds.toServerJSONObject) {
                a.bounds = a.bounds.toServerJSONObject()
            }
        }
        return a
    },
    CLASS_NAME: "SuperMap.REST.UGCLayer"
});
SuperMap.REST.UGCMapLayer = SuperMap.Class(SuperMap.REST.UGCLayer, {
    completeLineSymbolDisplayed: null,
    maxScale: null,
    minScale: null,
    minVisibleGeometrySize: null,
    opaqueRate: null,
    symbolScalable: null,
    symbolScale: null,
    overlapDisplayed: null,
    overlapDisplayedOptions: null,
    initialize: function(a) {
        a = a || {};
        SuperMap.REST.UGCLayer.prototype.initialize.apply(this, [a])
    },
    destroy: function() {
        SuperMap.REST.UGCLayer.prototype.destroy.apply(this, arguments);
        SuperMap.Util.reset(this)
    },
    fromJson: function(a) {
        SuperMap.REST.UGCLayer.prototype.fromJson.apply(this, [a])
    },
    toServerJSONObject: function() {
        var a = SuperMap.REST.UGCLayer.prototype.toServerJSONObject.apply(this, arguments);
        return a
    },
    CLASS_NAME: "SuperMap.REST.UGCMapLayer"
});
SuperMap.REST.UGCSubLayer = SuperMap.Class(SuperMap.REST.UGCMapLayer, {
    datasetInfo: null,
    displayFilter: null,
    joinItems: null,
    representationField: null,
    ugcLayerType: null,
    initialize: function(a) {
        a = a || {};
        SuperMap.REST.UGCMapLayer.prototype.initialize.apply(this, [a])
    },
    fromJson: function(d) {
        SuperMap.REST.UGCMapLayer.prototype.fromJson.apply(this, [d]);
        if (this.datasetInfo) {
            this.datasetInfo = new SuperMap.REST.DatasetInfo(this.datasetInfo)
        }
        if (this.joinItems && this.joinItems.length) {
            var a = [];
            for (var c = 0; c < this.joinItems.length; c++) {
                a[c] = new SuperMap.REST.JoinItem(this.joinItems[c])
            }
            this.joinItems = a
        }
    },
    destroy: function() {
        SuperMap.REST.UGCMapLayer.prototype.destroy.apply(this, arguments);
        SuperMap.Util.reset(this)
    },
    toServerJSONObject: function() {
        var c = SuperMap.REST.UGCMapLayer.prototype.toServerJSONObject.apply(this, arguments);
        if (c.joinItems) {
            var d = [];
            for (var a = 0; a < c.joinItems.length; a++) {
                if (c.joinItems[a].toServerJSONObject) {
                    d[a] = c.joinItems[a].toServerJSONObject()
                }
            }
            c.joinItems = d
        }
        if (c.datasetInfo) {
            if (c.datasetInfo.toServerJSONObject) {
                c.datasetInfo = c.datasetInfo.toServerJSONObject()
            }
        }
        return c
    },
    CLASS_NAME: "SuperMap.REST.UGCSubLayer"
});
SuperMap.REST.Grid = SuperMap.Class(SuperMap.REST.UGCSubLayer, {
    colorDictionarys: null,
    brightness: null,
    colorGradientType: null,
    colors: null,
    contrast: null,
    dashStyle: null,
    gridType: null,
    horizontalSpacing: null,
    sizeFixed: null,
    solidStyle: null,
    specialColor: null,
    specialValue: null,
    specialValueTransparent: null,
    verticalSpacing: null,
    initialize: function(a) {
        a = a || {};
        SuperMap.REST.UGCSubLayer.prototype.initialize.apply(this, [a])
    },
    destroy: function() {
        SuperMap.REST.UGCSubLayer.prototype.destroy.apply(this, arguments);
        SuperMap.Util.reset(this)
    },
    fromJson: function(g) {
        SuperMap.REST.UGCSubLayer.prototype.fromJson.apply(this, [g]);
        if (this.specialColor) {
            this.specialColor = new SuperMap.REST.ServerColor(this.specialColor.red,this.specialColor.green,this.specialColor.blue)
        }
        if (this.colors) {
            var a = [], d;
            for (var f in this.colors) {
                d = this.colors[f];
                a.push(new SuperMap.REST.ServerColor(d.red,d.green,d.blue))
            }
            this.colors = a
        }
        if (this.dashStyle) {
            this.dashStyle = new SupweMap.REST.ServerStyle(this.dashStyle)
        }
        if (this.solidStyle) {
            this.solidStyle = new SupweMap.REST.ServerStyle(this.solidStyle)
        }
        if (this.colorDictionary) {
            var h = [], c;
            for (var e in this.colorDictionary) {
                c = this.colorDictionary[e];
                h.push(new SuperMap.REST.ColorDictionary({
                    elevation: e,
                    color: c
                }))
            }
            this.colorDictionarys = h
        }
        delete this.colorDictionary
    },
    toServerJSONObject: function() {
        var a = SuperMap.REST.UGCSubLayer.prototype.toServerJSONObject.apply(this, arguments);
        if (a.dashStyle) {
            if (a.dashStyle.toServerJSONObject) {
                a.dashStyle = a.dashStyle.toServerJSONObject()
            }
        }
        if (a.solidStyle) {
            if (a.solidStyle.toServerJSONObject) {
                a.solidStyle = a.solidStyle.toServerJSONObject()
            }
        }
        return a
    },
    CLASS_NAME: "SuperMap.REST.Grid"
});
SuperMap.REST.Image = SuperMap.Class(SuperMap.REST.UGCSubLayer, {
    brightness: null,
    colorSpaceType: null,
    contrast: null,
    displayBandIndexes: null,
    transparent: null,
    transparentColor: null,
    transparentColorTolerance: null,
    initialize: function(a) {
        a = a || {};
        SuperMap.REST.UGCSubLayer.prototype.initialize.apply(this, [a])
    },
    destroy: function() {
        SuperMap.REST.UGCSubLayer.prototype.destroy.apply(this, arguments);
        SuperMap.Util.reset(this)
    },
    fromJson: function(a) {
        SuperMap.REST.UGCSubLayer.prototype.fromJson.apply(this, [a]);
        if (this.transparentColor) {
            this.transparentColor = new SuperMap.REST.ServerColor(this.transparentColor.red,this.transparentColor.green,this.transparentColor.blue)
        }
    },
    toServerJSONObject: function() {
        var a = SuperMap.REST.UGCSubLayer.prototype.toServerJSONObject.apply(this, arguments);
        return a
    },
    CLASS_NAME: "SuperMap.REST.Image"
});
SuperMap.REST.ServerTheme = SuperMap.Class(SuperMap.REST.UGCSubLayer, {
    theme: null,
    themeElementPosition: null,
    initialize: function(a) {
        a = a || {};
        SuperMap.REST.UGCSubLayer.prototype.initialize.apply(this, [a])
    },
    destroy: function() {
        SuperMap.REST.UGCSubLayer.prototype.destroy.apply(this, arguments);
        SuperMap.Util.reset(this)
    },
    fromJson: function(c) {
        SuperMap.REST.UGCSubLayer.prototype.fromJson.apply(this, [c]);
        var a = this.theme;
        var d = a && a.type;
        switch (d) {
        case "LABEL":
            this.theme = SuperMap.REST.ThemeLabel.fromObj(a);
            break;
        case "UNIQUE":
            this.theme = SuperMap.REST.ThemeUnique.fromObj(a);
            break;
        case "GRAPH":
            this.theme = SuperMap.REST.ThemeGraph.fromObj(a);
            break;
        case "DOTDENSITY":
            this.theme = SuperMap.REST.ThemeDotDensity.fromObj(a);
            break;
        case "GRADUATEDSYMBOL":
            this.theme = SuperMap.REST.ThemeGraduatedSymbol.fromObj(a);
            break;
        case "RANGE":
            this.theme = SuperMap.REST.ThemeRange.fromObj(a);
            break
        }
        if (this.themeElementPosition) {
            this.themeElementPosition = new SuperMap.LonLat(this.themeElementPosition.x,this.themeElementPosition.y)
        }
    },
    toServerJSONObject: function() {
        var a = SuperMap.REST.UGCSubLayer.prototype.toServerJSONObject.apply(this, arguments);
        if (a.themeElementPosition) {
            if (a.themeElementPosition.toServerJSONObject) {
                a.themeElementPosition = a.themeElementPosition.toServerJSONObject()
            }
        }
        if (a.theme) {
            if (a.theme.toServerJSONObject) {
                a.theme = a.theme.toServerJSONObject()
            }
        }
        return a
    },
    CLASS_NAME: "SuperMap.REST.ServerTheme"
});
SuperMap.REST.Vector = SuperMap.Class(SuperMap.REST.UGCSubLayer, {
    style: null,
    initialize: function(a) {
        a = a || {};
        SuperMap.REST.UGCSubLayer.prototype.initialize.apply(this, [a])
    },
    destroy: function() {
        SuperMap.REST.UGCSubLayer.prototype.destroy.apply(this, arguments);
        SuperMap.Util.reset(this)
    },
    fromJson: function(c) {
        SuperMap.REST.UGCSubLayer.prototype.fromJson.apply(this, [c]);
        var a = this.style;
        if (a) {
            this.style = new SuperMap.REST.ServerStyle(a)
        }
    },
    toServerJSONObject: function() {
        var a = SuperMap.REST.UGCSubLayer.prototype.toServerJSONObject.apply(this, arguments);
        if (a.style) {
            if (a.style.toServerJSONObject) {
                a.style = a.style.toServerJSONObject()
            }
        }
        return a
    },
    CLASS_NAME: "SuperMap.REST.Vector"
});
SuperMap.REST.DatasetInfo = SuperMap.Class({
    bounds: null,
    dataSourceName: null,
    description: null,
    encodeType: null,
    isReadOnly: null,
    name: null,
    prjCoordSys: null,
    tableName: null,
    type: null,
    initialize: function(c) {
        c = c || {};
        SuperMap.Util.extend(this, c);
        var a = this.bounds;
        if (a) {
            this.bounds = new SuperMap.Bounds(a.leftBottom.x,a.leftBottom.y,a.rightTop.x,a.rightTop.y)
        }
    },
    destroy: function() {
        SuperMap.Util.reset(this)
    },
    toServerJSONObject: function() {
        var a = {};
        a = SuperMap.Util.copyAttributes(a, this);
        if (a.bounds) {
            if (a.bounds.toServerJSONObject) {
                a.bounds = a.bounds.toServerJSONObject()
            }
        }
        return a
    },
    CLASS_NAME: "SuperMap.REST.DatasetInfo"
});
SuperMap.REST.ChartAttributeSpec = SuperMap.Class({
    code: null,
    required: null,
    initialize: function(a) {
        if (!a) {
            return
        }
        SuperMap.Util.extend(this, a)
    },
    destroy: function() {
        var a = this;
        a.code = null;
        a.required = null
    },
    fromJson: function(c) {
        var a = new SuperMap.REST.ChartAttributeSpec();
        if (c) {
            if (c.code != null) {
                a.code = c.code
            }
            if (c.required) {
                a.required = c.required
            }
        }
        return a
    },
    CLASS_NAME: "SuperMap.REST.ChartAttributeSpec"
});
SuperMap.REST.ChartFeatureInfoSpec = SuperMap.Class({
    acronym: null,
    code: null,
    localName: null,
    name: null,
    primitive: null,
    attributeFields: null,
    initialize: function(a) {
        if (!a) {
            return
        }
        SuperMap.Util.extend(this, a)
    },
    destroy: function() {
        var a = this;
        a.acronym = null,
        a.code = null,
        a.localName = null,
        a.name = null,
        a.primitive = null,
        a.attributeFields = null
    },
    fromJson: function(a) {
        var f = new SuperMap.REST.ChartFeatureInfoSpec();
        if (a) {
            if (a.acronym) {
                f.acronym = a.acronym
            }
            if (a.code != null) {
                f.code = a.code
            }
            if (a.localName) {
                f.localName = a.localName
            }
            if (a.name) {
                f.name = a.name
            }
            if (a.primitive) {
                f.primitive = a.primitive
            }
            if (a.attributeFields) {
                var c = new SuperMap.REST.ChartAttributeSpec();
                var e = [];
                for (var d in a.attributeFields) {
                    e.push(c.fromJson(a.attributeFields[d]))
                }
                f.attributeFields = e
            }
        }
        return f
    },
    CLASS_NAME: "SuperMap.REST.ChartFeatureInfoSpec"
});
SuperMap.REST.ChartFeatureInfoSpecsResult = SuperMap.Class({
    chartFeatureInfoSpecs: null,
    initialize: function(a) {
        if (!a) {
            return
        }
        SuperMap.Util.extend(this, a)
    },
    destroy: function() {
        var a = this;
        a.chartFeatureInfoSpecs = null
    },
    fromJson: function(c) {
        if (c == null) {
            return null
        }
        var a = new SuperMap.REST.ChartFeatureInfoSpecsResult();
        var f = [];
        var e = new SuperMap.REST.ChartFeatureInfoSpec();
        for (var d in c) {
            f.push(e.fromJson(c[d]))
        }
        a.chartFeatureInfoSpecs = f;
        return a
    },
    CLASS_NAME: "SuperMap.REST.ChartFeatureInfoSpecsResult"
});
SuperMap.REST.ChartFeatureInfoSpecsService = SuperMap.Class(SuperMap.ServiceBase, {
    EVENT_TYPES: ["processCompleted", "processFailed"],
    events: null,
    eventListeners: null,
    result: null,
    initialize: function(c, a) {
        SuperMap.ServiceBase.prototype.initialize.apply(this, [c]);
        if (a) {
            SuperMap.Util.extend(this, a)
        }
        var d = this;
        d.events = new SuperMap.Events(d,null,d.EVENT_TYPES,true);
        if (d.eventListeners instanceof Object) {
            d.events.on(d.eventListeners)
        }
    },
    destroy: function() {
        SuperMap.ServiceBase.prototype.destroy.apply(this, arguments);
        SuperMap.Util.reset(this)
    },
    processAsync: function() {
        var a = this
          , c = "GET";
        end = a.url.substr(a.url.length - 1, 1);
        if (!a.isTempLayers) {
            a.url += (end === "/") ? "" : "/";
            a.url += a.isInTheSameDomain ? "chartFeatureInfoSpecs.json?" : "chartFeatureInfoSpecs.jsonp?"
        } else {
            a.url += a.isInTheSameDomain ? ".json?" : ".jsonp?"
        }
        a.request({
            method: c,
            params: null,
            scope: a,
            success: a.getFeatureComplted,
            failure: a.getFeatureFailed
        })
    },
    getFeatureComplted: function(a) {
        var d = this
          , c = null
          , e = null;
        a = SuperMap.Util.transformResult(a);
        if (d.returnContent) {
            e = SuperMap.REST.QueryResult.fromJson(a)
        } else {
            e = new SuperMap.REST.QueryResult();
            if (a.customResult) {
                e.customResponse = new SuperMap.Bounds(a.customResult.left,a.customResult.bottom,a.customResult.right,a.customResult.top)
            }
            e.resourceInfo = SuperMap.REST.ResourceInfo.fromJson(a)
        }
        d.lastResult = e;
        c = new SuperMap.REST.QueryEventArgs(e,a);
        d.events.triggerEvent("processCompleted", c)
    },
    getFeatureFailed: function(c) {
        var f = this
          , e = null
          , a = null
          , d = null;
        c = SuperMap.Util.transformResult(c);
        e = c.error;
        if (!e) {
            return
        }
        a = SuperMap.ServiceException.fromJson(e);
        d = new SuperMap.ServiceFailedEventArgs(a,c);
        f.events.triggerEvent("processFailed", d)
    },
    CLASS_NAME: "SuperMap.REST.ChartFeatureInfoSpecsService"
});
SuperMap.REST.LayerStatus = SuperMap.Class({
    layerName: null,
    isVisible: null,
    displayFilter: null,
    initialize: function(a) {
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        var a = this;
        a.layerName = null;
        a.isVisible = null;
        a.displayFilter = null
    },
    toJSON: function() {
        var c = "{";
        c += '"type":"UGC",';
        var a = [];
        if (this.layerName) {
            a.push('"name":"' + this.layerName + '"');
            a.push('"visible":' + this.isVisible)
        }
        if (this.displayFilter) {
            a.push('"displayFilter":"' + this.displayFilter + '"')
        }
        c += a;
        c += "}";
        return c
    },
    CLASS_NAME: "SuperMap.REST.LayerStatus"
});
SuperMap.REST.SetLayerStatusParameters = SuperMap.Class({
    layerStatusList: null,
    holdTime: null,
    resourceID: null,
    initialize: function(a) {
        if (a) {
            SuperMap.Util.extend(this, a)
        }
        var c = this;
        c.layerStatusList = []
    },
    destroy: function() {
        var a = this;
        a.layerStatusList = null;
        a.holdTime = null;
        a.resourceID = null
    },
    toJSON: function() {
        var e = "{";
        e += '"layers":[';
        var c = [];
        for (var d = 0, a = this.layerStatusList.length; d < a; d++) {
            c.push(this.layerStatusList[d].toJSON())
        }
        e += c;
        e += "]";
        e += "}";
        return e
    },
    CLASS_NAME: "SuperMap.REST.SetLayerStatusParameters"
});
SuperMap.REST.SetLayerResult = SuperMap.Class({
    succeed: null,
    newResourceID: null,
    initialize: function(a) {
        if (a) {
            SuperMap.Util.extend(this, a)
        }
    },
    destroy: function() {
        var a = this;
        a.succeed = null;
        a.newResourceID = null
    },
    CLASS_NAME: "SuperMap.REST.SetLayerResult"
});
SuperMap.REST.SetLayerResult.fromJson = function(a) {
    if (!a) {
        return
    }
    return new SuperMap.REST.SetLayerResult({
        succeed: a.succeed,
        newResourceID: a.newResourceID
    })
}
;
SuperMap.REST.SetLayersStatusEventArgs = SuperMap.Class(SuperMap.ServiceEventArgs, {
    result: null,
    initialize: function(a, d) {
        SuperMap.ServiceEventArgs.prototype.initialize.apply(this, [d]);
        var c = this;
        c.result = a
    },
    destroy: function() {
        SuperMap.ServiceEventArgs.prototype.destroy.apply(this, arguments);
        var a = this;
        if (a.result) {
            a.result = null
        }
    },
    CLASS_NAME: "SuperMap.REST.SetLayersStatusEventArgs"
});
SuperMap.REST.SetLayerStatusService = SuperMap.Class(SuperMap.ServiceBase, {
    EVENT_TYPES: ["processCompleted", "processFailed"],
    events: null,
    lastResult: null,
    lastparams: null,
    mapUrl: null,
    initialize: function(a) {
        SuperMap.ServiceBase.prototype.initialize.apply(this, [a]);
        var c = this;
        c.events = new SuperMap.Events(c,null,c.EVENT_TYPES,true);
        if (c.eventListeners instanceof Object) {
            c.events.on(c.eventListeners)
        }
        c.mapUrl = a
    },
    destroy: function() {
        SuperMap.ServiceBase.prototype.destroy.apply(this, arguments);
        SuperMap.Util.reset(this)
    },
    processAsync: function(f) {
        var d = []
          , c = this
          , g = "POST";
        if (!f) {
            return
        }
        c.url = c.mapUrl;
        var a = c.url.substr(c.url.length - 1, 1);
        c.url += (a === "/") ? "" : "/";
        if (f.resourceID == null) {
            c.url += "tempLayersSet";
            c.url += c.isInTheSameDomain ? ".json?" : ".jsonp?";
            c.lastparams = f;
            c.request({
                method: g,
                scope: c,
                success: c.createTempLayerComplete
            })
        } else {
            c.url += "tempLayersSet/" + f.resourceID;
            c.url += c.isInTheSameDomain ? ".json?" : ".jsonp?";
            c.url += "elementRemain=true&reference=" + f.resourceID + "&holdTime=" + f.holdTime.toString() + "&_method=PUT";
            var e = "[{";
            e += '"type":"UGC",';
            if (f.layerStatusList != null && f.layerStatusList.length > 0) {
                e += '"subLayers":' + f.toJSON()
            }
            e += ',"visible":' + true + ",";
            e += '"name":"' + this.getMapName(this.mapUrl) + '"';
            e += "}]";
            c.request({
                method: "PUT",
                data: e,
                scope: c,
                success: c.setLayerComplted
            })
        }
    },
    createTempLayerComplete: function(a) {
        var c = this;
        a = SuperMap.Util.transformResult(a);
        if (a.succeed) {
            c.lastparams.resourceID = a.newResourceID
        }
        c.processAsync(c.lastparams)
    },
    getMapName: function(c) {
        var e = c;
        if (e.charAt(e.length - 1) == "/") {
            e = e.substr(0, e.length - 1)
        }
        var a = e.lastIndexOf("/");
        var d = e.substring(a + 1, e.length);
        return d
    },
    setLayerComplted: function(a) {
        var c = this, f;
        a = SuperMap.Util.transformResult(a);
        f = SuperMap.REST.SetLayerResult.fromJson(a);
        var e = f.succeed;
        if (e) {
            var d = new SuperMap.REST.SetLayersStatusEventArgs(f,a);
            c.lastResult = f;
            if (d.result != null && c.lastparams != null) {
                d.result.newResourceID = c.lastparams.resourceID;
                c.lastResult.newResourceID = c.lastparams.resourceID
            }
            c.events.triggerEvent("processCompleted", d)
        }
    },
    setLayerFailed: function(c) {
        var f = this
          , e = null
          , a = null
          , d = null
    },
    CLASS_NAME: "SuperMap.REST.SetLayerStatusService"
});
